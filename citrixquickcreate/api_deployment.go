/*
Quick Create Service for DaaS Quick Deploy with AWS WorkSpaces Core - Tech Preview

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: DaaSTechPreview
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixquickcreate

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// DeploymentQCSService DeploymentQCS service
type DeploymentQCSService service

type DeploymentQCSAddMachineAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	citrixTransactionId *string
	body                *AddAwsEdcDeploymentMachines
}

// The Transaction Id.
func (r DeploymentQCSAddMachineAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSAddMachineAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Configuration of machine
func (r DeploymentQCSAddMachineAsyncRequest) Body(body AddAwsEdcDeploymentMachines) DeploymentQCSAddMachineAsyncRequest {
	r.body = &body
	return r
}

func (r DeploymentQCSAddMachineAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.AddMachineAsyncExecute(r)
}

/*
AddMachineAsync Adds machine to deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@return DeploymentQCSAddMachineAsyncRequest
*/
func (a *DeploymentQCSService) AddMachineAsync(ctx context.Context, customerId string, deploymentId string) DeploymentQCSAddMachineAsyncRequest {
	return DeploymentQCSAddMachineAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) AddMachineAsyncExecute(r DeploymentQCSAddMachineAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.AddMachineAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/$addMachines"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSDeleteDeploymentAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	forceDelete         *bool
	citrixTransactionId *string
}

// Force delete deployment
func (r DeploymentQCSDeleteDeploymentAsyncRequest) ForceDelete(forceDelete bool) DeploymentQCSDeleteDeploymentAsyncRequest {
	r.forceDelete = &forceDelete
	return r
}

// The Transaction Id.
func (r DeploymentQCSDeleteDeploymentAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSDeleteDeploymentAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

func (r DeploymentQCSDeleteDeploymentAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.DeleteDeploymentAsyncExecute(r)
}

/*
DeleteDeploymentAsync Delete deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@return DeploymentQCSDeleteDeploymentAsyncRequest
*/
func (a *DeploymentQCSService) DeleteDeploymentAsync(ctx context.Context, customerId string, deploymentId string) DeploymentQCSDeleteDeploymentAsyncRequest {
	return DeploymentQCSDeleteDeploymentAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) DeleteDeploymentAsyncExecute(r DeploymentQCSDeleteDeploymentAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.DeleteDeploymentAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDelete", r.forceDelete, "form", "")
	} else {
		var defaultValue bool = false
		r.forceDelete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSGetDeploymentAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	citrixTransactionId *string
}

// The Transaction Id.
func (r DeploymentQCSGetDeploymentAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSGetDeploymentAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

func (r DeploymentQCSGetDeploymentAsyncRequest) Execute() (*AwsEdcDeployment, *http.Response, error) {
	return r.ApiService.GetDeploymentAsyncExecute(r)
}

/*
GetDeploymentAsync Gets deployment with vdas

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@return DeploymentQCSGetDeploymentAsyncRequest
*/
func (a *DeploymentQCSService) GetDeploymentAsync(ctx context.Context, customerId string, deploymentId string) DeploymentQCSGetDeploymentAsyncRequest {
	return DeploymentQCSGetDeploymentAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return AwsEdcDeployment
func (a *DeploymentQCSService) GetDeploymentAsyncExecute(r DeploymentQCSGetDeploymentAsyncRequest) (*AwsEdcDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsEdcDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.GetDeploymentAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSGetDeploymentsAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	includeVdas         *bool
	accountType         *AccountType
	citrixTransactionId *string
}

// Indicates if the deployment VDAs should be included in the response
func (r DeploymentQCSGetDeploymentsAsyncRequest) IncludeVdas(includeVdas bool) DeploymentQCSGetDeploymentsAsyncRequest {
	r.includeVdas = &includeVdas
	return r
}

// Account Type
func (r DeploymentQCSGetDeploymentsAsyncRequest) AccountType(accountType AccountType) DeploymentQCSGetDeploymentsAsyncRequest {
	r.accountType = &accountType
	return r
}

// The Transaction Id.
func (r DeploymentQCSGetDeploymentsAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSGetDeploymentsAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

func (r DeploymentQCSGetDeploymentsAsyncRequest) Execute() (*Deployments, *http.Response, error) {
	return r.ApiService.GetDeploymentsAsyncExecute(r)
}

/*
GetDeploymentsAsync Gets deployments

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@return DeploymentQCSGetDeploymentsAsyncRequest
*/
func (a *DeploymentQCSService) GetDeploymentsAsync(ctx context.Context, customerId string) DeploymentQCSGetDeploymentsAsyncRequest {
	return DeploymentQCSGetDeploymentsAsyncRequest{
		ApiService: a,
		ctx:        ctx,
		customerId: customerId,
	}
}

// Execute executes the request
//
//	@return Deployments
func (a *DeploymentQCSService) GetDeploymentsAsyncExecute(r DeploymentQCSGetDeploymentsAsyncRequest) (*Deployments, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Deployments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.GetDeploymentsAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeVdas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeVdas", r.includeVdas, "form", "")
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSInitiateDeleteDeploymentAsyncRequest struct {
	ctx                            context.Context
	ApiService                     *DeploymentQCSService
	customerId                     string
	deploymentId                   string
	forceDelete                    *bool
	citrixTransactionId            *string
	deploymentIdInitiateDeleteBody *DeploymentIdInitiateDeleteBody
}

// Force delete deployment
func (r DeploymentQCSInitiateDeleteDeploymentAsyncRequest) ForceDelete(forceDelete bool) DeploymentQCSInitiateDeleteDeploymentAsyncRequest {
	r.forceDelete = &forceDelete
	return r
}

// The Transaction Id.
func (r DeploymentQCSInitiateDeleteDeploymentAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSInitiateDeleteDeploymentAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Deployment AD credentials
func (r DeploymentQCSInitiateDeleteDeploymentAsyncRequest) DeploymentIdInitiateDeleteBody(deploymentIdInitiateDeleteBody DeploymentIdInitiateDeleteBody) DeploymentQCSInitiateDeleteDeploymentAsyncRequest {
	r.deploymentIdInitiateDeleteBody = &deploymentIdInitiateDeleteBody
	return r
}

func (r DeploymentQCSInitiateDeleteDeploymentAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.InitiateDeleteDeploymentAsyncExecute(r)
}

/*
InitiateDeleteDeploymentAsync Initiate delete deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@return DeploymentQCSInitiateDeleteDeploymentAsyncRequest
*/
func (a *DeploymentQCSService) InitiateDeleteDeploymentAsync(ctx context.Context, customerId string, deploymentId string) DeploymentQCSInitiateDeleteDeploymentAsyncRequest {
	return DeploymentQCSInitiateDeleteDeploymentAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) InitiateDeleteDeploymentAsyncExecute(r DeploymentQCSInitiateDeleteDeploymentAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.InitiateDeleteDeploymentAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/$initiateDelete"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDelete", r.forceDelete, "form", "")
	} else {
		var defaultValue bool = false
		r.forceDelete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.deploymentIdInitiateDeleteBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSInitiateDeploymentAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	citrixTransactionId *string
	body                *InitiateAwsEdcDeployment
}

// The Transaction Id.
func (r DeploymentQCSInitiateDeploymentAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSInitiateDeploymentAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Deployment configuration
func (r DeploymentQCSInitiateDeploymentAsyncRequest) Body(body InitiateAwsEdcDeployment) DeploymentQCSInitiateDeploymentAsyncRequest {
	r.body = &body
	return r
}

func (r DeploymentQCSInitiateDeploymentAsyncRequest) Execute() (*AwsEdcDeployment, *http.Response, error) {
	return r.ApiService.InitiateDeploymentAsyncExecute(r)
}

/*
InitiateDeploymentAsync Initiates deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@return DeploymentQCSInitiateDeploymentAsyncRequest
*/
func (a *DeploymentQCSService) InitiateDeploymentAsync(ctx context.Context, customerId string) DeploymentQCSInitiateDeploymentAsyncRequest {
	return DeploymentQCSInitiateDeploymentAsyncRequest{
		ApiService: a,
		ctx:        ctx,
		customerId: customerId,
	}
}

// Execute executes the request
//
//	@return AwsEdcDeployment
func (a *DeploymentQCSService) InitiateDeploymentAsyncExecute(r DeploymentQCSInitiateDeploymentAsyncRequest) (*AwsEdcDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsEdcDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.InitiateDeploymentAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/$initiate"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSInitiateRemoveMachineAsyncRequest struct {
	ctx                         context.Context
	ApiService                  *DeploymentQCSService
	customerId                  string
	deploymentId                string
	machineId                   string
	forceDelete                 *bool
	citrixTransactionId         *string
	machineIdInitiateDeleteBody *MachineIdInitiateDeleteBody
}

// Force delete machine
func (r DeploymentQCSInitiateRemoveMachineAsyncRequest) ForceDelete(forceDelete bool) DeploymentQCSInitiateRemoveMachineAsyncRequest {
	r.forceDelete = &forceDelete
	return r
}

// The Transaction Id.
func (r DeploymentQCSInitiateRemoveMachineAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSInitiateRemoveMachineAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Active Directory credentials for the machine
func (r DeploymentQCSInitiateRemoveMachineAsyncRequest) MachineIdInitiateDeleteBody(machineIdInitiateDeleteBody MachineIdInitiateDeleteBody) DeploymentQCSInitiateRemoveMachineAsyncRequest {
	r.machineIdInitiateDeleteBody = &machineIdInitiateDeleteBody
	return r
}

func (r DeploymentQCSInitiateRemoveMachineAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.InitiateRemoveMachineAsyncExecute(r)
}

/*
InitiateRemoveMachineAsync Initiate removal of machine from deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@param machineId ID of the machine
	@return DeploymentQCSInitiateRemoveMachineAsyncRequest
*/
func (a *DeploymentQCSService) InitiateRemoveMachineAsync(ctx context.Context, customerId string, deploymentId string, machineId string) DeploymentQCSInitiateRemoveMachineAsyncRequest {
	return DeploymentQCSInitiateRemoveMachineAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
		machineId:    machineId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) InitiateRemoveMachineAsyncExecute(r DeploymentQCSInitiateRemoveMachineAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.InitiateRemoveMachineAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/machines/{machineId}/$initiateDelete"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDelete", r.forceDelete, "form", "")
	} else {
		var defaultValue bool = false
		r.forceDelete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.machineIdInitiateDeleteBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSPatchMachinesAsyncRequest struct {
	ctx                      context.Context
	ApiService               *DeploymentQCSService
	customerId               string
	deploymentId             string
	citrixTransactionId      *string
	deploymentIdMachinesBody *DeploymentIdMachinesBody
}

// The Transaction Id.
func (r DeploymentQCSPatchMachinesAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSPatchMachinesAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Machines to be modified to turn on or off maintenance mode
func (r DeploymentQCSPatchMachinesAsyncRequest) DeploymentIdMachinesBody(deploymentIdMachinesBody DeploymentIdMachinesBody) DeploymentQCSPatchMachinesAsyncRequest {
	r.deploymentIdMachinesBody = &deploymentIdMachinesBody
	return r
}

func (r DeploymentQCSPatchMachinesAsyncRequest) Execute() (*http.Response, error) {
	return r.ApiService.PatchMachinesAsyncExecute(r)
}

/*
PatchMachinesAsync Turn on or off the deployment mode for deployment machines

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@return DeploymentQCSPatchMachinesAsyncRequest
*/
func (a *DeploymentQCSService) PatchMachinesAsync(ctx context.Context, customerId string, deploymentId string) DeploymentQCSPatchMachinesAsyncRequest {
	return DeploymentQCSPatchMachinesAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
func (a *DeploymentQCSService) PatchMachinesAsyncExecute(r DeploymentQCSPatchMachinesAsyncRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.PatchMachinesAsync")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/machines"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.deploymentIdMachinesBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DeploymentQCSRemoveMachineAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	machineId           string
	forceDelete         *bool
	citrixTransactionId *string
}

// Force delete machine
func (r DeploymentQCSRemoveMachineAsyncRequest) ForceDelete(forceDelete bool) DeploymentQCSRemoveMachineAsyncRequest {
	r.forceDelete = &forceDelete
	return r
}

// The Transaction Id.
func (r DeploymentQCSRemoveMachineAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSRemoveMachineAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

func (r DeploymentQCSRemoveMachineAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.RemoveMachineAsyncExecute(r)
}

/*
RemoveMachineAsync Removes machine to deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@param machineId ID of the machine
	@return DeploymentQCSRemoveMachineAsyncRequest
*/
func (a *DeploymentQCSService) RemoveMachineAsync(ctx context.Context, customerId string, deploymentId string, machineId string) DeploymentQCSRemoveMachineAsyncRequest {
	return DeploymentQCSRemoveMachineAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
		machineId:    machineId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) RemoveMachineAsyncExecute(r DeploymentQCSRemoveMachineAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.RemoveMachineAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/machines/{machineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDelete", r.forceDelete, "form", "")
	} else {
		var defaultValue bool = false
		r.forceDelete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSRemoveMachinesAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	forceDelete         *bool
	citrixTransactionId *string
	machinesDeleteBody  *MachinesDeleteBody
}

// Force delete machines
func (r DeploymentQCSRemoveMachinesAsyncRequest) ForceDelete(forceDelete bool) DeploymentQCSRemoveMachinesAsyncRequest {
	r.forceDelete = &forceDelete
	return r
}

// The Transaction Id.
func (r DeploymentQCSRemoveMachinesAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSRemoveMachinesAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Configuration object specifying which machines to delete
func (r DeploymentQCSRemoveMachinesAsyncRequest) MachinesDeleteBody(machinesDeleteBody MachinesDeleteBody) DeploymentQCSRemoveMachinesAsyncRequest {
	r.machinesDeleteBody = &machinesDeleteBody
	return r
}

func (r DeploymentQCSRemoveMachinesAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.RemoveMachinesAsyncExecute(r)
}

/*
RemoveMachinesAsync Removes machines from deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@return DeploymentQCSRemoveMachinesAsyncRequest
*/
func (a *DeploymentQCSService) RemoveMachinesAsync(ctx context.Context, customerId string, deploymentId string) DeploymentQCSRemoveMachinesAsyncRequest {
	return DeploymentQCSRemoveMachinesAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) RemoveMachinesAsyncExecute(r DeploymentQCSRemoveMachinesAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.RemoveMachinesAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/machines/$delete"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDelete", r.forceDelete, "form", "")
	} else {
		var defaultValue bool = false
		r.forceDelete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.machinesDeleteBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSRestartMachineAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	machineId           string
	citrixTransactionId *string
}

// The Transaction Id.
func (r DeploymentQCSRestartMachineAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSRestartMachineAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

func (r DeploymentQCSRestartMachineAsyncRequest) Execute() (*http.Response, error) {
	return r.ApiService.RestartMachineAsyncExecute(r)
}

/*
RestartMachineAsync Restart a machine

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@param machineId ID of the machine
	@return DeploymentQCSRestartMachineAsyncRequest
*/
func (a *DeploymentQCSService) RestartMachineAsync(ctx context.Context, customerId string, deploymentId string, machineId string) DeploymentQCSRestartMachineAsyncRequest {
	return DeploymentQCSRestartMachineAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
		machineId:    machineId,
	}
}

// Execute executes the request
func (a *DeploymentQCSService) RestartMachineAsyncExecute(r DeploymentQCSRestartMachineAsyncRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.RestartMachineAsync")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/machines/{machineId}/$restart"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DeploymentQCSSaveAsImageAsyncRequest struct {
	ctx                      context.Context
	ApiService               *DeploymentQCSService
	customerId               string
	deploymentId             string
	machineId                string
	citrixTransactionId      *string
	machineIdSaveAsImageBody *MachineIdSaveAsImageBody
}

// The Transaction Id.
func (r DeploymentQCSSaveAsImageAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSSaveAsImageAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// configurations of the new image
func (r DeploymentQCSSaveAsImageAsyncRequest) MachineIdSaveAsImageBody(machineIdSaveAsImageBody MachineIdSaveAsImageBody) DeploymentQCSSaveAsImageAsyncRequest {
	r.machineIdSaveAsImageBody = &machineIdSaveAsImageBody
	return r
}

func (r DeploymentQCSSaveAsImageAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.SaveAsImageAsyncExecute(r)
}

/*
SaveAsImageAsync Save image to account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@param machineId ID of the image builder machine
	@return DeploymentQCSSaveAsImageAsyncRequest
*/
func (a *DeploymentQCSService) SaveAsImageAsync(ctx context.Context, customerId string, deploymentId string, machineId string) DeploymentQCSSaveAsImageAsyncRequest {
	return DeploymentQCSSaveAsImageAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
		machineId:    machineId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) SaveAsImageAsyncExecute(r DeploymentQCSSaveAsImageAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.SaveAsImageAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/machines/{machineId}/$saveAsImage"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.machineIdSaveAsImageBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSUpdateDeploymentImageAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	citrixTransactionId *string
	imageUpdateBody     *ImageUpdateBody
}

// The Transaction Id.
func (r DeploymentQCSUpdateDeploymentImageAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSUpdateDeploymentImageAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Details of the new image
func (r DeploymentQCSUpdateDeploymentImageAsyncRequest) ImageUpdateBody(imageUpdateBody ImageUpdateBody) DeploymentQCSUpdateDeploymentImageAsyncRequest {
	r.imageUpdateBody = &imageUpdateBody
	return r
}

func (r DeploymentQCSUpdateDeploymentImageAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.UpdateDeploymentImageAsyncExecute(r)
}

/*
UpdateDeploymentImageAsync Update image for a deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@return DeploymentQCSUpdateDeploymentImageAsyncRequest
*/
func (a *DeploymentQCSService) UpdateDeploymentImageAsync(ctx context.Context, customerId string, deploymentId string) DeploymentQCSUpdateDeploymentImageAsyncRequest {
	return DeploymentQCSUpdateDeploymentImageAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) UpdateDeploymentImageAsyncExecute(r DeploymentQCSUpdateDeploymentImageAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.UpdateDeploymentImageAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/image/$update"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.imageUpdateBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSUpdateDeploymentPropertiesAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	citrixTransactionId *string
	body                *UpdateAwsEdcDeploymentProperties
}

// The Transaction Id.
func (r DeploymentQCSUpdateDeploymentPropertiesAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSUpdateDeploymentPropertiesAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Deployment properties configuration
func (r DeploymentQCSUpdateDeploymentPropertiesAsyncRequest) Body(body UpdateAwsEdcDeploymentProperties) DeploymentQCSUpdateDeploymentPropertiesAsyncRequest {
	r.body = &body
	return r
}

func (r DeploymentQCSUpdateDeploymentPropertiesAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.UpdateDeploymentPropertiesAsyncExecute(r)
}

/*
UpdateDeploymentPropertiesAsync Updates deployment properties

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@return DeploymentQCSUpdateDeploymentPropertiesAsyncRequest
*/
func (a *DeploymentQCSService) UpdateDeploymentPropertiesAsync(ctx context.Context, customerId string, deploymentId string) DeploymentQCSUpdateDeploymentPropertiesAsyncRequest {
	return DeploymentQCSUpdateDeploymentPropertiesAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) UpdateDeploymentPropertiesAsyncExecute(r DeploymentQCSUpdateDeploymentPropertiesAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.UpdateDeploymentPropertiesAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/$update"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DeploymentQCSUpdateMachineAsyncRequest struct {
	ctx                 context.Context
	ApiService          *DeploymentQCSService
	customerId          string
	deploymentId        string
	machineId           string
	citrixTransactionId *string
	body                *UpdateAwsEdcDeploymentMachine
}

// The Transaction Id.
func (r DeploymentQCSUpdateMachineAsyncRequest) CitrixTransactionId(citrixTransactionId string) DeploymentQCSUpdateMachineAsyncRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Configuration of machine
func (r DeploymentQCSUpdateMachineAsyncRequest) Body(body UpdateAwsEdcDeploymentMachine) DeploymentQCSUpdateMachineAsyncRequest {
	r.body = &body
	return r
}

func (r DeploymentQCSUpdateMachineAsyncRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.UpdateMachineAsyncExecute(r)
}

/*
UpdateMachineAsync Updates machine in deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId ID of the customer
	@param deploymentId ID of the deployment
	@param machineId ID of the machine
	@return DeploymentQCSUpdateMachineAsyncRequest
*/
func (a *DeploymentQCSService) UpdateMachineAsync(ctx context.Context, customerId string, deploymentId string, machineId string) DeploymentQCSUpdateMachineAsyncRequest {
	return DeploymentQCSUpdateMachineAsyncRequest{
		ApiService:   a,
		ctx:          ctx,
		customerId:   customerId,
		deploymentId: deploymentId,
		machineId:    machineId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *DeploymentQCSService) UpdateMachineAsyncExecute(r DeploymentQCSUpdateMachineAsyncRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentQCSService.UpdateMachineAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{customerId}/deployments/{deploymentId}/machines/{machineId}/$update"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CWSAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
