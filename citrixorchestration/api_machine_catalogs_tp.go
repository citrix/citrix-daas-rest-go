/*
Citrix Virtual Apps and Desktops REST API TECHPREVIEW

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: techpreview
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MachineCatalogsTPApiService MachineCatalogsTPApi service
type MachineCatalogsTPApiService service

type ApiMachineCatalogsTPAddMachineCatalogMachineRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	machine *AddMachineToMachineCatalogDetailRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xAccessToken *string
	xActionName *string
}

// Details of the machine to add to the machine catalog.
func (r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) Machine(machine AddMachineToMachineCatalogDetailRequestModel) ApiMachineCatalogsTPAddMachineCatalogMachineRequest {
	r.machine = &machine
	return r
}

// If &#x60;true&#x60;, the machine will be added into the machine catalog as a background task. The task will have JobType AddMachineCatalogMachine. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties: * _NameOrId_ - Name or ID of the machine being added.
func (r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) Async(async bool) ApiMachineCatalogsTPAddMachineCatalogMachineRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) Authorization(authorization string) ApiMachineCatalogsTPAddMachineCatalogMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPAddMachineCatalogMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsTPAddMachineCatalogMachineRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsTPAddMachineCatalogMachineRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) XActionName(xActionName string) ApiMachineCatalogsTPAddMachineCatalogMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPAddMachineCatalogMachineExecute(r)
}

/*
MachineCatalogsTPAddMachineCatalogMachine Add machine to the machine catalog.

Add a machine to the machine catalog.  This is the first step in making the
machine available to run users' desktops and applications. The machine may
be physical or virtual.  The type of machine (physical or virtual) must
match the machine catalog configuration.


Note that due to
the long-running nature of the adding operation, it cannot
complete synchronously, would always initiate an asynchronous job to
run to completion.


The machine must support the expected capabilities of the machine catalog:
the  and
. The session
support of the machine is determined by the type of Citrix VDA software
installed (server or workstation) and the functional level depends on the
version of the Citrix VDA software installed.  The API will complete
successfully if these are not correct but the machine will be unable to register.


Note: to add multiple machines in a single call, use the
 API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to add machine to.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPAddMachineCatalogMachineRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPAddMachineCatalogMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPAddMachineCatalogMachineRequest {
	return ApiMachineCatalogsTPAddMachineCatalogMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return JobResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPAddMachineCatalogMachineExecute(r ApiMachineCatalogsTPAddMachineCatalogMachineRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPAddMachineCatalogMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/Machines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.machine == nil {
		return localVarReturnValue, nil, reportError("machine is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.machine
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	machine *MachineAccountRequestModel
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
}

// Machine account to add to the machine catalog.  The machine must not be a member of any other machine catalog.
func (r ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest) Machine(machine MachineAccountRequestModel) ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest {
	r.machine = &machine
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest) XActionName(xActionName string) ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPAddMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsTPAddMachineCatalogMachineAccount Add a machine account to the machine catalog.

Add a machine account to the machine catalog. This is only relevant for machine catalogs where ProvisioningType is MCS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to add the machine account to.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPAddMachineCatalogMachineAccount(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return ProvisioningSchemeMachineAccountResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPAddMachineCatalogMachineAccountExecute(r ApiMachineCatalogsTPAddMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvisioningSchemeMachineAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPAddMachineCatalogMachineAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/MachineAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.machine == nil {
		return localVarReturnValue, nil, reportError("machine is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.machine
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPAddMachineCatalogTagsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	tagNameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsTPAddMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsTPAddMachineCatalogTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPAddMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsTPAddMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPAddMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPAddMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPAddMachineCatalogTagsRequest) XActionName(xActionName string) ApiMachineCatalogsTPAddMachineCatalogTagsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPAddMachineCatalogTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPAddMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsTPAddMachineCatalogTags Add a tag to a machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param tagNameOrId Name or ID of the tag to add.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPAddMachineCatalogTagsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPAddMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string, customerid string, siteid string) ApiMachineCatalogsTPAddMachineCatalogTagsRequest {
	return ApiMachineCatalogsTPAddMachineCatalogTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		tagNameOrId: tagNameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return TagResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPAddMachineCatalogTagsExecute(r ApiMachineCatalogsTPAddMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPAddMachineCatalogTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/Tags/{tagNameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagNameOrId"+"}", url.PathEscape(parameterValueToString(r.tagNameOrId, "tagNameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPCheckMachineCatalogExistsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	name string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPCheckMachineCatalogExistsRequest) Authorization(authorization string) ApiMachineCatalogsTPCheckMachineCatalogExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPCheckMachineCatalogExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPCheckMachineCatalogExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPCheckMachineCatalogExistsRequest) XActionName(xActionName string) ApiMachineCatalogsTPCheckMachineCatalogExistsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPCheckMachineCatalogExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPCheckMachineCatalogExistsExecute(r)
}

/*
MachineCatalogsTPCheckMachineCatalogExists Check for the existence of a machine catalog by name.

Check for the existence of a machine catalog by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPCheckMachineCatalogExistsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPCheckMachineCatalogExists(ctx context.Context, name string, customerid string, siteid string) ApiMachineCatalogsTPCheckMachineCatalogExistsRequest {
	return ApiMachineCatalogsTPCheckMachineCatalogExistsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPCheckMachineCatalogExistsExecute(r ApiMachineCatalogsTPCheckMachineCatalogExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPCheckMachineCatalogExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	name string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest) Authorization(authorization string) ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest) XActionName(xActionName string) ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPCheckRemotePCEnrollmentScopeExistsExecute(r)
}

/*
MachineCatalogsTPCheckRemotePCEnrollmentScopeExists Check for the existence of a RemotePC enrollment scope by name.

Check for the existence of a RemotePC enrollment scope by name. Note that
RemotePC enrollment scope names must be unique within the site, so the
`nameOrId` parameter does not affect whether the RemotePC enrollment scope
name is found.
If the name is found to be available, this returns 404 Not Found.
If a RemotePC enrollment scope by that name exists and is associated with the
specified machine catalog, this returns 204 No Content. If a RemotePC
enrollment scope by that name exists and is associated with a different
machine catalog, this returns 303 See Other, and the `Location`
response header refers to location of the machine catalog which is associated
by the RemotePC enrollment scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param name Distinguished name of an OU containing machines allowed to enroll as remote PCs.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPCheckRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string, name string, customerid string, siteid string) ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest {
	return ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		name: name,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPCheckRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsTPCheckRemotePCEnrollmentScopeExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPCheckRemotePCEnrollmentScopeExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/RemotePCEnrollmentScopes/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPCreateMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	customerid string
	siteid string
	request *CreateMachineCatalogRequestModel
	async *bool
	sourceNameOrId *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xAccessToken *string
	xActionName *string
}

// Details about the machine catalog to create.
func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) Request(request CreateMachineCatalogRequestModel) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be created as a background task. The task will have JobType CreateMachineCatalog. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties: * _Name_ - Name of the machine catalog being created.
func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) Async(async bool) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	r.async = &async
	return r
}

// The machine catalog name or Id to recreate from. It is only used for catalog recreation scenario. Here specify name or Id of the failed catalog to recreate.
func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) SourceNameOrId(sourceNameOrId string) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	r.sourceNameOrId = &sourceNameOrId
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPCreateMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPCreateMachineCatalogExecute(r)
}

/*
MachineCatalogsTPCreateMachineCatalog Create a machine catalog.

Create a machine catalog.

Note that if a machine catalog uses 
of , the machine catalog creation will always invoke asynchronous
job(s) for the provisioning action.  If this API is invoked asynchronously, the asynchronous job
will include only the machine catalog creation, and the provisioning task(s) will be associated
with the newly created catalog.  If this API is invoked synchronously, the machine catalog
creation will complete synchronously but the provisioning task(s) may still be executing, and
will be associated with the newly created catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPCreateMachineCatalogRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPCreateMachineCatalog(ctx context.Context, customerid string, siteid string) ApiMachineCatalogsTPCreateMachineCatalogRequest {
	return ApiMachineCatalogsTPCreateMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineCatalogDetailResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPCreateMachineCatalogExecute(r ApiMachineCatalogsTPCreateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPCreateMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs"
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.sourceNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNameOrId", r.sourceNameOrId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *CreateUpgradeScheduleRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details about the VDA upgrade schedule to create.
func (r ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest) Request(request CreateUpgradeScheduleRequestModel) ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be created as a background task.
func (r ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest) XActionName(xActionName string) ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPCreateMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsTPCreateMachineCatalogUpgradeSchedule Setup a new VDA upgrade schedule for a machine catalog.

A new VDA upgrade schedule can only be created for a machine catalog
when the upgrade status for the catalog is UpgradeSuccessful, UpgradeFailed or UpgradeCancelled.
If the status is ongoing or waiting to start, the operation fails.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPCreateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPCreateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsTPCreateMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPCreateMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPDeleteMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	deleteVm *bool
	deleteAccount *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xAccessToken *string
	xActionName *string
}

// Specifies whether to delete virtual machines that were provisioned in the machine catalog. Only relevant when ProvisioningType is MCS; otherwise, ignored.  Optional; default is &#x60;true&#x60;.
func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) DeleteVm(deleteVm bool) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	r.deleteVm = &deleteVm
	return r
}

// Specifies what to do with AD machine accounts that are associated with the machine catalog.  Optional; default is .
func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) DeleteAccount(deleteAccount string) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	r.deleteAccount = &deleteAccount
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be deleted as a background task. The task will have JobType DeleteMachineCatalog. When the task is complete it will redirect to GetMachineCatalogs. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being deleted, * _Name_ - Name of the machine catalog being deleted.
func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) Async(async bool) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPDeleteMachineCatalogRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPDeleteMachineCatalogExecute(r)
}

/*
MachineCatalogsTPDeleteMachineCatalog Delete a machine catalog.

Delete a machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to update.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPDeleteMachineCatalogRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPDeleteMachineCatalog(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPDeleteMachineCatalogRequest {
	return ApiMachineCatalogsTPDeleteMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPDeleteMachineCatalogExecute(r ApiMachineCatalogsTPDeleteMachineCatalogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPDeleteMachineCatalog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteVm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteVm", r.deleteVm, "")
	}
	if r.deleteAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAccount", r.deleteAccount, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPDoMachineCatalogSearchRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	customerid string
	siteid string
	searchRequest *CatalogSearchRequestModel
	async *bool
	limit *int32
	continuationToken *string
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Specifies the advanced search parameters.
func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) SearchRequest(searchRequest CatalogSearchRequestModel) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	r.searchRequest = &searchRequest
	return r
}

// If &#x60;true&#x60;, the catalogs (and associated objects) will be added as a background task. The task will have JobType SearchMachineCatalogs.
func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) Async(async bool) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	r.async = &async
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) Limit(limit int32) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) Fields(fields string) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) Authorization(authorization string) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) XActionName(xActionName string) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) Execute() (*CatalogSearchResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPDoMachineCatalogSearchExecute(r)
}

/*
MachineCatalogsTPDoMachineCatalogSearch Perform an advanced search for machinecatalogs.

Perform an advanced search for machinecatalogs.  Note that some combinations
of search parameters may result in slow performance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPDoMachineCatalogSearchRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPDoMachineCatalogSearch(ctx context.Context, customerid string, siteid string) ApiMachineCatalogsTPDoMachineCatalogSearchRequest {
	return ApiMachineCatalogsTPDoMachineCatalogSearchRequest{
		ApiService: a,
		ctx: ctx,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return CatalogSearchResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPDoMachineCatalogSearchExecute(r ApiMachineCatalogsTPDoMachineCatalogSearchRequest) (*CatalogSearchResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogSearchResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPDoMachineCatalogSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machinecatalogs/$search"
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchRequest == nil {
		return localVarReturnValue, nil, reportError("searchRequest is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.searchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	async *bool
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsTPGetMachineCatalogRequest) Async(async bool) ApiMachineCatalogsTPGetMachineCatalogRequest {
	r.async = &async
	return r
}

// Optional parameters, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsTPGetMachineCatalogRequest) Fields(fields string) ApiMachineCatalogsTPGetMachineCatalogRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalog Get details about a single machine catalog.

Get details about a single machine catalog by name or ID of machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalog(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogRequest {
	return ApiMachineCatalogsTPGetMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineCatalogDetailResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogExecute(r ApiMachineCatalogsTPGetMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	limit *int32
	continuationToken *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// The max number of delivery group associations returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest) Limit(limit int32) ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest) Async(async bool) ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest) Execute() (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogDeliveryGroupAssociations Get delivery group associations of a machine catalog.

Get delivery group associations by name or Id of a remote pc machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogDeliveryGroupAssociations(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest {
	return ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return DeliveryGroupAssociationResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsExecute(r ApiMachineCatalogsTPGetMachineCatalogDeliveryGroupAssociationsRequest) (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeliveryGroupAssociationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogDeliveryGroupAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/DeliveryGroupAssociations"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest) Async(async bool) ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest) Execute() (*VMImageResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogLastMasterImageExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogLastMasterImage Get the last master VM images used by the machine catalog.

Get the last master VM images used by the machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogLastMasterImage(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest {
	return ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return VMImageResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogLastMasterImageExecute(r ApiMachineCatalogsTPGetMachineCatalogLastMasterImageRequest) (*VMImageResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMImageResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogLastMasterImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/LastMasterImage"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	limit *int32
	continuationToken *string
	async *bool
	accountState *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// The max number of machine accounts returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) Limit(limit int32) ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, the machine accounts will be queried as a background task. The task will have JobType GetMachineCatalogMachineAccounts. When the task is complete it will redirect to GetJobResults.
func (r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) Async(async bool) ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest {
	r.async = &async
	return r
}

// The state of accounts for query.
func (r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) AccountState(accountState string) ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest {
	r.accountState = &accountState
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogMachineAccountsExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogMachineAccounts Get all machine accounts associated with a machine catalog.

Get all machine accounts associated with a machine catalog.  This returns
all machine accounts for the machine catalog regardless of whether they are
in-use, available, locked, etc.


This is only relevant for machine catalogs where ProvisioningType is MCS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to get machine accounts for.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogMachineAccounts(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest {
	return ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return ProvisioningSchemeMachineAccountResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogMachineAccountsExecute(r ApiMachineCatalogsTPGetMachineCatalogMachineAccountsRequest) (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvisioningSchemeMachineAccountResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogMachineAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/MachineAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.accountState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountState", r.accountState, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogMachinesRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	limit *int32
	continuationToken *string
	async *bool
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// The max number of machines returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) Limit(limit int32) ApiMachineCatalogsTPGetMachineCatalogMachinesRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsTPGetMachineCatalogMachinesRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) Async(async bool) ApiMachineCatalogsTPGetMachineCatalogMachinesRequest {
	r.async = &async
	return r
}

// Optional parameters, only the specified properties in the fields are required.
func (r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) Fields(fields string) ApiMachineCatalogsTPGetMachineCatalogMachinesRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogMachinesRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) Execute() (*MachineResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogMachinesExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogMachines GET the machines of a catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogMachinesRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogMachines(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogMachinesRequest {
	return ApiMachineCatalogsTPGetMachineCatalogMachinesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogMachinesExecute(r ApiMachineCatalogsTPGetMachineCatalogMachinesRequest) (*MachineResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogMachines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/Machines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest) Execute() (*VMImageResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogMasterImageHistoryExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogMasterImageHistory Get the history of master VM images used by the machine catalog.

Get the history of master VM images used by the machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogMasterImageHistory(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest {
	return ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return VMImageResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogMasterImageHistoryExecute(r ApiMachineCatalogsTPGetMachineCatalogMasterImageHistoryRequest) (*VMImageResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMImageResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogMasterImageHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/MasterImageHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	machines *[]string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// The machines to get start menu applications
func (r ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest) Machines(machines []string) ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest {
	r.machines = &machines
	return r
}

// If &#x60;true&#x60;, the start menu applications will be queried as a background task. This is recommended as this operation may cause a power action, turning on a machine in order to gather the data. This may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType GetStartMenuApplications. When the task is complete it will redirect to \&quot;JobsControllerTP.GetJobResults(string)\&quot;. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog from which start menu applications are being obtained, * _Name_ - Name of the machine catalog from which start menu applications are being obtained. * _MachineId_ - ID of the machine selected, from which the start menu applications are being obtained; will be present in Parameters only after a machine is selected. * _MachineName_ - Name of the machine selected, from which the start menu applications are being obtained; will be present in Parameters only after a machine is selected.
func (r ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest) Async(async bool) ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest) Execute() (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogStartMenuApplicationsExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogStartMenuApplications Get the start menu applications from a machine in the machine catalog.

Get the start menu applications from a machine in the machine catalog

Note that this API may require a machine within a catalog to be
booted, if no machines are currently available.  Therefore the API
may take quite some time to complete.  Consider using the `async=true`
parameter to mitigate this.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogStartMenuApplications(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest {
	return ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return StartMenuApplicationResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogStartMenuApplicationsExecute(r ApiMachineCatalogsTPGetMachineCatalogStartMenuApplicationsRequest) (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StartMenuApplicationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogStartMenuApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/StartMenuApplications"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.machines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "machines", r.machines, "csv")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogTagsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Optional parameters, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsTPGetMachineCatalogTagsRequest) Fields(fields string) ApiMachineCatalogsTPGetMachineCatalogTagsRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogTagsRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogTagsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogTags Get tags associated with a machine catalog.

Get tags associated with a machine catalog.  This includes tags which are
directly associated with the machine catalog, as well as tags associated with
machines that are associated with the machine catalog.
To find only tags directly associated with the machine catalog,
filter the results to those with
NumMachineCatalogs equal to `1`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogTagsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogTags(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogTagsRequest {
	return ApiMachineCatalogsTPGetMachineCatalogTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return TagResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogTagsExecute(r ApiMachineCatalogsTPGetMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/Tags"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogTestReportRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogTestReportRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogTestReportRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogTestReportRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogTestReportRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogTestReportRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogTestReportRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogTestReportRequest) Execute() (*TestReportResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogTestReportExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogTestReport Get the most recent test report of a machine catalog.

Get the test report from the last run of
TestMachineCatalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogTestReportRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogTestReport(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogTestReportRequest {
	return ApiMachineCatalogsTPGetMachineCatalogTestReportRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return TestReportResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogTestReportExecute(r ApiMachineCatalogsTPGetMachineCatalogTestReportRequest) (*TestReportResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TestReportResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogTestReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/TestReport"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest) Execute() (*MachineCatalogVusComponentResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogVDAComponentsAndFeatures Get the components and features of VDAs associated with a machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogVDAComponentsAndFeatures(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest {
	return ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineCatalogVusComponentResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesExecute(r ApiMachineCatalogsTPGetMachineCatalogVDAComponentsAndFeaturesRequest) (*MachineCatalogVusComponentResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogVusComponentResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogVDAComponentsAndFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/VDAComponentsAndFeatures"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	customerid string
	siteid string
	adminFolder *string
	async *bool
	limit *int32
	continuationToken *string
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Admin folder path or Id.
func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) AdminFolder(adminFolder string) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	r.adminFolder = &adminFolder
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) Async(async bool) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	r.async = &async
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) Limit(limit int32) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server
func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) Fields(fields string) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogsRequest) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogsExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogs Get all machine catalogs.

Get all machine catalogs in the site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogs(ctx context.Context, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogsRequest {
	return ApiMachineCatalogsTPGetMachineCatalogsRequest{
		ApiService: a,
		ctx: ctx,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineCatalogResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogsExecute(r ApiMachineCatalogsTPGetMachineCatalogsRequest) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs"
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adminFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adminFolder", r.adminFolder, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest) Authorization(authorization string) ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest) XActionName(xActionName string) ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest) Execute() (*AdministratorResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPGetMachineCatalogsAdministratorsExecute(r)
}

/*
MachineCatalogsTPGetMachineCatalogsAdministrators Get administrators who can administer a machine catalog.

Get administrators who can administer a machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogsAdministrators(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest {
	return ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return AdministratorResponseModelCollection
func (a *MachineCatalogsTPApiService) MachineCatalogsTPGetMachineCatalogsAdministratorsExecute(r ApiMachineCatalogsTPGetMachineCatalogsAdministratorsRequest) (*AdministratorResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdministratorResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPGetMachineCatalogsAdministrators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/Administrators"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *RebootMachinesRequestModel
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Reboot options.
func (r ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest) Request(request RebootMachinesRequestModel) ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest {
	r.request = &request
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest) Authorization(authorization string) ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest) XActionName(xActionName string) ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPRebootMachineCatalogMachinesExecute(r)
}

/*
MachineCatalogsTPRebootMachineCatalogMachines Reboot all machines in a machine catalog.

Reboot all machines in a machine catalog.


Note that there is no job representation for the reboot operation.
The call returns immediately even though the machines reboot over time.
If you want to follow the progress of the reboot operation, check
the 
property of the machines in the machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRebootMachineCatalogMachines(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest {
	return ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRebootMachineCatalogMachinesExecute(r ApiMachineCatalogsTPRebootMachineCatalogMachinesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPRebootMachineCatalogMachines")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/$RebootMachines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	machine string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest) Authorization(authorization string) ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest) XActionName(xActionName string) ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPRemoveMachineCatalogMachineExecute(r)
}

/*
MachineCatalogsTPRemoveMachineCatalogMachine Remove a machine from the machine catalog.

Remove a machine from the machine catalog.  Removing the machine from the machine
catalog removes it from the site.


A machine cannot be removed from the machine catalog if it is a member of a delivery group.


Note: to remove multiple machines in a single call, use the
 API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to remove the machine from.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param machine Machine to remove from the catalog.  May be specified by name, ID, or SID.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRemoveMachineCatalogMachine(ctx context.Context, nameOrId string, machine string, customerid string, siteid string) ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest {
	return ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		machine: machine,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRemoveMachineCatalogMachineExecute(r ApiMachineCatalogsTPRemoveMachineCatalogMachineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPRemoveMachineCatalogMachine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/Machines/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	machine string
	customerid string
	siteid string
	deleteAccount *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
}

// Specifies what to do with the machine account in AD.  Optional; default is None.
func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest) DeleteAccount(deleteAccount string) ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest {
	r.deleteAccount = &deleteAccount
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest) XActionName(xActionName string) ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPRemoveMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsTPRemoveMachineCatalogMachineAccount Remove a machine account from the machine catalog.

Remove a machine account from the machine catalog. This is only relevant for machine catalogs where ProvisioningType is MCS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to remove the machine account from.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param machine Machine account to remove.  May be specified by SamName, UPN, or SID.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRemoveMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string, customerid string, siteid string) ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		machine: machine,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRemoveMachineCatalogMachineAccountExecute(r ApiMachineCatalogsTPRemoveMachineCatalogMachineAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPRemoveMachineCatalogMachineAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/MachineAccounts/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAccount", r.deleteAccount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	tagNameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest) XActionName(xActionName string) ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPRemoveMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsTPRemoveMachineCatalogTags Remove a tag from a machine catalog.

Remove a tag from a machine catalog.  Does not delete the tag,
only its association to the machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param tagNameOrId Name or ID of the tag.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRemoveMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string, customerid string, siteid string) ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest {
	return ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		tagNameOrId: tagNameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRemoveMachineCatalogTagsExecute(r ApiMachineCatalogsTPRemoveMachineCatalogTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPRemoveMachineCatalogTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/Tags/{tagNameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagNameOrId"+"}", url.PathEscape(parameterValueToString(r.tagNameOrId, "tagNameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	force *bool
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, VDA upgrade schedules existing with all machines within the catalog will be removed except those upgrade status in progressing. If &#x60;false&#x60;, only the perform removing when catalog level schedule not started.
func (r ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest) Force(force bool) ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest {
	r.force = &force
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be removed as a background task.
func (r ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest) XActionName(xActionName string) ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPRemoveMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsTPRemoveMachineCatalogUpgradeSchedule Remove a pending VDA upgrade schedule for a machine catalog.

A VDA upgrade schedule can only be cancelled for a machine catalog
when the upgrade status is waiting to start. If the current upgrade is
in another status, the operation fails with HTTP response status 404.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRemoveMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRemoveMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsTPRemoveMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPRemoveMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *RebootMachinesRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
}

// Details about the image update to be performed.
func (r ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest) Request(request RebootMachinesRequestModel) ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest {
	r.request = &request
	return r
}

// Due to the long-running nature of the update operation, it cannot complete synchronously, and always initiates an asynchronous job to run to completion.  If the &#x60;async&#x60; parameter is &#x60;true&#x60;, the only difference is that instead of returning the initial job status in the payload, the response is instead &#x60;202&#x60; with the &#x60;Location&#x60; header pointing to the job status API.  This may be desirable for clients that wish to unify their logic for handling asynchronous jobs.  The task will have JobType . When the task is complete it will redirect to . The job&#39;s  will contain properties:   * _Id_ - ID of the machine catalog for which the provisioning scheme is being updated, * _Name_ - Name of the machine catalog for which the provisioning scheme is being updated.
func (r ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest) Async(async bool) ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest) Authorization(authorization string) ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest) XActionName(xActionName string) ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPRollbackMachineCatalogProvisioningSchemeExecute(r)
}

/*
MachineCatalogsTPRollbackMachineCatalogProvisioningScheme Rollback the machine catalog's provisioning scheme.

Rollback the machine catalog's provisioning scheme.


Only valid when the machine catalog's ProvisioningType is MCS.


Provides the ability to roll back the hard disk image used to provision
virtual machines. If the provisioning scheme has CleanOnBoot equal to
`true`, then the next time that virtual machines are started, their
hard disks are updated to this new image. Regardless of CleanOnBoot,
all new virtual machines created after this call succeeds will use this
new hard disk image.


*Note:* The provisioning scheme for a machine catalog cannot be
changed while any provisioning tasks are already executing for the
machine catalog.  Cancel existing provisioning tasks or wait for
their completion before updating the provisioning scheme.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRollbackMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest {
	return ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return JobResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPRollbackMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsTPRollbackMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPRollbackMachineCatalogProvisioningScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/$RollbackProvisioningScheme"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPSetMachineCatalogTagsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *TagsRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details of the tags to set on the machine catalog.
func (r ApiMachineCatalogsTPSetMachineCatalogTagsRequest) Request(request TagsRequestModel) ApiMachineCatalogsTPSetMachineCatalogTagsRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsTPSetMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsTPSetMachineCatalogTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPSetMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsTPSetMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPSetMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPSetMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPSetMachineCatalogTagsRequest) XActionName(xActionName string) ApiMachineCatalogsTPSetMachineCatalogTagsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPSetMachineCatalogTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPSetMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsTPSetMachineCatalogTags Set tags associated with a machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPSetMachineCatalogTagsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPSetMachineCatalogTags(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPSetMachineCatalogTagsRequest {
	return ApiMachineCatalogsTPSetMachineCatalogTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPSetMachineCatalogTagsExecute(r ApiMachineCatalogsTPSetMachineCatalogTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPSetMachineCatalogTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/Tags"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPTestMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the tests will run as a background task. This is recommended as the tests may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType TestMachineCatalog. When the task is complete it will redirect to GetJobResults. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being tested, * _Name_ - Name of the machine catalog being tested.
func (r ApiMachineCatalogsTPTestMachineCatalogRequest) Async(async bool) ApiMachineCatalogsTPTestMachineCatalogRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPTestMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsTPTestMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPTestMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPTestMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPTestMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsTPTestMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPTestMachineCatalogRequest) Execute() (*MachineCatalogTestResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPTestMachineCatalogExecute(r)
}

/*
MachineCatalogsTPTestMachineCatalog Run tests on a machine catalog and create a test report.

Run tests on a machine catalog and create a test report.  Obtain the
most recent report from
GetMachineCatalogTestReport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to test.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPTestMachineCatalogRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPTestMachineCatalog(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPTestMachineCatalogRequest {
	return ApiMachineCatalogsTPTestMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineCatalogTestResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPTestMachineCatalogExecute(r ApiMachineCatalogsTPTestMachineCatalogRequest) (*MachineCatalogTestResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogTestResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPTestMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/$test"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPTestMachineCatalogExistsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	customerid string
	siteid string
	request *CatalogNameCheckRequestModel
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Name of the machine catalog.
func (r ApiMachineCatalogsTPTestMachineCatalogExistsRequest) Request(request CatalogNameCheckRequestModel) ApiMachineCatalogsTPTestMachineCatalogExistsRequest {
	r.request = &request
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPTestMachineCatalogExistsRequest) Authorization(authorization string) ApiMachineCatalogsTPTestMachineCatalogExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPTestMachineCatalogExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPTestMachineCatalogExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPTestMachineCatalogExistsRequest) XActionName(xActionName string) ApiMachineCatalogsTPTestMachineCatalogExistsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPTestMachineCatalogExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPTestMachineCatalogExistsExecute(r)
}

/*
MachineCatalogsTPTestMachineCatalogExists Test the existence of a machine catalog by name.

Check for the existence of a machine catalog by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPTestMachineCatalogExistsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPTestMachineCatalogExists(ctx context.Context, customerid string, siteid string) ApiMachineCatalogsTPTestMachineCatalogExistsRequest {
	return ApiMachineCatalogsTPTestMachineCatalogExistsRequest{
		ApiService: a,
		ctx: ctx,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPTestMachineCatalogExistsExecute(r ApiMachineCatalogsTPTestMachineCatalogExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPTestMachineCatalogExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/$checkCatalogName"
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *RemotePCEnrollmentScopeCheckModel
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Request model that contains distinguished name of an OU containing machines allowed to enroll as remote PCs.
func (r ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest) Request(request RemotePCEnrollmentScopeCheckModel) ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest {
	r.request = &request
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest) Authorization(authorization string) ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest) XActionName(xActionName string) ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPTestRemotePCEnrollmentScopeExistsExecute(r)
}

/*
MachineCatalogsTPTestRemotePCEnrollmentScopeExists Check for the existence of a RemotePC enrollment scope by name in the request body. Use HttpPost and take name in body as this name may be very long, and cause url too long exception.

Check for the existence of a RemotePC enrollment scope by name. Note that
RemotePC enrollment scope names must be unique within the site, so the
`nameOrId` parameter does not affect whether the RemotePC enrollment scope
name is found.
If the name is found to be available, this returns 404 Not Found.
If a RemotePC enrollment scope by that name exists and is associated with the
specified machine catalog, this returns 204 No Content. If a RemotePC
enrollment scope by that name exists and is associated with a different
machine catalog, this returns 303 See Other, and the `Location`
response header refers to location of the machine catalog which is associated
by the RemotePC enrollment scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPTestRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest {
	return ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPTestRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsTPTestRemotePCEnrollmentScopeExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPTestRemotePCEnrollmentScopeExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/RemotePCEnrollmentScopes/$checkScopeName"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPUpdateMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *UpdateMachineCatalogRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xAccessToken *string
	xActionName *string
}

// Properties of the machine catalog to update.
func (r ApiMachineCatalogsTPUpdateMachineCatalogRequest) Request(request UpdateMachineCatalogRequestModel) ApiMachineCatalogsTPUpdateMachineCatalogRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be updated as a background task. The task will have JobType UpdateMachineCatalog. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being updated, * _Name_ - Name of the machine catalog being updated.
func (r ApiMachineCatalogsTPUpdateMachineCatalogRequest) Async(async bool) ApiMachineCatalogsTPUpdateMachineCatalogRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPUpdateMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsTPUpdateMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPUpdateMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPUpdateMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsTPUpdateMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsTPUpdateMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPUpdateMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsTPUpdateMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPUpdateMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPUpdateMachineCatalogExecute(r)
}

/*
MachineCatalogsTPUpdateMachineCatalog Update a machine catalog.

Update a machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to update.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPUpdateMachineCatalogRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalog(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPUpdateMachineCatalogRequest {
	return ApiMachineCatalogsTPUpdateMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineCatalogDetailResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogExecute(r ApiMachineCatalogsTPUpdateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPUpdateMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest) Authorization(authorization string) ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest) XActionName(xActionName string) ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPUpdateMachineCatalogExistingMachinesExecute(r)
}

/*
MachineCatalogsTPUpdateMachineCatalogExistingMachines Apply current provisioning scheme to existing machines

Set-ProvScheme changes the template (provisioning scheme) and does not affect existing machines,
this method is used to request property update on existing machines

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogExistingMachines(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest {
	return ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogExistingMachinesExecute(r ApiMachineCatalogsTPUpdateMachineCatalogExistingMachinesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPUpdateMachineCatalogExistingMachines")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/$RequestProvVmUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	machine string
	customerid string
	siteid string
	details *UpdateMachineAccountRequestModel
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
}

// New details for the machine account record.
func (r ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest) Details(details UpdateMachineAccountRequestModel) ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest {
	r.details = &details
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest) XActionName(xActionName string) ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPUpdateMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsTPUpdateMachineCatalogMachineAccount Update a machine account within the machine catalog.

Update a machine account within the machine catalog.  This is typically used to reset or
update the machine password so that the site is able to apply the machine account to a
provisioned VM.


This is only relevant for machine catalogs where ProvisioningType is MCS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog containing the machine account.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param machine Machine account to update.  May be specified by SamName, UPN, or SID.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string, customerid string, siteid string) ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		machine: machine,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return ProvisioningSchemeMachineAccountResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogMachineAccountExecute(r ApiMachineCatalogsTPUpdateMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvisioningSchemeMachineAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPUpdateMachineCatalogMachineAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/MachineAccounts/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.details == nil {
		return localVarReturnValue, nil, reportError("details is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.details
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *UpdateMachineCatalogProvisioningSchemeRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details about the image update to be performed.
func (r ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest) Request(request UpdateMachineCatalogProvisioningSchemeRequestModel) ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest {
	r.request = &request
	return r
}

// Due to the long-running nature of the update operation, it cannot complete synchronously, and always initiates an asynchronous job to run to completion.  If the &#x60;async&#x60; parameter is &#x60;true&#x60;, the only difference is that instead of returning the initial job status in the payload, the response is instead &#x60;202&#x60; with the &#x60;Location&#x60; header pointing to the job status API.  This may be desirable for clients that wish to unify their logic for handling asynchronous jobs.  The task will have JobType . When the task is complete it will redirect to . The job&#39;s  will contain properties:   * _Id_ - ID of the machine catalog for which the provisioning scheme is being updated, * _Name_ - Name of the machine catalog for which the provisioning scheme is being updated, * _MasterImageXDPath_ - Path to the new image specified for the provisioning scheme, in XenApp &amp; XenDesktop path format. * _MasterImageFullPath_ - Path to the new image specified for the provisioning scheme, relative to the root of the API. * _MasterImageRelativePath_ - Path to the new image specified for the provisioning scheme, relative to the resource pool.
func (r ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest) Async(async bool) ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest) Authorization(authorization string) ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest) XActionName(xActionName string) ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPUpdateMachineCatalogProvisioningSchemeExecute(r)
}

/*
MachineCatalogsTPUpdateMachineCatalogProvisioningScheme Update the machine catalog's provisioning scheme.

Update the machine catalog's provisioning scheme.


Only valid when the machine catalog's ProvisioningType is MCS.


Provides the ability to update the hard disk image used to provision
virtual machines. If the provisioning scheme has CleanOnBoot equal to
`true`, then the next time that virtual machines are started, their
hard disks are updated to this new image. Regardless of CleanOnBoot,
all new virtual machines created after this call succeeds will use this
new hard disk image.


A snapshot or VM template is used rather than a VM, so that the
content of the hard disk for the provisioning scheme can be easily
determined.


The previous hard disk image path is stored into the history (see
).  The
data stored in the history allows for a rollback to be undertaken,
to revert to the previous hard disk image if required.


*Note:* The provisioning scheme for a machine catalog cannot be
changed while any provisioning tasks are already executing for the
machine catalog.  Cancel existing provisioning tasks or wait for
their completion before updating the provisioning scheme.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest {
	return ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return JobResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsTPUpdateMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPUpdateMachineCatalogProvisioningScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/$UpdateProvisioningScheme"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *UpdateUpgradeScheduleRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details about the updated VDA upgrade schedule.
func (r ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest) Request(request UpdateUpgradeScheduleRequestModel) ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be updated as a background task.
func (r ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest) XActionName(xActionName string) ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTPUpdateMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsTPUpdateMachineCatalogUpgradeSchedule Reschedule a pending VDA upgrade schedule for a machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachineCatalogsTPApiService) MachineCatalogsTPUpdateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsTPUpdateMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPUpdateMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsTPApiService
	nameOrId string
	customerid string
	siteid string
	request *VDAComponentsSelectionValidationRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// More details attached to this validation.
func (r ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Request(request VDAComponentsSelectionValidationRequestModel) ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.request = &request
	return r
}

// If async execute.
func (r ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Async(async bool) ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Authorization(authorization string) ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) XActionName(xActionName string) ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Execute() (*VDAComponentsSelectionValidationResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute(r)
}

/*
MachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelection Validate the VDA component selection at catalog level that can be Included/Excluded and features that need enable during an VDA upgrade using VDA Upgrade Service.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param customerid
 @param siteid
 @return ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest
*/
func (a *MachineCatalogsTPApiService) MachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelection(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	return ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return VDAComponentsSelectionValidationResponseModel
func (a *MachineCatalogsTPApiService) MachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute(r ApiMachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) (*VDAComponentsSelectionValidationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VDAComponentsSelectionValidationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsTPApiService.MachineCatalogsTPValidateMachineCatalogVDAComponentsAndFeaturesSelection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/MachineCatalogs/{nameOrId}/VDAComponentsAndFeatures/$validate"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
