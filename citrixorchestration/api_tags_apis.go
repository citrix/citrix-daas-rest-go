/*
Citrix Virtual Apps and Desktops Rest API for Developer Portal

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: devportal-onprem-ga
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// TagsAPIsDAASService TagsAPIsDAAS service
type TagsAPIsDAASService service

type ApiTagsCheckTagExistsRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	name                string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsCheckTagExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsCheckTagExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsCheckTagExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsCheckTagExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsCheckTagExistsRequest) UserAgent(userAgent string) ApiTagsCheckTagExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsCheckTagExistsRequest) Authorization(authorization string) ApiTagsCheckTagExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsCheckTagExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsCheckTagExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsCheckTagExistsRequest) Accept(accept string) ApiTagsCheckTagExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsCheckTagExistsRequest) CitrixLocale(citrixLocale string) ApiTagsCheckTagExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTagsCheckTagExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.TagsCheckTagExistsExecute(r)
}

/*
TagsCheckTagExists Check for the existence of a tag by name.

Check for the existence of a tag by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag.
	@return ApiTagsCheckTagExistsRequest
*/
func (a *TagsAPIsDAASService) TagsCheckTagExists(ctx context.Context, name string) ApiTagsCheckTagExistsRequest {
	return ApiTagsCheckTagExistsRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
func (a *TagsAPIsDAASService) TagsCheckTagExistsExecute(r ApiTagsCheckTagExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsCheckTagExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTagsCreateTagRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	tagRequestModel     *TagRequestModel
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsCreateTagRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsCreateTagRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsCreateTagRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsCreateTagRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details of the tag to create.
func (r ApiTagsCreateTagRequest) TagRequestModel(tagRequestModel TagRequestModel) ApiTagsCreateTagRequest {
	r.tagRequestModel = &tagRequestModel
	return r
}

// User Agent type of the request.
func (r ApiTagsCreateTagRequest) UserAgent(userAgent string) ApiTagsCreateTagRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsCreateTagRequest) Authorization(authorization string) ApiTagsCreateTagRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsCreateTagRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsCreateTagRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsCreateTagRequest) Accept(accept string) ApiTagsCreateTagRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsCreateTagRequest) CitrixLocale(citrixLocale string) ApiTagsCreateTagRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tag will be created as a background task. The task will have JobType CreateTag. When the task is complete it will redirect to \&quot;GetTag(string)\&quot;. The job&#39;s Parameters will contain properties:  * _Name_ - Name of the tag being created.
func (r ApiTagsCreateTagRequest) Async(async bool) ApiTagsCreateTagRequest {
	r.async = &async
	return r
}

func (r ApiTagsCreateTagRequest) Execute() (*TagResponseModel, *http.Response, error) {
	return r.ApiService.TagsCreateTagExecute(r)
}

/*
TagsCreateTag Create a tag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTagsCreateTagRequest
*/
func (a *TagsAPIsDAASService) TagsCreateTag(ctx context.Context) ApiTagsCreateTagRequest {
	return ApiTagsCreateTagRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TagResponseModel
func (a *TagsAPIsDAASService) TagsCreateTagExecute(r ApiTagsCreateTagRequest) (*TagResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsCreateTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.tagRequestModel == nil {
		return localVarReturnValue, nil, reportError("tagRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.tagRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsDeleteTagRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
	force               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsDeleteTagRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsDeleteTagRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsDeleteTagRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsDeleteTagRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsDeleteTagRequest) UserAgent(userAgent string) ApiTagsDeleteTagRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsDeleteTagRequest) Authorization(authorization string) ApiTagsDeleteTagRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsDeleteTagRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsDeleteTagRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsDeleteTagRequest) Accept(accept string) ApiTagsDeleteTagRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsDeleteTagRequest) CitrixLocale(citrixLocale string) ApiTagsDeleteTagRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tag will be deleted as a background task. The task will have JobType DeleteTag. When the task is complete it will redirect to GetTags. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the tag being deleted, * _Name_ - Name of the tag being deleted.
func (r ApiTagsDeleteTagRequest) Async(async bool) ApiTagsDeleteTagRequest {
	r.async = &async
	return r
}

// For deleting the tag if true
func (r ApiTagsDeleteTagRequest) Force(force bool) ApiTagsDeleteTagRequest {
	r.force = &force
	return r
}

func (r ApiTagsDeleteTagRequest) Execute() (*http.Response, error) {
	return r.ApiService.TagsDeleteTagExecute(r)
}

/*
TagsDeleteTag Delete a tag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsDeleteTagRequest
*/
func (a *TagsAPIsDAASService) TagsDeleteTag(ctx context.Context, nameOrId string) ApiTagsDeleteTagRequest {
	return ApiTagsDeleteTagRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *TagsAPIsDAASService) TagsDeleteTagExecute(r ApiTagsDeleteTagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsDeleteTag")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTagsGetTagRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsGetTagRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsGetTagRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsGetTagRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsGetTagRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsGetTagRequest) UserAgent(userAgent string) ApiTagsGetTagRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsGetTagRequest) Authorization(authorization string) ApiTagsGetTagRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsGetTagRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsGetTagRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsGetTagRequest) Accept(accept string) ApiTagsGetTagRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsGetTagRequest) CitrixLocale(citrixLocale string) ApiTagsGetTagRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTagsGetTagRequest) Execute() (*TagDetailResponseModel, *http.Response, error) {
	return r.ApiService.TagsGetTagExecute(r)
}

/*
TagsGetTag Get a single tag from the site.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsGetTagRequest
*/
func (a *TagsAPIsDAASService) TagsGetTag(ctx context.Context, nameOrId string) ApiTagsGetTagRequest {
	return ApiTagsGetTagRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return TagDetailResponseModel
func (a *TagsAPIsDAASService) TagsGetTagExecute(r ApiTagsGetTagRequest) (*TagDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsGetTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsGetTagApplicationGroupsRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsGetTagApplicationGroupsRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsGetTagApplicationGroupsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsGetTagApplicationGroupsRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsGetTagApplicationGroupsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsGetTagApplicationGroupsRequest) UserAgent(userAgent string) ApiTagsGetTagApplicationGroupsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsGetTagApplicationGroupsRequest) Authorization(authorization string) ApiTagsGetTagApplicationGroupsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsGetTagApplicationGroupsRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsGetTagApplicationGroupsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsGetTagApplicationGroupsRequest) Accept(accept string) ApiTagsGetTagApplicationGroupsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsGetTagApplicationGroupsRequest) CitrixLocale(citrixLocale string) ApiTagsGetTagApplicationGroupsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of application groups returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTagsGetTagApplicationGroupsRequest) Limit(limit int32) ApiTagsGetTagApplicationGroupsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiTagsGetTagApplicationGroupsRequest) ContinuationToken(continuationToken string) ApiTagsGetTagApplicationGroupsRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiTagsGetTagApplicationGroupsRequest) Execute() (*ApplicationGroupResponseModelCollection, *http.Response, error) {
	return r.ApiService.TagsGetTagApplicationGroupsExecute(r)
}

/*
TagsGetTagApplicationGroups Get the application groups associated with a tag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsGetTagApplicationGroupsRequest
*/
func (a *TagsAPIsDAASService) TagsGetTagApplicationGroups(ctx context.Context, nameOrId string) ApiTagsGetTagApplicationGroupsRequest {
	return ApiTagsGetTagApplicationGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return ApplicationGroupResponseModelCollection
func (a *TagsAPIsDAASService) TagsGetTagApplicationGroupsExecute(r ApiTagsGetTagApplicationGroupsRequest) (*ApplicationGroupResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationGroupResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsGetTagApplicationGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}/ApplicationGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsGetTagApplicationsRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsGetTagApplicationsRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsGetTagApplicationsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsGetTagApplicationsRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsGetTagApplicationsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsGetTagApplicationsRequest) UserAgent(userAgent string) ApiTagsGetTagApplicationsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsGetTagApplicationsRequest) Authorization(authorization string) ApiTagsGetTagApplicationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsGetTagApplicationsRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsGetTagApplicationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsGetTagApplicationsRequest) Accept(accept string) ApiTagsGetTagApplicationsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsGetTagApplicationsRequest) CitrixLocale(citrixLocale string) ApiTagsGetTagApplicationsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of applications returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTagsGetTagApplicationsRequest) Limit(limit int32) ApiTagsGetTagApplicationsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiTagsGetTagApplicationsRequest) ContinuationToken(continuationToken string) ApiTagsGetTagApplicationsRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiTagsGetTagApplicationsRequest) Execute() (*ApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiService.TagsGetTagApplicationsExecute(r)
}

/*
TagsGetTagApplications Get the applications associated with a tag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsGetTagApplicationsRequest
*/
func (a *TagsAPIsDAASService) TagsGetTagApplications(ctx context.Context, nameOrId string) ApiTagsGetTagApplicationsRequest {
	return ApiTagsGetTagApplicationsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return ApplicationResponseModelCollection
func (a *TagsAPIsDAASService) TagsGetTagApplicationsExecute(r ApiTagsGetTagApplicationsRequest) (*ApplicationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsGetTagApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}/Applications"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsGetTagDeliveryGroupsRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsGetTagDeliveryGroupsRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsGetTagDeliveryGroupsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsGetTagDeliveryGroupsRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsGetTagDeliveryGroupsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsGetTagDeliveryGroupsRequest) UserAgent(userAgent string) ApiTagsGetTagDeliveryGroupsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsGetTagDeliveryGroupsRequest) Authorization(authorization string) ApiTagsGetTagDeliveryGroupsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsGetTagDeliveryGroupsRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsGetTagDeliveryGroupsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsGetTagDeliveryGroupsRequest) Accept(accept string) ApiTagsGetTagDeliveryGroupsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsGetTagDeliveryGroupsRequest) CitrixLocale(citrixLocale string) ApiTagsGetTagDeliveryGroupsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of delivery groups returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTagsGetTagDeliveryGroupsRequest) Limit(limit int32) ApiTagsGetTagDeliveryGroupsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiTagsGetTagDeliveryGroupsRequest) ContinuationToken(continuationToken string) ApiTagsGetTagDeliveryGroupsRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiTagsGetTagDeliveryGroupsRequest) Execute() (*DeliveryGroupResponseModelCollection, *http.Response, error) {
	return r.ApiService.TagsGetTagDeliveryGroupsExecute(r)
}

/*
TagsGetTagDeliveryGroups Get the delivery groups associated with a tag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsGetTagDeliveryGroupsRequest
*/
func (a *TagsAPIsDAASService) TagsGetTagDeliveryGroups(ctx context.Context, nameOrId string) ApiTagsGetTagDeliveryGroupsRequest {
	return ApiTagsGetTagDeliveryGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return DeliveryGroupResponseModelCollection
func (a *TagsAPIsDAASService) TagsGetTagDeliveryGroupsExecute(r ApiTagsGetTagDeliveryGroupsRequest) (*DeliveryGroupResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeliveryGroupResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsGetTagDeliveryGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}/DeliveryGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsGetTagMachineCatalogsRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsGetTagMachineCatalogsRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsGetTagMachineCatalogsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsGetTagMachineCatalogsRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsGetTagMachineCatalogsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsGetTagMachineCatalogsRequest) UserAgent(userAgent string) ApiTagsGetTagMachineCatalogsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsGetTagMachineCatalogsRequest) Authorization(authorization string) ApiTagsGetTagMachineCatalogsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsGetTagMachineCatalogsRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsGetTagMachineCatalogsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsGetTagMachineCatalogsRequest) Accept(accept string) ApiTagsGetTagMachineCatalogsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsGetTagMachineCatalogsRequest) CitrixLocale(citrixLocale string) ApiTagsGetTagMachineCatalogsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTagsGetTagMachineCatalogsRequest) Limit(limit int32) ApiTagsGetTagMachineCatalogsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiTagsGetTagMachineCatalogsRequest) ContinuationToken(continuationToken string) ApiTagsGetTagMachineCatalogsRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiTagsGetTagMachineCatalogsRequest) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiService.TagsGetTagMachineCatalogsExecute(r)
}

/*
TagsGetTagMachineCatalogs Get the machine catalogs associated with a tag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsGetTagMachineCatalogsRequest
*/
func (a *TagsAPIsDAASService) TagsGetTagMachineCatalogs(ctx context.Context, nameOrId string) ApiTagsGetTagMachineCatalogsRequest {
	return ApiTagsGetTagMachineCatalogsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return MachineCatalogResponseModelCollection
func (a *TagsAPIsDAASService) TagsGetTagMachineCatalogsExecute(r ApiTagsGetTagMachineCatalogsRequest) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineCatalogResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsGetTagMachineCatalogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}/MachineCatalogs"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsGetTagMachinesRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
	fields              *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsGetTagMachinesRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsGetTagMachinesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsGetTagMachinesRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsGetTagMachinesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsGetTagMachinesRequest) UserAgent(userAgent string) ApiTagsGetTagMachinesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsGetTagMachinesRequest) Authorization(authorization string) ApiTagsGetTagMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsGetTagMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsGetTagMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsGetTagMachinesRequest) Accept(accept string) ApiTagsGetTagMachinesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsGetTagMachinesRequest) CitrixLocale(citrixLocale string) ApiTagsGetTagMachinesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of machines returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTagsGetTagMachinesRequest) Limit(limit int32) ApiTagsGetTagMachinesRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiTagsGetTagMachinesRequest) ContinuationToken(continuationToken string) ApiTagsGetTagMachinesRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server
func (r ApiTagsGetTagMachinesRequest) Fields(fields string) ApiTagsGetTagMachinesRequest {
	r.fields = &fields
	return r
}

func (r ApiTagsGetTagMachinesRequest) Execute() (*MachineResponseModelCollection, *http.Response, error) {
	return r.ApiService.TagsGetTagMachinesExecute(r)
}

/*
TagsGetTagMachines Get the machines associated with a tag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsGetTagMachinesRequest
*/
func (a *TagsAPIsDAASService) TagsGetTagMachines(ctx context.Context, nameOrId string) ApiTagsGetTagMachinesRequest {
	return ApiTagsGetTagMachinesRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return MachineResponseModelCollection
func (a *TagsAPIsDAASService) TagsGetTagMachinesExecute(r ApiTagsGetTagMachinesRequest) (*MachineResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsGetTagMachines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}/Machines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsGetTagsRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
	fields              *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsGetTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsGetTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsGetTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsGetTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTagsGetTagsRequest) UserAgent(userAgent string) ApiTagsGetTagsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsGetTagsRequest) Authorization(authorization string) ApiTagsGetTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsGetTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsGetTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsGetTagsRequest) Accept(accept string) ApiTagsGetTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsGetTagsRequest) CitrixLocale(citrixLocale string) ApiTagsGetTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of tags returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTagsGetTagsRequest) Limit(limit int32) ApiTagsGetTagsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiTagsGetTagsRequest) ContinuationToken(continuationToken string) ApiTagsGetTagsRequest {
	r.continuationToken = &continuationToken
	return r
}

// The required fields of tag.
func (r ApiTagsGetTagsRequest) Fields(fields string) ApiTagsGetTagsRequest {
	r.fields = &fields
	return r
}

func (r ApiTagsGetTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.TagsGetTagsExecute(r)
}

/*
TagsGetTags Get the list of all tags in the site.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTagsGetTagsRequest
*/
func (a *TagsAPIsDAASService) TagsGetTags(ctx context.Context) ApiTagsGetTagsRequest {
	return ApiTagsGetTagsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TagResponseModelCollection
func (a *TagsAPIsDAASService) TagsGetTagsExecute(r ApiTagsGetTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsGetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsPatchTagRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	tagRequestModel     *TagRequestModel
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsPatchTagRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsPatchTagRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsPatchTagRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsPatchTagRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details of the tag to update.
func (r ApiTagsPatchTagRequest) TagRequestModel(tagRequestModel TagRequestModel) ApiTagsPatchTagRequest {
	r.tagRequestModel = &tagRequestModel
	return r
}

// User Agent type of the request.
func (r ApiTagsPatchTagRequest) UserAgent(userAgent string) ApiTagsPatchTagRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsPatchTagRequest) Authorization(authorization string) ApiTagsPatchTagRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsPatchTagRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsPatchTagRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsPatchTagRequest) Accept(accept string) ApiTagsPatchTagRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsPatchTagRequest) CitrixLocale(citrixLocale string) ApiTagsPatchTagRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tag will be updated as a background task. The task will have JobType UpdateTag. When the task is complete it will redirect to \&quot;GetTag(string)\&quot;. The job&#39;s Parameters will contain properties:   * _Id_ - ID of the tag being updated, * _Name_ - Name of the tag being updated.
func (r ApiTagsPatchTagRequest) Async(async bool) ApiTagsPatchTagRequest {
	r.async = &async
	return r
}

func (r ApiTagsPatchTagRequest) Execute() (*TagResponseModel, *http.Response, error) {
	return r.ApiService.TagsPatchTagExecute(r)
}

/*
TagsPatchTag Update a tag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsPatchTagRequest
*/
func (a *TagsAPIsDAASService) TagsPatchTag(ctx context.Context, nameOrId string) ApiTagsPatchTagRequest {
	return ApiTagsPatchTagRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return TagResponseModel
func (a *TagsAPIsDAASService) TagsPatchTagExecute(r ApiTagsPatchTagRequest) (*TagResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsPatchTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.tagRequestModel == nil {
		return localVarReturnValue, nil, reportError("tagRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.tagRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagsSetTagApplicationsRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	refsRequestModel    *RefsRequestModel
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsSetTagApplicationsRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsSetTagApplicationsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsSetTagApplicationsRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsSetTagApplicationsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// The applications to tag.  Any application             not listed will be untagged if it was previously associated with the tag.
func (r ApiTagsSetTagApplicationsRequest) RefsRequestModel(refsRequestModel RefsRequestModel) ApiTagsSetTagApplicationsRequest {
	r.refsRequestModel = &refsRequestModel
	return r
}

// User Agent type of the request.
func (r ApiTagsSetTagApplicationsRequest) UserAgent(userAgent string) ApiTagsSetTagApplicationsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsSetTagApplicationsRequest) Authorization(authorization string) ApiTagsSetTagApplicationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsSetTagApplicationsRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsSetTagApplicationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsSetTagApplicationsRequest) Accept(accept string) ApiTagsSetTagApplicationsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsSetTagApplicationsRequest) CitrixLocale(citrixLocale string) ApiTagsSetTagApplicationsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task. The task will have JobType SetTagApplications. When the task is complete it will redirect to GetTagApplications. The job&#39;s Parameters will contain properties: * _Id_ - ID of the tag being associated with applications, * _Name_ - Name of the tag being associated with applications.
func (r ApiTagsSetTagApplicationsRequest) Async(async bool) ApiTagsSetTagApplicationsRequest {
	r.async = &async
	return r
}

func (r ApiTagsSetTagApplicationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.TagsSetTagApplicationsExecute(r)
}

/*
TagsSetTagApplications Associate a tag with applications.

Associate a tag with applications.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsSetTagApplicationsRequest
*/
func (a *TagsAPIsDAASService) TagsSetTagApplications(ctx context.Context, nameOrId string) ApiTagsSetTagApplicationsRequest {
	return ApiTagsSetTagApplicationsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *TagsAPIsDAASService) TagsSetTagApplicationsExecute(r ApiTagsSetTagApplicationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsSetTagApplications")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}/Applications"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.refsRequestModel == nil {
		return nil, reportError("refsRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.refsRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTagsSetTagDeliveryGroupsRequest struct {
	ctx                 context.Context
	ApiService          *TagsAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	refsRequestModel    *RefsRequestModel
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiTagsSetTagDeliveryGroupsRequest) CitrixCustomerId(citrixCustomerId string) ApiTagsSetTagDeliveryGroupsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiTagsSetTagDeliveryGroupsRequest) CitrixInstanceId(citrixInstanceId string) ApiTagsSetTagDeliveryGroupsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// The delivery groups to tag.  Any delivery group             not listed will be untagged if it was previously associated with the tag.
func (r ApiTagsSetTagDeliveryGroupsRequest) RefsRequestModel(refsRequestModel RefsRequestModel) ApiTagsSetTagDeliveryGroupsRequest {
	r.refsRequestModel = &refsRequestModel
	return r
}

// User Agent type of the request.
func (r ApiTagsSetTagDeliveryGroupsRequest) UserAgent(userAgent string) ApiTagsSetTagDeliveryGroupsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTagsSetTagDeliveryGroupsRequest) Authorization(authorization string) ApiTagsSetTagDeliveryGroupsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTagsSetTagDeliveryGroupsRequest) CitrixTransactionId(citrixTransactionId string) ApiTagsSetTagDeliveryGroupsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiTagsSetTagDeliveryGroupsRequest) Accept(accept string) ApiTagsSetTagDeliveryGroupsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTagsSetTagDeliveryGroupsRequest) CitrixLocale(citrixLocale string) ApiTagsSetTagDeliveryGroupsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task. The task will have JobType SetTagDeliveryGroups. When the task is complete it will redirect to GetTagDeliveryGroups. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the tag being associated with delivery groups, * _Name_ - Name of the tag being associated with delivery groups.
func (r ApiTagsSetTagDeliveryGroupsRequest) Async(async bool) ApiTagsSetTagDeliveryGroupsRequest {
	r.async = &async
	return r
}

func (r ApiTagsSetTagDeliveryGroupsRequest) Execute() (*http.Response, error) {
	return r.ApiService.TagsSetTagDeliveryGroupsExecute(r)
}

/*
TagsSetTagDeliveryGroups Associate a tag with delivery groups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the tag.
	@return ApiTagsSetTagDeliveryGroupsRequest
*/
func (a *TagsAPIsDAASService) TagsSetTagDeliveryGroups(ctx context.Context, nameOrId string) ApiTagsSetTagDeliveryGroupsRequest {
	return ApiTagsSetTagDeliveryGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *TagsAPIsDAASService) TagsSetTagDeliveryGroupsExecute(r ApiTagsSetTagDeliveryGroupsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIsDAASService.TagsSetTagDeliveryGroups")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tags/{nameOrId}/DeliveryGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.refsRequestModel == nil {
		return nil, reportError("refsRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.refsRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
