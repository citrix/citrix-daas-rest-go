/*
Citrix Virtual Apps and Desktops Rest API for Developer Portal

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: devportal-onprem-ga
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// MaintenanceCyclesAPIsDAASService MaintenanceCyclesAPIsDAAS service
type MaintenanceCyclesAPIsDAASService service

type ApiMaintenanceCyclesCancelMaintenanceCycleRequest struct {
	ctx                 context.Context
	ApiService          *MaintenanceCyclesAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) CitrixCustomerId(citrixCustomerId string) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) CitrixInstanceId(citrixInstanceId string) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) UserAgent(userAgent string) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) Authorization(authorization string) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) CitrixTransactionId(citrixTransactionId string) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) Accept(accept string) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) CitrixLocale(citrixLocale string) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the maintenance cycle will be removed within a background task.
func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) Async(async bool) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	r.async = &async
	return r
}

func (r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MaintenanceCyclesCancelMaintenanceCycleExecute(r)
}

/*
MaintenanceCyclesCancelMaintenanceCycle Cancel a maintenance cycle for a machine catalog.

A maintenance cycle can only be cancelled when the cycle status is not in 'completed'.
If the maintenance cycle is in another status, the operation fails with HTTP response status 404.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId
	@return ApiMaintenanceCyclesCancelMaintenanceCycleRequest
*/
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesCancelMaintenanceCycle(ctx context.Context, nameOrId string) ApiMaintenanceCyclesCancelMaintenanceCycleRequest {
	return ApiMaintenanceCyclesCancelMaintenanceCycleRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesCancelMaintenanceCycleExecute(r ApiMaintenanceCyclesCancelMaintenanceCycleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintenanceCyclesAPIsDAASService.MaintenanceCyclesCancelMaintenanceCycle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintenanceCycles/{nameOrId}/$cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMaintenanceCyclesCreateMaintenanceCycleRequest struct {
	ctx                                context.Context
	ApiService                         *MaintenanceCyclesAPIsDAASService
	citrixCustomerId                   *string
	citrixInstanceId                   *string
	createMaintenanceCycleRequestModel *CreateMaintenanceCycleRequestModel
	userAgent                          *string
	authorization                      *string
	citrixTransactionId                *string
	accept                             *string
	citrixLocale                       *string
	async                              *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) CitrixCustomerId(citrixCustomerId string) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) CitrixInstanceId(citrixInstanceId string) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details to create the maintenance cycle.
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) CreateMaintenanceCycleRequestModel(createMaintenanceCycleRequestModel CreateMaintenanceCycleRequestModel) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.createMaintenanceCycleRequestModel = &createMaintenanceCycleRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) UserAgent(userAgent string) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) Authorization(authorization string) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) CitrixTransactionId(citrixTransactionId string) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) Accept(accept string) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) CitrixLocale(citrixLocale string) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the maintenance cycle will be create within a background task.
func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) Async(async bool) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	r.async = &async
	return r
}

func (r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MaintenanceCyclesCreateMaintenanceCycleExecute(r)
}

/*
MaintenanceCyclesCreateMaintenanceCycle Create a maintenance cycle for a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMaintenanceCyclesCreateMaintenanceCycleRequest
*/
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesCreateMaintenanceCycle(ctx context.Context) ApiMaintenanceCyclesCreateMaintenanceCycleRequest {
	return ApiMaintenanceCyclesCreateMaintenanceCycleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesCreateMaintenanceCycleExecute(r ApiMaintenanceCyclesCreateMaintenanceCycleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintenanceCyclesAPIsDAASService.MaintenanceCyclesCreateMaintenanceCycle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintenanceCycles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.createMaintenanceCycleRequestModel == nil {
		return nil, reportError("createMaintenanceCycleRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.createMaintenanceCycleRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest struct {
	ctx                                context.Context
	ApiService                         *MaintenanceCyclesAPIsDAASService
	citrixCustomerId                   *string
	citrixInstanceId                   *string
	maintenanceCycleSearchRequestModel *MaintenanceCycleSearchRequestModel
	userAgent                          *string
	authorization                      *string
	citrixTransactionId                *string
	accept                             *string
	citrixLocale                       *string
	async                              *bool
	limit                              *int32
	skip                               *int32
	continuationToken                  *string
	fields                             *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) CitrixCustomerId(citrixCustomerId string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) CitrixInstanceId(citrixInstanceId string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Specifies the advanced search parameters.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) MaintenanceCycleSearchRequestModel(maintenanceCycleSearchRequestModel MaintenanceCycleSearchRequestModel) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.maintenanceCycleSearchRequestModel = &maintenanceCycleSearchRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) UserAgent(userAgent string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) Authorization(authorization string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) CitrixTransactionId(citrixTransactionId string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) Accept(accept string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) CitrixLocale(citrixLocale string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the maintenance cycles (and associated objects) will be added as a background task. The task will have JobType SearchMaintenanceCycles.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) Async(async bool) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.async = &async
	return r
}

// The max number of maintenance cycles returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) Limit(limit int32) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.limit = &limit
	return r
}

func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) Skip(skip int32) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.skip = &skip
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) ContinuationToken(continuationToken string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) Fields(fields string) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	r.fields = &fields
	return r
}

func (r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) Execute() (*MaintenanceCycleResponseModelCollection, *http.Response, error) {
	return r.ApiService.MaintenanceCyclesDoMaintenanceCycleSearchExecute(r)
}

/*
MaintenanceCyclesDoMaintenanceCycleSearch Perform an advanced search for maintenance cycles.

Perform an advanced search for mainenance cycles.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest
*/
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesDoMaintenanceCycleSearch(ctx context.Context) ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest {
	return ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MaintenanceCycleResponseModelCollection
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesDoMaintenanceCycleSearchExecute(r ApiMaintenanceCyclesDoMaintenanceCycleSearchRequest) (*MaintenanceCycleResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MaintenanceCycleResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintenanceCyclesAPIsDAASService.MaintenanceCyclesDoMaintenanceCycleSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintenanceCycles/$search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.maintenanceCycleSearchRequestModel == nil {
		return localVarReturnValue, nil, reportError("maintenanceCycleSearchRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.maintenanceCycleSearchRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest struct {
	ctx                                              context.Context
	ApiService                                       *MaintenanceCyclesAPIsDAASService
	citrixCustomerId                                 *string
	citrixInstanceId                                 *string
	maintenanceCycleVMOperationJobSearchRequestModel *MaintenanceCycleVMOperationJobSearchRequestModel
	userAgent                                        *string
	authorization                                    *string
	citrixTransactionId                              *string
	accept                                           *string
	citrixLocale                                     *string
	async                                            *bool
	limit                                            *int32
	skip                                             *int32
	continuationToken                                *string
	fields                                           *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) CitrixCustomerId(citrixCustomerId string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) CitrixInstanceId(citrixInstanceId string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Specifies the advanced search parameters.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) MaintenanceCycleVMOperationJobSearchRequestModel(maintenanceCycleVMOperationJobSearchRequestModel MaintenanceCycleVMOperationJobSearchRequestModel) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.maintenanceCycleVMOperationJobSearchRequestModel = &maintenanceCycleVMOperationJobSearchRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) UserAgent(userAgent string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) Authorization(authorization string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) CitrixTransactionId(citrixTransactionId string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) Accept(accept string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) CitrixLocale(citrixLocale string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the maintenance cycle vm operation jobs (and associated objects) will be added as a background task. The task will have JobType SearchMaintenanceCycleVMOperationJobs.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) Async(async bool) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.async = &async
	return r
}

// The max number of maintenance cycle vm operation jobs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) Limit(limit int32) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.limit = &limit
	return r
}

func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) Skip(skip int32) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.skip = &skip
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) ContinuationToken(continuationToken string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) Fields(fields string) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	r.fields = &fields
	return r
}

func (r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) Execute() (*MaintenanceCycleVMOperationJobResponseModelCollection, *http.Response, error) {
	return r.ApiService.MaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchExecute(r)
}

/*
MaintenanceCyclesDoMaintenanceCycleVMOperationJobSearch Perform an advanced search for maintenance cycle vm operation jobs.

Perform an advanced search for mainenance cycle vm operation jobs.  Note that some combinations
of search parameters may result in slow performance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest
*/
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesDoMaintenanceCycleVMOperationJobSearch(ctx context.Context) ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest {
	return ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MaintenanceCycleVMOperationJobResponseModelCollection
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchExecute(r ApiMaintenanceCyclesDoMaintenanceCycleVMOperationJobSearchRequest) (*MaintenanceCycleVMOperationJobResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MaintenanceCycleVMOperationJobResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintenanceCyclesAPIsDAASService.MaintenanceCyclesDoMaintenanceCycleVMOperationJobSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintenanceCycles/operationJobs/$search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.maintenanceCycleVMOperationJobSearchRequestModel == nil {
		return localVarReturnValue, nil, reportError("maintenanceCycleVMOperationJobSearchRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.maintenanceCycleVMOperationJobSearchRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMaintenanceCyclesGetMaintenanceCycleRequest struct {
	ctx                 context.Context
	ApiService          *MaintenanceCyclesAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) CitrixCustomerId(citrixCustomerId string) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) CitrixInstanceId(citrixInstanceId string) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) UserAgent(userAgent string) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) Authorization(authorization string) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) CitrixTransactionId(citrixTransactionId string) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) Accept(accept string) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) CitrixLocale(citrixLocale string) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the maintenance cycle will be get within a background task.
func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) Async(async bool) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	r.async = &async
	return r
}

func (r ApiMaintenanceCyclesGetMaintenanceCycleRequest) Execute() (*MaintenanceCycleDetailsResponseModel, *http.Response, error) {
	return r.ApiService.MaintenanceCyclesGetMaintenanceCycleExecute(r)
}

/*
MaintenanceCyclesGetMaintenanceCycle Get a maintenance cycle for a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId The Id or name of the maintenance cycle to get.
	@return ApiMaintenanceCyclesGetMaintenanceCycleRequest
*/
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesGetMaintenanceCycle(ctx context.Context, nameOrId string) ApiMaintenanceCyclesGetMaintenanceCycleRequest {
	return ApiMaintenanceCyclesGetMaintenanceCycleRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return MaintenanceCycleDetailsResponseModel
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesGetMaintenanceCycleExecute(r ApiMaintenanceCyclesGetMaintenanceCycleRequest) (*MaintenanceCycleDetailsResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MaintenanceCycleDetailsResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintenanceCyclesAPIsDAASService.MaintenanceCyclesGetMaintenanceCycle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintenanceCycles/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMaintenanceCyclesRemoveMaintenanceCycleRequest struct {
	ctx                 context.Context
	ApiService          *MaintenanceCyclesAPIsDAASService
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) CitrixCustomerId(citrixCustomerId string) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) CitrixInstanceId(citrixInstanceId string) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) UserAgent(userAgent string) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) Authorization(authorization string) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) CitrixTransactionId(citrixTransactionId string) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) Accept(accept string) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) CitrixLocale(citrixLocale string) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the maintenance cycle will be removed within a background task.
func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) Async(async bool) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	r.async = &async
	return r
}

func (r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MaintenanceCyclesRemoveMaintenanceCycleExecute(r)
}

/*
MaintenanceCyclesRemoveMaintenanceCycle Remove a maintenance cycle for a machine catalog.

A maintenance cycle can only be removed from machine catalog when the cycle status is not in 'running' or 'cancelling'.
If the maintenace cycle is in another status, the operation fails with HTTP response status 404.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId
	@return ApiMaintenanceCyclesRemoveMaintenanceCycleRequest
*/
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesRemoveMaintenanceCycle(ctx context.Context, nameOrId string) ApiMaintenanceCyclesRemoveMaintenanceCycleRequest {
	return ApiMaintenanceCyclesRemoveMaintenanceCycleRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesRemoveMaintenanceCycleExecute(r ApiMaintenanceCyclesRemoveMaintenanceCycleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintenanceCyclesAPIsDAASService.MaintenanceCyclesRemoveMaintenanceCycle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintenanceCycles/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMaintenanceCyclesRestartMaintenanceCycleRequest struct {
	ctx                                 context.Context
	ApiService                          *MaintenanceCyclesAPIsDAASService
	citrixCustomerId                    *string
	citrixInstanceId                    *string
	nameOrId                            string
	restartMaintenanceCycleRequestModel *RestartMaintenanceCycleRequestModel
	userAgent                           *string
	authorization                       *string
	citrixTransactionId                 *string
	accept                              *string
	citrixLocale                        *string
	async                               *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) CitrixCustomerId(citrixCustomerId string) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) CitrixInstanceId(citrixInstanceId string) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details to restart the maintenance cycle.
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) RestartMaintenanceCycleRequestModel(restartMaintenanceCycleRequestModel RestartMaintenanceCycleRequestModel) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.restartMaintenanceCycleRequestModel = &restartMaintenanceCycleRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) UserAgent(userAgent string) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) Authorization(authorization string) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) CitrixTransactionId(citrixTransactionId string) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) Accept(accept string) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) CitrixLocale(citrixLocale string) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the maintenance cycle will be restarted within a background task.
func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) Async(async bool) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	r.async = &async
	return r
}

func (r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MaintenanceCyclesRestartMaintenanceCycleExecute(r)
}

/*
MaintenanceCyclesRestartMaintenanceCycle Restart a maintenance cycle for a machine catalog.

A maintenance cycle can only be restarted when the cycle status is in 'cancelled', 'failed' or 'completed'.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId The Id or name of the maintenance cycle to restart.
	@return ApiMaintenanceCyclesRestartMaintenanceCycleRequest
*/
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesRestartMaintenanceCycle(ctx context.Context, nameOrId string) ApiMaintenanceCyclesRestartMaintenanceCycleRequest {
	return ApiMaintenanceCyclesRestartMaintenanceCycleRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesRestartMaintenanceCycleExecute(r ApiMaintenanceCyclesRestartMaintenanceCycleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintenanceCyclesAPIsDAASService.MaintenanceCyclesRestartMaintenanceCycle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintenanceCycles/{nameOrId}/$restart"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.restartMaintenanceCycleRequestModel == nil {
		return nil, reportError("restartMaintenanceCycleRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.restartMaintenanceCycleRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMaintenanceCyclesUpdateMaintenanceCycleRequest struct {
	ctx                                context.Context
	ApiService                         *MaintenanceCyclesAPIsDAASService
	citrixCustomerId                   *string
	citrixInstanceId                   *string
	updateMaintenanceCycleRequestModel *UpdateMaintenanceCycleRequestModel
	userAgent                          *string
	authorization                      *string
	citrixTransactionId                *string
	accept                             *string
	citrixLocale                       *string
	async                              *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) CitrixCustomerId(citrixCustomerId string) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) CitrixInstanceId(citrixInstanceId string) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details to create the maintenance cycle.
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) UpdateMaintenanceCycleRequestModel(updateMaintenanceCycleRequestModel UpdateMaintenanceCycleRequestModel) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.updateMaintenanceCycleRequestModel = &updateMaintenanceCycleRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) UserAgent(userAgent string) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) Authorization(authorization string) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) CitrixTransactionId(citrixTransactionId string) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) Accept(accept string) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) CitrixLocale(citrixLocale string) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the maintenance cycle will be create within a background task.
func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) Async(async bool) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	r.async = &async
	return r
}

func (r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MaintenanceCyclesUpdateMaintenanceCycleExecute(r)
}

/*
MaintenanceCyclesUpdateMaintenanceCycle Update a maintenance cycle for a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMaintenanceCyclesUpdateMaintenanceCycleRequest
*/
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesUpdateMaintenanceCycle(ctx context.Context) ApiMaintenanceCyclesUpdateMaintenanceCycleRequest {
	return ApiMaintenanceCyclesUpdateMaintenanceCycleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *MaintenanceCyclesAPIsDAASService) MaintenanceCyclesUpdateMaintenanceCycleExecute(r ApiMaintenanceCyclesUpdateMaintenanceCycleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintenanceCyclesAPIsDAASService.MaintenanceCyclesUpdateMaintenanceCycle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintenanceCycles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.updateMaintenanceCycleRequestModel == nil {
		return nil, reportError("updateMaintenanceCycleRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.updateMaintenanceCycleRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
