/*
Citrix Virtual Apps and Desktops Rest API for Developer Portal

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: devportal-onprem-ga
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IdentityAPIsDAASService IdentityAPIsDAAS service
type IdentityAPIsDAASService service

type ApiIdentityAddAzureAdSecurityGroupMemberRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	azureAdTenantId string
	groupId string
	refGroupId string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAccessToken *string
	accept *string
	citrixLocale *string
	serviceAccountUid *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) UserAgent(userAgent string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) Authorization(authorization string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) XAccessToken(xAccessToken string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Must accept application/json.
func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) Accept(accept string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) CitrixLocale(citrixLocale string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) ServiceAccountUid(serviceAccountUid string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	r.serviceAccountUid = &serviceAccountUid
	return r
}

func (r ApiIdentityAddAzureAdSecurityGroupMemberRequest) Execute() (*http.Response, error) {
	return r.ApiService.IdentityAddAzureAdSecurityGroupMemberExecute(r)
}

/*
IdentityAddAzureAdSecurityGroupMember Add a security group to an assigned security as it's member

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param azureAdTenantId The Azure tenant id.
 @param groupId The parent assigned security group object id
 @param refGroupId The nested devices security group object id
 @return ApiIdentityAddAzureAdSecurityGroupMemberRequest
*/
func (a *IdentityAPIsDAASService) IdentityAddAzureAdSecurityGroupMember(ctx context.Context, azureAdTenantId string, groupId string, refGroupId string) ApiIdentityAddAzureAdSecurityGroupMemberRequest {
	return ApiIdentityAddAzureAdSecurityGroupMemberRequest{
		ApiService: a,
		ctx: ctx,
		azureAdTenantId: azureAdTenantId,
		groupId: groupId,
		refGroupId: refGroupId,
	}
}

// Execute executes the request
func (a *IdentityAPIsDAASService) IdentityAddAzureAdSecurityGroupMemberExecute(r ApiIdentityAddAzureAdSecurityGroupMemberRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityAddAzureAdSecurityGroupMember")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/AzureADTenants/{azureAdTenantId}/AzureADSecurityGroups/{groupId}/members/{refGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"azureAdTenantId"+"}", url.PathEscape(parameterValueToString(r.azureAdTenantId, "azureAdTenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"refGroupId"+"}", url.PathEscape(parameterValueToString(r.refGroupId, "refGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.serviceAccountUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceAccountUid", r.serviceAccountUid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityCreateMachineRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	identityCreateMachineRequestModel *IdentityCreateMachineRequestModel
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityCreateMachineRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityCreateMachineRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityCreateMachineRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityCreateMachineRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details of the machine identity to create.
func (r ApiIdentityCreateMachineRequest) IdentityCreateMachineRequestModel(identityCreateMachineRequestModel IdentityCreateMachineRequestModel) ApiIdentityCreateMachineRequest {
	r.identityCreateMachineRequestModel = &identityCreateMachineRequestModel
	return r
}

// User Agent type of the request.
func (r ApiIdentityCreateMachineRequest) UserAgent(userAgent string) ApiIdentityCreateMachineRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityCreateMachineRequest) Authorization(authorization string) ApiIdentityCreateMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityCreateMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityCreateMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityCreateMachineRequest) XAdminCredential(xAdminCredential string) ApiIdentityCreateMachineRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityCreateMachineRequest) Accept(accept string) ApiIdentityCreateMachineRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityCreateMachineRequest) CitrixLocale(citrixLocale string) ApiIdentityCreateMachineRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the machine identity will be created as a background task.
func (r ApiIdentityCreateMachineRequest) Async(async bool) ApiIdentityCreateMachineRequest {
	r.async = &async
	return r
}

func (r ApiIdentityCreateMachineRequest) Execute() (*IdentityMachineResponseModel, *http.Response, error) {
	return r.ApiService.IdentityCreateMachineExecute(r)
}

/*
IdentityCreateMachine Create machine identity

Create machine identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityCreateMachineRequest
*/
func (a *IdentityAPIsDAASService) IdentityCreateMachine(ctx context.Context) ApiIdentityCreateMachineRequest {
	return ApiIdentityCreateMachineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityMachineResponseModel
func (a *IdentityAPIsDAASService) IdentityCreateMachineExecute(r ApiIdentityCreateMachineRequest) (*IdentityMachineResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityMachineResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityCreateMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Machines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.identityCreateMachineRequestModel == nil {
		return localVarReturnValue, nil, reportError("identityCreateMachineRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.identityCreateMachineRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityCreateServiceAccountRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	createServiceAccountRequestModel *CreateServiceAccountRequestModel
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityCreateServiceAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityCreateServiceAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityCreateServiceAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityCreateServiceAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// The object of CreateServiceAccountRequestModel used to create a service account. 
func (r ApiIdentityCreateServiceAccountRequest) CreateServiceAccountRequestModel(createServiceAccountRequestModel CreateServiceAccountRequestModel) ApiIdentityCreateServiceAccountRequest {
	r.createServiceAccountRequestModel = &createServiceAccountRequestModel
	return r
}

// User Agent type of the request.
func (r ApiIdentityCreateServiceAccountRequest) UserAgent(userAgent string) ApiIdentityCreateServiceAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityCreateServiceAccountRequest) Authorization(authorization string) ApiIdentityCreateServiceAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityCreateServiceAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityCreateServiceAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityCreateServiceAccountRequest) Accept(accept string) ApiIdentityCreateServiceAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityCreateServiceAccountRequest) CitrixLocale(citrixLocale string) ApiIdentityCreateServiceAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentityCreateServiceAccountRequest) Execute() (*ServiceAccountResponseModel, *http.Response, error) {
	return r.ApiService.IdentityCreateServiceAccountExecute(r)
}

/*
IdentityCreateServiceAccount Create a service account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityCreateServiceAccountRequest
*/
func (a *IdentityAPIsDAASService) IdentityCreateServiceAccount(ctx context.Context) ApiIdentityCreateServiceAccountRequest {
	return ApiIdentityCreateServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceAccountResponseModel
func (a *IdentityAPIsDAASService) IdentityCreateServiceAccountExecute(r ApiIdentityCreateServiceAccountRequest) (*ServiceAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityCreateServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/ServiceAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.createServiceAccountRequestModel == nil {
		return localVarReturnValue, nil, reportError("createServiceAccountRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.createServiceAccountRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityDeleteMachineRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	machine string
	forest *string
	domain *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	directoryServerHint *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityDeleteMachineRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityDeleteMachineRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityDeleteMachineRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityDeleteMachineRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Forest to delete machine account from.  Required.
func (r ApiIdentityDeleteMachineRequest) Forest(forest string) ApiIdentityDeleteMachineRequest {
	r.forest = &forest
	return r
}

// Domain to delete machine account from.  Required.
func (r ApiIdentityDeleteMachineRequest) Domain(domain string) ApiIdentityDeleteMachineRequest {
	r.domain = &domain
	return r
}

// User Agent type of the request.
func (r ApiIdentityDeleteMachineRequest) UserAgent(userAgent string) ApiIdentityDeleteMachineRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityDeleteMachineRequest) Authorization(authorization string) ApiIdentityDeleteMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityDeleteMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityDeleteMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityDeleteMachineRequest) XAdminCredential(xAdminCredential string) ApiIdentityDeleteMachineRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityDeleteMachineRequest) Accept(accept string) ApiIdentityDeleteMachineRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityDeleteMachineRequest) CitrixLocale(citrixLocale string) ApiIdentityDeleteMachineRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityDeleteMachineRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityDeleteMachineRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// If &#x60;true&#x60;, the machine identity will be deleted as a background task.
func (r ApiIdentityDeleteMachineRequest) Async(async bool) ApiIdentityDeleteMachineRequest {
	r.async = &async
	return r
}

func (r ApiIdentityDeleteMachineRequest) Execute() (*http.Response, error) {
	return r.ApiService.IdentityDeleteMachineExecute(r)
}

/*
IdentityDeleteMachine Delete a machine identity

Delete a machine identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param machine Machine identity to delete.
 @return ApiIdentityDeleteMachineRequest
*/
func (a *IdentityAPIsDAASService) IdentityDeleteMachine(ctx context.Context, machine string) ApiIdentityDeleteMachineRequest {
	return ApiIdentityDeleteMachineRequest{
		ApiService: a,
		ctx: ctx,
		machine: machine,
	}
}

// Execute executes the request
func (a *IdentityAPIsDAASService) IdentityDeleteMachineExecute(r ApiIdentityDeleteMachineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityDeleteMachine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Machines/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.forest == nil {
		return nil, reportError("forest is required and must be specified")
	}
	if r.domain == nil {
		return nil, reportError("domain is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityDeleteServiceAccountRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	serviceAccountUid string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityDeleteServiceAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityDeleteServiceAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityDeleteServiceAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityDeleteServiceAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityDeleteServiceAccountRequest) UserAgent(userAgent string) ApiIdentityDeleteServiceAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityDeleteServiceAccountRequest) Authorization(authorization string) ApiIdentityDeleteServiceAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityDeleteServiceAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityDeleteServiceAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityDeleteServiceAccountRequest) Accept(accept string) ApiIdentityDeleteServiceAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityDeleteServiceAccountRequest) CitrixLocale(citrixLocale string) ApiIdentityDeleteServiceAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentityDeleteServiceAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.IdentityDeleteServiceAccountExecute(r)
}

/*
IdentityDeleteServiceAccount Delete an existing service account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceAccountUid The ServiceAccountUid of an existing service account. 
 @return ApiIdentityDeleteServiceAccountRequest
*/
func (a *IdentityAPIsDAASService) IdentityDeleteServiceAccount(ctx context.Context, serviceAccountUid string) ApiIdentityDeleteServiceAccountRequest {
	return ApiIdentityDeleteServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		serviceAccountUid: serviceAccountUid,
	}
}

// Execute executes the request
func (a *IdentityAPIsDAASService) IdentityDeleteServiceAccountExecute(r ApiIdentityDeleteServiceAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityDeleteServiceAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/ServiceAccount/{serviceAccountUid}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceAccountUid"+"}", url.PathEscape(parameterValueToString(r.serviceAccountUid, "serviceAccountUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGetAzureADSecurityGroupsRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	azureAdTenantId string
	groupId string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAccessToken *string
	accept *string
	citrixLocale *string
	serviceAccountUid *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetAzureADSecurityGroupsRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetAzureADSecurityGroupsRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetAzureADSecurityGroupsRequest) UserAgent(userAgent string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetAzureADSecurityGroupsRequest) Authorization(authorization string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetAzureADSecurityGroupsRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiIdentityGetAzureADSecurityGroupsRequest) XAccessToken(xAccessToken string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Must accept application/json.
func (r ApiIdentityGetAzureADSecurityGroupsRequest) Accept(accept string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetAzureADSecurityGroupsRequest) CitrixLocale(citrixLocale string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Service account objectId
func (r ApiIdentityGetAzureADSecurityGroupsRequest) ServiceAccountUid(serviceAccountUid string) ApiIdentityGetAzureADSecurityGroupsRequest {
	r.serviceAccountUid = &serviceAccountUid
	return r
}

func (r ApiIdentityGetAzureADSecurityGroupsRequest) Execute() (*AzureADSecurityGroupResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetAzureADSecurityGroupsExecute(r)
}

/*
IdentityGetAzureADSecurityGroups Get Azure AD security group by group id.

Retrieves AzureAD's security groups by user's input.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param azureAdTenantId AzureAD tenantId
 @param groupId AzureAD security group's objectId
 @return ApiIdentityGetAzureADSecurityGroupsRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetAzureADSecurityGroups(ctx context.Context, azureAdTenantId string, groupId string) ApiIdentityGetAzureADSecurityGroupsRequest {
	return ApiIdentityGetAzureADSecurityGroupsRequest{
		ApiService: a,
		ctx: ctx,
		azureAdTenantId: azureAdTenantId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AzureADSecurityGroupResponseModel
func (a *IdentityAPIsDAASService) IdentityGetAzureADSecurityGroupsExecute(r ApiIdentityGetAzureADSecurityGroupsRequest) (*AzureADSecurityGroupResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AzureADSecurityGroupResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetAzureADSecurityGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/AzureADTenants/{azureAdTenantId}/AzureADSecurityGroups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"azureAdTenantId"+"}", url.PathEscape(parameterValueToString(r.azureAdTenantId, "azureAdTenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.serviceAccountUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceAccountUid", r.serviceAccountUid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetAzureAdSecurityGroupMemberRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	azureAdTenantId string
	groupId string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAccessToken *string
	accept *string
	citrixLocale *string
	type_ *string
	maxCount *int32
	serviceAccountUid *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) UserAgent(userAgent string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) Authorization(authorization string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) XAccessToken(xAccessToken string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Must accept application/json.
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) Accept(accept string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) CitrixLocale(citrixLocale string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Only type&#x3D;group is support now.
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) Type_(type_ string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.type_ = &type_
	return r
}

// The max return records number.
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) MaxCount(maxCount int32) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.maxCount = &maxCount
	return r
}

// The service account uid.
func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) ServiceAccountUid(serviceAccountUid string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	r.serviceAccountUid = &serviceAccountUid
	return r
}

func (r ApiIdentityGetAzureAdSecurityGroupMemberRequest) Execute() (*AzureADSecurityGroupResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetAzureAdSecurityGroupMemberExecute(r)
}

/*
IdentityGetAzureAdSecurityGroupMember Retrieves all the group type of members of a specific group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param azureAdTenantId The Azure tenant id.
 @param groupId The security group object id.
 @return ApiIdentityGetAzureAdSecurityGroupMemberRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetAzureAdSecurityGroupMember(ctx context.Context, azureAdTenantId string, groupId string) ApiIdentityGetAzureAdSecurityGroupMemberRequest {
	return ApiIdentityGetAzureAdSecurityGroupMemberRequest{
		ApiService: a,
		ctx: ctx,
		azureAdTenantId: azureAdTenantId,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AzureADSecurityGroupResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetAzureAdSecurityGroupMemberExecute(r ApiIdentityGetAzureAdSecurityGroupMemberRequest) (*AzureADSecurityGroupResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AzureADSecurityGroupResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetAzureAdSecurityGroupMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/AzureADTenants/{azureAdTenantId}/AzureADSecurityGroups/{groupId}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"azureAdTenantId"+"}", url.PathEscape(parameterValueToString(r.azureAdTenantId, "azureAdTenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.serviceAccountUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceAccountUid", r.serviceAccountUid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetContainerRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	container string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *string
	directoryServerHint *string
	propertiesToRetrieve *int32
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetContainerRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetContainerRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetContainerRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetContainerRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetContainerRequest) UserAgent(userAgent string) ApiIdentityGetContainerRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetContainerRequest) Authorization(authorization string) ApiIdentityGetContainerRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetContainerRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetContainerRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetContainerRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetContainerRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetContainerRequest) Accept(accept string) ApiIdentityGetContainerRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetContainerRequest) CitrixLocale(citrixLocale string) ApiIdentityGetContainerRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get container from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetContainerRequest) Forest(forest string) ApiIdentityGetContainerRequest {
	r.forest = &forest
	return r
}

// Domain to get container from.  If not specified, all domains in the forest(s) are queried, which may take a long time.
func (r ApiIdentityGetContainerRequest) Domain(domain string) ApiIdentityGetContainerRequest {
	r.domain = &domain
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityGetContainerRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityGetContainerRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties will be retrieved.
func (r ApiIdentityGetContainerRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetContainerRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

func (r ApiIdentityGetContainerRequest) Execute() (*IdentityContainerResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetContainerExecute(r)
}

/*
IdentityGetContainer Get a single container (e.g. OU)

Get a single container (e.g. OU).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param container Container to get.
 @return ApiIdentityGetContainerRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetContainer(ctx context.Context, container string) ApiIdentityGetContainerRequest {
	return ApiIdentityGetContainerRequest{
		ApiService: a,
		ctx: ctx,
		container: container,
	}
}

// Execute executes the request
//  @return IdentityContainerResponseModel
func (a *IdentityAPIsDAASService) IdentityGetContainerExecute(r ApiIdentityGetContainerRequest) (*IdentityContainerResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityContainerResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Containers/{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetContainersRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *string
	container *[]string
	startsWith *string
	contains *string
	matches *string
	parentOU *string
	recursive *bool
	containerType *[]IdentityContainerType
	directoryServerHint *string
	propertiesToRetrieve *int32
	limit *int32
	continuationToken *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetContainersRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetContainersRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetContainersRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetContainersRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetContainersRequest) UserAgent(userAgent string) ApiIdentityGetContainersRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetContainersRequest) Authorization(authorization string) ApiIdentityGetContainersRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetContainersRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetContainersRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetContainersRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetContainersRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetContainersRequest) Accept(accept string) ApiIdentityGetContainersRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetContainersRequest) CitrixLocale(citrixLocale string) ApiIdentityGetContainersRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get containers from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetContainersRequest) Forest(forest string) ApiIdentityGetContainersRequest {
	r.forest = &forest
	return r
}

// Domain to get containers from.  If not specified, all domains in the forest(s) are queried, which may take a long time.
func (r ApiIdentityGetContainersRequest) Domain(domain string) ApiIdentityGetContainersRequest {
	r.domain = &domain
	return r
}

// Specific container(s) to filter the results to.  If not specified, all matching containers are returned.  If set, &#x60;recursive&#x60; parameter is ignored and is implied &#x60;true&#x60;.
func (r ApiIdentityGetContainersRequest) Container(container []string) ApiIdentityGetContainersRequest {
	r.container = &container
	return r
}

// Search for containers that start with a string.  If not specified, all matching containers are returned.
func (r ApiIdentityGetContainersRequest) StartsWith(startsWith string) ApiIdentityGetContainersRequest {
	r.startsWith = &startsWith
	return r
}

// Search for containers that contain a string.  If not specified, all matching containers are returned.
func (r ApiIdentityGetContainersRequest) Contains(contains string) ApiIdentityGetContainersRequest {
	r.contains = &contains
	return r
}

// Search for containers that match a string.  If not specified, all matching containers are returned.
func (r ApiIdentityGetContainersRequest) Matches(matches string) ApiIdentityGetContainersRequest {
	r.matches = &matches
	return r
}

// The parent OU to search.  If not specified, will search from the root OU.
func (r ApiIdentityGetContainersRequest) ParentOU(parentOU string) ApiIdentityGetContainersRequest {
	r.parentOU = &parentOU
	return r
}

// Indicates whether the search should be recursive.  Default is &#x60;false&#x60;.
func (r ApiIdentityGetContainersRequest) Recursive(recursive bool) ApiIdentityGetContainersRequest {
	r.recursive = &recursive
	return r
}

// Indicates container type(s) that should be retrieved.  If not specified, all container types will be searched.
func (r ApiIdentityGetContainersRequest) ContainerType(containerType []IdentityContainerType) ApiIdentityGetContainersRequest {
	r.containerType = &containerType
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityGetContainersRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityGetContainersRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties will be retrieved.
func (r ApiIdentityGetContainersRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetContainersRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

// Maximum number of items to return.  If more items are available, a continuation token will be returned.  If not specified, all items will be returned.
func (r ApiIdentityGetContainersRequest) Limit(limit int32) ApiIdentityGetContainersRequest {
	r.limit = &limit
	return r
}

// If specified, a previous query will be continued.  The caller must specify the same query parameters and admin credentials as the initial query or else the behavior is undefined.
func (r ApiIdentityGetContainersRequest) ContinuationToken(continuationToken string) ApiIdentityGetContainersRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiIdentityGetContainersRequest) Execute() (*IdentityContainerResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetContainersExecute(r)
}

/*
IdentityGetContainers Get containers from identity provider.

Get containers from identity provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetContainersRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetContainers(ctx context.Context) ApiIdentityGetContainersRequest {
	return ApiIdentityGetContainersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityContainerResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetContainersExecute(r ApiIdentityGetContainersRequest) (*IdentityContainerResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityContainerResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Containers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.container != nil {
		t := *r.container
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "container", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "container", t, "multi")
		}
	}
	if r.startsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startsWith", r.startsWith, "")
	}
	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.matches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matches", r.matches, "")
	}
	if r.parentOU != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentOU", r.parentOU, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "")
	}
	if r.containerType != nil {
		t := *r.containerType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "containerType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "containerType", t, "multi")
		}
	}
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetDirectoriesRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
	limit *int32
	continuationToken *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetDirectoriesRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetDirectoriesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetDirectoriesRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetDirectoriesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetDirectoriesRequest) UserAgent(userAgent string) ApiIdentityGetDirectoriesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetDirectoriesRequest) Authorization(authorization string) ApiIdentityGetDirectoriesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetDirectoriesRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetDirectoriesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityGetDirectoriesRequest) Accept(accept string) ApiIdentityGetDirectoriesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetDirectoriesRequest) CitrixLocale(citrixLocale string) ApiIdentityGetDirectoriesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of items returned by this query.
func (r ApiIdentityGetDirectoriesRequest) Limit(limit int32) ApiIdentityGetDirectoriesRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiIdentityGetDirectoriesRequest) ContinuationToken(continuationToken string) ApiIdentityGetDirectoriesRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiIdentityGetDirectoriesRequest) Execute() (*IdentityDirectoryResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetDirectoriesExecute(r)
}

/*
IdentityGetDirectories Get list of directories from all identity providers

Get list of directories from all identity providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetDirectoriesRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetDirectories(ctx context.Context) ApiIdentityGetDirectoriesRequest {
	return ApiIdentityGetDirectoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityDirectoryResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetDirectoriesExecute(r ApiIdentityGetDirectoriesRequest) (*IdentityDirectoryResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityDirectoryResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetDirectories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Directories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetDomainRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	domain string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	directoryServerHint *string
	propertiesToRetrieve *int32
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetDomainRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetDomainRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetDomainRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetDomainRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetDomainRequest) UserAgent(userAgent string) ApiIdentityGetDomainRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetDomainRequest) Authorization(authorization string) ApiIdentityGetDomainRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetDomainRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetDomainRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetDomainRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetDomainRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetDomainRequest) Accept(accept string) ApiIdentityGetDomainRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetDomainRequest) CitrixLocale(citrixLocale string) ApiIdentityGetDomainRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get domain from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetDomainRequest) Forest(forest string) ApiIdentityGetDomainRequest {
	r.forest = &forest
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityGetDomainRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityGetDomainRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties. If not specified, all properties other than IdentityDomainProperty.Controllers IdentityDomainProperty.PrimaryController will be retrieved.
func (r ApiIdentityGetDomainRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetDomainRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

func (r ApiIdentityGetDomainRequest) Execute() (*IdentityDomainResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetDomainExecute(r)
}

/*
IdentityGetDomain Get a single domain from the identity provider

Get a single domain from the identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domain Domain to get details from.
 @return ApiIdentityGetDomainRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetDomain(ctx context.Context, domain string) ApiIdentityGetDomainRequest {
	return ApiIdentityGetDomainRequest{
		ApiService: a,
		ctx: ctx,
		domain: domain,
	}
}

// Execute executes the request
//  @return IdentityDomainResponseModel
func (a *IdentityAPIsDAASService) IdentityGetDomainExecute(r ApiIdentityGetDomainRequest) (*IdentityDomainResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityDomainResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Domains/{domain}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(parameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetDomainAzureADCustomDomainRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	domain string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetDomainAzureADCustomDomainRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetDomainAzureADCustomDomainRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetDomainAzureADCustomDomainRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetDomainAzureADCustomDomainRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetDomainAzureADCustomDomainRequest) UserAgent(userAgent string) ApiIdentityGetDomainAzureADCustomDomainRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetDomainAzureADCustomDomainRequest) Authorization(authorization string) ApiIdentityGetDomainAzureADCustomDomainRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetDomainAzureADCustomDomainRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetDomainAzureADCustomDomainRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityGetDomainAzureADCustomDomainRequest) Accept(accept string) ApiIdentityGetDomainAzureADCustomDomainRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetDomainAzureADCustomDomainRequest) CitrixLocale(citrixLocale string) ApiIdentityGetDomainAzureADCustomDomainRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentityGetDomainAzureADCustomDomainRequest) Execute() (*AzureADCustomDomainResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetDomainAzureADCustomDomainExecute(r)
}

/*
IdentityGetDomainAzureADCustomDomain Gets the Azure AD custom domain with the specified domain name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domain Domain name.
 @return ApiIdentityGetDomainAzureADCustomDomainRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetDomainAzureADCustomDomain(ctx context.Context, domain string) ApiIdentityGetDomainAzureADCustomDomainRequest {
	return ApiIdentityGetDomainAzureADCustomDomainRequest{
		ApiService: a,
		ctx: ctx,
		domain: domain,
	}
}

// Execute executes the request
//  @return AzureADCustomDomainResponseModel
func (a *IdentityAPIsDAASService) IdentityGetDomainAzureADCustomDomainExecute(r ApiIdentityGetDomainAzureADCustomDomainRequest) (*AzureADCustomDomainResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AzureADCustomDomainResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetDomainAzureADCustomDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Domains/{domain}/AzureADCustomDomain"
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(parameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetDomainsRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *[]string
	directoryServerHint *string
	parentDomain *string
	recursive *bool
	propertiesToRetrieve *int32
	limit *int32
	continuationToken *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetDomainsRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetDomainsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetDomainsRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetDomainsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetDomainsRequest) UserAgent(userAgent string) ApiIdentityGetDomainsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetDomainsRequest) Authorization(authorization string) ApiIdentityGetDomainsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetDomainsRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetDomainsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetDomainsRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetDomainsRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetDomainsRequest) Accept(accept string) ApiIdentityGetDomainsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetDomainsRequest) CitrixLocale(citrixLocale string) ApiIdentityGetDomainsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get domains from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetDomainsRequest) Forest(forest string) ApiIdentityGetDomainsRequest {
	r.forest = &forest
	return r
}

// Specific domain(s) to filter the results to.  If not specified, all matching domains are returned.
func (r ApiIdentityGetDomainsRequest) Domain(domain []string) ApiIdentityGetDomainsRequest {
	r.domain = &domain
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityGetDomainsRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityGetDomainsRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// Parent domain name to search.  Default is the root domain of the forest.
func (r ApiIdentityGetDomainsRequest) ParentDomain(parentDomain string) ApiIdentityGetDomainsRequest {
	r.parentDomain = &parentDomain
	return r
}

// Specifies whether the search is recursive.
func (r ApiIdentityGetDomainsRequest) Recursive(recursive bool) ApiIdentityGetDomainsRequest {
	r.recursive = &recursive
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties. If not specified, all properties other than IdentityDomainProperty.Controllers IdentityDomainProperty.PrimaryController will be retrieved.
func (r ApiIdentityGetDomainsRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetDomainsRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

// Maximum number of items to return.  If more items are available, a continuation token will be returned.  If not specified, all items will be returned.
func (r ApiIdentityGetDomainsRequest) Limit(limit int32) ApiIdentityGetDomainsRequest {
	r.limit = &limit
	return r
}

// If specified, a previous query will be continued.  The caller must specify the same query parameters and admin credentials as the initial query or else the behavior is undefined.
func (r ApiIdentityGetDomainsRequest) ContinuationToken(continuationToken string) ApiIdentityGetDomainsRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiIdentityGetDomainsRequest) Async(async bool) ApiIdentityGetDomainsRequest {
	r.async = &async
	return r
}

func (r ApiIdentityGetDomainsRequest) Execute() (*IdentityDomainResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetDomainsExecute(r)
}

/*
IdentityGetDomains Get list of domains from the identity provider

Get list of domains from the identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetDomainsRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetDomains(ctx context.Context) ApiIdentityGetDomainsRequest {
	return ApiIdentityGetDomainsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityDomainResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetDomainsExecute(r ApiIdentityGetDomainsRequest) (*IdentityDomainResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityDomainResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetDomains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		t := *r.domain
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain", t, "multi")
		}
	}
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.parentDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentDomain", r.parentDomain, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetForestRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	forest string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	propertiesToRetrieve *int32
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetForestRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetForestRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetForestRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetForestRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetForestRequest) UserAgent(userAgent string) ApiIdentityGetForestRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetForestRequest) Authorization(authorization string) ApiIdentityGetForestRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetForestRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetForestRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetForestRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetForestRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetForestRequest) Accept(accept string) ApiIdentityGetForestRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetForestRequest) CitrixLocale(citrixLocale string) ApiIdentityGetForestRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties will be retrieved.
func (r ApiIdentityGetForestRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetForestRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

func (r ApiIdentityGetForestRequest) Execute() (*IdentityForestResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetForestExecute(r)
}

/*
IdentityGetForest Get information about a single forest

Get information about a single forest.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param forest forest
 @return ApiIdentityGetForestRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetForest(ctx context.Context, forest string) ApiIdentityGetForestRequest {
	return ApiIdentityGetForestRequest{
		ApiService: a,
		ctx: ctx,
		forest: forest,
	}
}

// Execute executes the request
//  @return IdentityForestResponseModel
func (a *IdentityAPIsDAASService) IdentityGetForestExecute(r ApiIdentityGetForestRequest) (*IdentityForestResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityForestResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetForest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Forests/{forest}"
	localVarPath = strings.Replace(localVarPath, "{"+"forest"+"}", url.PathEscape(parameterValueToString(r.forest, "forest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetForestsRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *[]string
	propertiesToRetrieve *int32
	limit *int32
	continuationToken *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetForestsRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetForestsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetForestsRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetForestsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetForestsRequest) UserAgent(userAgent string) ApiIdentityGetForestsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetForestsRequest) Authorization(authorization string) ApiIdentityGetForestsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetForestsRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetForestsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetForestsRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetForestsRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetForestsRequest) Accept(accept string) ApiIdentityGetForestsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetForestsRequest) CitrixLocale(citrixLocale string) ApiIdentityGetForestsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Specific forest(s) to filter the results to.  If not specified, all forests are returned.
func (r ApiIdentityGetForestsRequest) Forest(forest []string) ApiIdentityGetForestsRequest {
	r.forest = &forest
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties will be retrieved.
func (r ApiIdentityGetForestsRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetForestsRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

// Maximum number of items to return.  If more items are available, a continuation token will be returned.  If not specified, all items will be returned.
func (r ApiIdentityGetForestsRequest) Limit(limit int32) ApiIdentityGetForestsRequest {
	r.limit = &limit
	return r
}

// If specified, a previous query will be continued.  The caller must specify the same query parameters and admin credentials as the initial query or else the behavior is undefined.
func (r ApiIdentityGetForestsRequest) ContinuationToken(continuationToken string) ApiIdentityGetForestsRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiIdentityGetForestsRequest) Execute() (*IdentityForestResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetForestsExecute(r)
}

/*
IdentityGetForests Get the list of forests from the identity provider

Get the list of forests from the identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetForestsRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetForests(ctx context.Context) ApiIdentityGetForestsRequest {
	return ApiIdentityGetForestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityForestResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetForestsExecute(r ApiIdentityGetForestsRequest) (*IdentityForestResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityForestResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetForests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Forests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		t := *r.forest
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "forest", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "forest", t, "multi")
		}
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetMachineRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	machine string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *string
	directoryServerHint *string
	propertiesToRetrieve *int32
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetMachineRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetMachineRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetMachineRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetMachineRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetMachineRequest) UserAgent(userAgent string) ApiIdentityGetMachineRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetMachineRequest) Authorization(authorization string) ApiIdentityGetMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetMachineRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetMachineRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetMachineRequest) Accept(accept string) ApiIdentityGetMachineRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetMachineRequest) CitrixLocale(citrixLocale string) ApiIdentityGetMachineRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get machine account from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetMachineRequest) Forest(forest string) ApiIdentityGetMachineRequest {
	r.forest = &forest
	return r
}

// Domain to get machine account from.  If not specified, all domains in the forest(s) are queried, which may take a long time.
func (r ApiIdentityGetMachineRequest) Domain(domain string) ApiIdentityGetMachineRequest {
	r.domain = &domain
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityGetMachineRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityGetMachineRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties other than IPAddress will be retrieved.
func (r ApiIdentityGetMachineRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetMachineRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

func (r ApiIdentityGetMachineRequest) Execute() (*IdentityMachineResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetMachineExecute(r)
}

/*
IdentityGetMachine Get a single machine account from identity provider

Get a single machine account from identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param machine Machine to get.
 @return ApiIdentityGetMachineRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetMachine(ctx context.Context, machine string) ApiIdentityGetMachineRequest {
	return ApiIdentityGetMachineRequest{
		ApiService: a,
		ctx: ctx,
		machine: machine,
	}
}

// Execute executes the request
//  @return IdentityMachineResponseModel
func (a *IdentityAPIsDAASService) IdentityGetMachineExecute(r ApiIdentityGetMachineRequest) (*IdentityMachineResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityMachineResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Machines/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetMachinesRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *string
	machine *[]string
	startsWith *string
	contains *string
	matches *string
	parentOU *string
	recursive *bool
	directoryServerHint *string
	propertiesToRetrieve *int32
	limit *int32
	continuationToken *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetMachinesRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetMachinesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetMachinesRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetMachinesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetMachinesRequest) UserAgent(userAgent string) ApiIdentityGetMachinesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetMachinesRequest) Authorization(authorization string) ApiIdentityGetMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetMachinesRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetMachinesRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetMachinesRequest) Accept(accept string) ApiIdentityGetMachinesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetMachinesRequest) CitrixLocale(citrixLocale string) ApiIdentityGetMachinesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get machine accounts from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetMachinesRequest) Forest(forest string) ApiIdentityGetMachinesRequest {
	r.forest = &forest
	return r
}

// Domain to get machine accounts from.  If not specified, all domains in the forest(s) are queried, which may take a long time.
func (r ApiIdentityGetMachinesRequest) Domain(domain string) ApiIdentityGetMachinesRequest {
	r.domain = &domain
	return r
}

// Specific machine(s) to filter the results to.  If not specified, all matching machines are returned.  If set, &#x60;recursive&#x60; parameter is ignored and is implied &#x60;true&#x60;.
func (r ApiIdentityGetMachinesRequest) Machine(machine []string) ApiIdentityGetMachinesRequest {
	r.machine = &machine
	return r
}

// Search for machine accounts that start with a string.  This parameter is exclusive with &#x60;contains&#x60;, and &#x60;matches&#x60;.
func (r ApiIdentityGetMachinesRequest) StartsWith(startsWith string) ApiIdentityGetMachinesRequest {
	r.startsWith = &startsWith
	return r
}

// Search for machine accounts that contain a string.  This parameter is exclusive with &#x60;startsWith&#x60;, and &#x60;matches&#x60;.
func (r ApiIdentityGetMachinesRequest) Contains(contains string) ApiIdentityGetMachinesRequest {
	r.contains = &contains
	return r
}

// Search for machine accounts that match a string.  This parameter is exclusive with &#x60;startsWith&#x60;, and &#x60;contains&#x60;.
func (r ApiIdentityGetMachinesRequest) Matches(matches string) ApiIdentityGetMachinesRequest {
	r.matches = &matches
	return r
}

// The parent OU to search.  If not specified, will search from the root OU.
func (r ApiIdentityGetMachinesRequest) ParentOU(parentOU string) ApiIdentityGetMachinesRequest {
	r.parentOU = &parentOU
	return r
}

// Indicates whether the search should be recursive.
func (r ApiIdentityGetMachinesRequest) Recursive(recursive bool) ApiIdentityGetMachinesRequest {
	r.recursive = &recursive
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityGetMachinesRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityGetMachinesRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties other than IPAddress will be retrieved.
func (r ApiIdentityGetMachinesRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetMachinesRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

// Maximum number of items to return.  If more items are available, a continuation token will be returned.  If not specified, all items will be returned.
func (r ApiIdentityGetMachinesRequest) Limit(limit int32) ApiIdentityGetMachinesRequest {
	r.limit = &limit
	return r
}

// If specified, a previous query will be continued.  The caller must specify the same query parameters and admin credentials as the initial query or else the behavior is undefined.
func (r ApiIdentityGetMachinesRequest) ContinuationToken(continuationToken string) ApiIdentityGetMachinesRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiIdentityGetMachinesRequest) Execute() (*IdentityMachineResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetMachinesExecute(r)
}

/*
IdentityGetMachines Get machine accounts from identity provider

Get machine accounts from identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetMachinesRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetMachines(ctx context.Context) ApiIdentityGetMachinesRequest {
	return ApiIdentityGetMachinesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityMachineResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetMachinesExecute(r ApiIdentityGetMachinesRequest) (*IdentityMachineResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityMachineResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetMachines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Machines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.machine != nil {
		t := *r.machine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "machine", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "machine", t, "multi")
		}
	}
	if r.startsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startsWith", r.startsWith, "")
	}
	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.matches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matches", r.matches, "")
	}
	if r.parentOU != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentOU", r.parentOU, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "")
	}
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetPrintersRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *string
	server *string
	uncpath *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetPrintersRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetPrintersRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetPrintersRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetPrintersRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetPrintersRequest) UserAgent(userAgent string) ApiIdentityGetPrintersRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetPrintersRequest) Authorization(authorization string) ApiIdentityGetPrintersRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetPrintersRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetPrintersRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetPrintersRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetPrintersRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetPrintersRequest) Accept(accept string) ApiIdentityGetPrintersRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetPrintersRequest) CitrixLocale(citrixLocale string) ApiIdentityGetPrintersRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get printers from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetPrintersRequest) Forest(forest string) ApiIdentityGetPrintersRequest {
	r.forest = &forest
	return r
}

// Domain to get printers from.  If not specified, all domains in the forest(s) are queried, which may take a long time.
func (r ApiIdentityGetPrintersRequest) Domain(domain string) ApiIdentityGetPrintersRequest {
	r.domain = &domain
	return r
}

// Printer server name
func (r ApiIdentityGetPrintersRequest) Server(server string) ApiIdentityGetPrintersRequest {
	r.server = &server
	return r
}

// Printer UNC path
func (r ApiIdentityGetPrintersRequest) Uncpath(uncpath string) ApiIdentityGetPrintersRequest {
	r.uncpath = &uncpath
	return r
}

// If &#x60;true&#x60;, the get printers will be executed as a background task. The task will have JobType GetPrintersIdentity. When the task is complete it will redirect to GetJobResults.
func (r ApiIdentityGetPrintersRequest) Async(async bool) ApiIdentityGetPrintersRequest {
	r.async = &async
	return r
}

func (r ApiIdentityGetPrintersRequest) Execute() (*IdentityPrinterResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetPrintersExecute(r)
}

/*
IdentityGetPrinters Get network printers from identity provider

Get network printers from identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetPrintersRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetPrinters(ctx context.Context) ApiIdentityGetPrintersRequest {
	return ApiIdentityGetPrintersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityPrinterResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetPrintersExecute(r ApiIdentityGetPrintersRequest) (*IdentityPrinterResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityPrinterResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetPrinters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Printers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.server != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server", r.server, "")
	}
	if r.uncpath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uncpath", r.uncpath, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetServiceAccountRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	serviceAccountUid string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetServiceAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetServiceAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetServiceAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetServiceAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetServiceAccountRequest) UserAgent(userAgent string) ApiIdentityGetServiceAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetServiceAccountRequest) Authorization(authorization string) ApiIdentityGetServiceAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetServiceAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetServiceAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityGetServiceAccountRequest) Accept(accept string) ApiIdentityGetServiceAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetServiceAccountRequest) CitrixLocale(citrixLocale string) ApiIdentityGetServiceAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentityGetServiceAccountRequest) Execute() (*ServiceAccountResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetServiceAccountExecute(r)
}

/*
IdentityGetServiceAccount Get a specific service account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceAccountUid The ServiceAccountUid of a specific service account. 
 @return ApiIdentityGetServiceAccountRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetServiceAccount(ctx context.Context, serviceAccountUid string) ApiIdentityGetServiceAccountRequest {
	return ApiIdentityGetServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		serviceAccountUid: serviceAccountUid,
	}
}

// Execute executes the request
//  @return ServiceAccountResponseModel
func (a *IdentityAPIsDAASService) IdentityGetServiceAccountExecute(r ApiIdentityGetServiceAccountRequest) (*ServiceAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/ServiceAccount/{serviceAccountUid}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceAccountUid"+"}", url.PathEscape(parameterValueToString(r.serviceAccountUid, "serviceAccountUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	serviceAccountUid string
	updateServiceAccountCapabilityPreviewRequestModel *UpdateServiceAccountCapabilityPreviewRequestModel
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Update serivce account capability preview request model.
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) UpdateServiceAccountCapabilityPreviewRequestModel(updateServiceAccountCapabilityPreviewRequestModel UpdateServiceAccountCapabilityPreviewRequestModel) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.updateServiceAccountCapabilityPreviewRequestModel = &updateServiceAccountCapabilityPreviewRequestModel
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) UserAgent(userAgent string) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) Authorization(authorization string) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) Accept(accept string) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) CitrixLocale(citrixLocale string) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the get preview patch will run as a background task. This is recommended as the gets may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType GetPatchPreviewServiceAccount. When the task is complete it will redirect to GetJobResults. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the service account being update.
func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) Async(async bool) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	r.async = &async
	return r
}

func (r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) Execute() (*UpdateServiceAccountCapabilityPreviewResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetServiceAccountCapabilityPatchPreviewExecute(r)
}

/*
IdentityGetServiceAccountCapabilityPatchPreview Get the service account capability patch preview.

Get the service account capability patch preview before updating the service account.
SetServiceAccount.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceAccountUid ID of the service account to test.
 @return ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetServiceAccountCapabilityPatchPreview(ctx context.Context, serviceAccountUid string) ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest {
	return ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest{
		ApiService: a,
		ctx: ctx,
		serviceAccountUid: serviceAccountUid,
	}
}

// Execute executes the request
//  @return UpdateServiceAccountCapabilityPreviewResponseModel
func (a *IdentityAPIsDAASService) IdentityGetServiceAccountCapabilityPatchPreviewExecute(r ApiIdentityGetServiceAccountCapabilityPatchPreviewRequest) (*UpdateServiceAccountCapabilityPreviewResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateServiceAccountCapabilityPreviewResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetServiceAccountCapabilityPatchPreview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/serviceAccount/{serviceAccountUid}/$getPatchPreview"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceAccountUid"+"}", url.PathEscape(parameterValueToString(r.serviceAccountUid, "serviceAccountUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.updateServiceAccountCapabilityPreviewRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateServiceAccountCapabilityPreviewRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.updateServiceAccountCapabilityPreviewRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetServiceAccountTestReportRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	serviceAccountUid string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetServiceAccountTestReportRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetServiceAccountTestReportRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetServiceAccountTestReportRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetServiceAccountTestReportRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetServiceAccountTestReportRequest) UserAgent(userAgent string) ApiIdentityGetServiceAccountTestReportRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetServiceAccountTestReportRequest) Authorization(authorization string) ApiIdentityGetServiceAccountTestReportRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetServiceAccountTestReportRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetServiceAccountTestReportRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityGetServiceAccountTestReportRequest) Accept(accept string) ApiIdentityGetServiceAccountTestReportRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetServiceAccountTestReportRequest) CitrixLocale(citrixLocale string) ApiIdentityGetServiceAccountTestReportRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentityGetServiceAccountTestReportRequest) Execute() (*TestReportResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetServiceAccountTestReportExecute(r)
}

/*
IdentityGetServiceAccountTestReport Get the most recent test report for a service account.

Get the test report from the last run of
TestServiceAccount.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceAccountUid ID of the service account.
 @return ApiIdentityGetServiceAccountTestReportRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetServiceAccountTestReport(ctx context.Context, serviceAccountUid string) ApiIdentityGetServiceAccountTestReportRequest {
	return ApiIdentityGetServiceAccountTestReportRequest{
		ApiService: a,
		ctx: ctx,
		serviceAccountUid: serviceAccountUid,
	}
}

// Execute executes the request
//  @return TestReportResponseModel
func (a *IdentityAPIsDAASService) IdentityGetServiceAccountTestReportExecute(r ApiIdentityGetServiceAccountTestReportRequest) (*TestReportResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TestReportResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetServiceAccountTestReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/serviceAccount/{serviceAccountUid}/testReport"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceAccountUid"+"}", url.PathEscape(parameterValueToString(r.serviceAccountUid, "serviceAccountUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetServiceAccountsRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetServiceAccountsRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetServiceAccountsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetServiceAccountsRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetServiceAccountsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetServiceAccountsRequest) UserAgent(userAgent string) ApiIdentityGetServiceAccountsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetServiceAccountsRequest) Authorization(authorization string) ApiIdentityGetServiceAccountsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetServiceAccountsRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetServiceAccountsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityGetServiceAccountsRequest) Accept(accept string) ApiIdentityGetServiceAccountsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetServiceAccountsRequest) CitrixLocale(citrixLocale string) ApiIdentityGetServiceAccountsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentityGetServiceAccountsRequest) Async(async bool) ApiIdentityGetServiceAccountsRequest {
	r.async = &async
	return r
}

func (r ApiIdentityGetServiceAccountsRequest) Execute() (*ServiceAccountResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetServiceAccountsExecute(r)
}

/*
IdentityGetServiceAccounts Get all service accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetServiceAccountsRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetServiceAccounts(ctx context.Context) ApiIdentityGetServiceAccountsRequest {
	return ApiIdentityGetServiceAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceAccountResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetServiceAccountsExecute(r ApiIdentityGetServiceAccountsRequest) (*ServiceAccountResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceAccountResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetServiceAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/ServiceAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetSiteRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	site string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *string
	propertiesToRetrieve *int32
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetSiteRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetSiteRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetSiteRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetSiteRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetSiteRequest) UserAgent(userAgent string) ApiIdentityGetSiteRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetSiteRequest) Authorization(authorization string) ApiIdentityGetSiteRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetSiteRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetSiteRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetSiteRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetSiteRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetSiteRequest) Accept(accept string) ApiIdentityGetSiteRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetSiteRequest) CitrixLocale(citrixLocale string) ApiIdentityGetSiteRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get the site from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetSiteRequest) Forest(forest string) ApiIdentityGetSiteRequest {
	r.forest = &forest
	return r
}

// Domain to get the site from.  If not specified, all domains in the forest(s) are queried until the site is found.
func (r ApiIdentityGetSiteRequest) Domain(domain string) ApiIdentityGetSiteRequest {
	r.domain = &domain
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties will be retrieved.
func (r ApiIdentityGetSiteRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetSiteRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

func (r ApiIdentityGetSiteRequest) Execute() (*IdentitySiteResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetSiteExecute(r)
}

/*
IdentityGetSite Get information about a single site

Get information about a single site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param site The site to get details for.
 @return ApiIdentityGetSiteRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetSite(ctx context.Context, site string) ApiIdentityGetSiteRequest {
	return ApiIdentityGetSiteRequest{
		ApiService: a,
		ctx: ctx,
		site: site,
	}
}

// Execute executes the request
//  @return IdentitySiteResponseModel
func (a *IdentityAPIsDAASService) IdentityGetSiteExecute(r ApiIdentityGetSiteRequest) (*IdentitySiteResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentitySiteResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetSite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Sites/{site}"
	localVarPath = strings.Replace(localVarPath, "{"+"site"+"}", url.PathEscape(parameterValueToString(r.site, "site")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetSitesRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *string
	hostNameOrIP *string
	site *[]string
	propertiesToRetrieve *int32
	limit *int32
	continuationToken *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetSitesRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetSitesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetSitesRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetSitesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetSitesRequest) UserAgent(userAgent string) ApiIdentityGetSitesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetSitesRequest) Authorization(authorization string) ApiIdentityGetSitesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetSitesRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetSitesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetSitesRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetSitesRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetSitesRequest) Accept(accept string) ApiIdentityGetSitesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetSitesRequest) CitrixLocale(citrixLocale string) ApiIdentityGetSitesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get sites from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetSitesRequest) Forest(forest string) ApiIdentityGetSitesRequest {
	r.forest = &forest
	return r
}

// Domain to get sites from.  If not specified, all domains in the forest(s) are queried.
func (r ApiIdentityGetSitesRequest) Domain(domain string) ApiIdentityGetSitesRequest {
	r.domain = &domain
	return r
}

// Hostname or IP to get sites from.
func (r ApiIdentityGetSitesRequest) HostNameOrIP(hostNameOrIP string) ApiIdentityGetSitesRequest {
	r.hostNameOrIP = &hostNameOrIP
	return r
}

// Specific site(s) to filter the results to.  If not specified, all matching sites are returned.
func (r ApiIdentityGetSitesRequest) Site(site []string) ApiIdentityGetSitesRequest {
	r.site = &site
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties will be retrieved.
func (r ApiIdentityGetSitesRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetSitesRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

// Maximum number of items to return.  If more items are available, a continuation token will be returned.  If not specified, all items will be returned.
func (r ApiIdentityGetSitesRequest) Limit(limit int32) ApiIdentityGetSitesRequest {
	r.limit = &limit
	return r
}

// If specified, a previous query will be continued.  The caller must specify the same query parameters and admin credentials as the initial query or else the behavior is undefined.
func (r ApiIdentityGetSitesRequest) ContinuationToken(continuationToken string) ApiIdentityGetSitesRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiIdentityGetSitesRequest) Execute() (*IdentitySiteResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetSitesExecute(r)
}

/*
IdentityGetSites Get list of sites from the identity provider

Get list of sites from the identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetSitesRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetSites(ctx context.Context) ApiIdentityGetSitesRequest {
	return ApiIdentityGetSitesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentitySiteResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetSitesExecute(r ApiIdentityGetSitesRequest) (*IdentitySiteResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentitySiteResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.hostNameOrIP != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostNameOrIP", r.hostNameOrIP, "")
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site", t, "multi")
		}
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetUserRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userOrGroup string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	forest *string
	domain *string
	directoryServerHint *string
	propertiesToRetrieve *int32
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetUserRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetUserRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetUserRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetUserRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetUserRequest) UserAgent(userAgent string) ApiIdentityGetUserRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetUserRequest) Authorization(authorization string) ApiIdentityGetUserRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetUserRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetUserRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetUserRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetUserRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetUserRequest) Accept(accept string) ApiIdentityGetUserRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetUserRequest) CitrixLocale(citrixLocale string) ApiIdentityGetUserRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Forest to get users from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetUserRequest) Forest(forest string) ApiIdentityGetUserRequest {
	r.forest = &forest
	return r
}

// Domain to get users from.  If not specified, all domains in the forest(s) are queried, which may take a long time.
func (r ApiIdentityGetUserRequest) Domain(domain string) ApiIdentityGetUserRequest {
	r.domain = &domain
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityGetUserRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityGetUserRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties will be retrieved.
func (r ApiIdentityGetUserRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetUserRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

func (r ApiIdentityGetUserRequest) Execute() (*IdentityUserResponseModel, *http.Response, error) {
	return r.ApiService.IdentityGetUserExecute(r)
}

/*
IdentityGetUser Get a single user or group

Get a single user or group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userOrGroup Identity of the user or group to get.
 @return ApiIdentityGetUserRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetUser(ctx context.Context, userOrGroup string) ApiIdentityGetUserRequest {
	return ApiIdentityGetUserRequest{
		ApiService: a,
		ctx: ctx,
		userOrGroup: userOrGroup,
	}
}

// Execute executes the request
//  @return IdentityUserResponseModel
func (a *IdentityAPIsDAASService) IdentityGetUserExecute(r ApiIdentityGetUserRequest) (*IdentityUserResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityUserResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Users/{userOrGroup}"
	localVarPath = strings.Replace(localVarPath, "{"+"userOrGroup"+"}", url.PathEscape(parameterValueToString(r.userOrGroup, "userOrGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGetUsersRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	provider *IdentityProviderType
	forest *string
	domain *string
	tenant *string
	user *[]string
	startsWith *string
	contains *string
	matches *string
	parentOU *string
	recursive *bool
	userType *IdentityUserType
	directoryServerHint *string
	propertiesToRetrieve *int32
	limit *int32
	continuationToken *string
	async *bool
	idpInstanceId *string
	includeIdentityClaims *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityGetUsersRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityGetUsersRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityGetUsersRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityGetUsersRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityGetUsersRequest) UserAgent(userAgent string) ApiIdentityGetUsersRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityGetUsersRequest) Authorization(authorization string) ApiIdentityGetUsersRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityGetUsersRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityGetUsersRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityGetUsersRequest) XAdminCredential(xAdminCredential string) ApiIdentityGetUsersRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityGetUsersRequest) Accept(accept string) ApiIdentityGetUsersRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityGetUsersRequest) CitrixLocale(citrixLocale string) ApiIdentityGetUsersRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Provider to get users from.
func (r ApiIdentityGetUsersRequest) Provider(provider IdentityProviderType) ApiIdentityGetUsersRequest {
	r.provider = &provider
	return r
}

// Forest to get users from.  If not specified, all forests are queried, which may take a long time.
func (r ApiIdentityGetUsersRequest) Forest(forest string) ApiIdentityGetUsersRequest {
	r.forest = &forest
	return r
}

// Domain to get users from.  If not specified, all domains in the forest(s) are queried, which may take a long time.
func (r ApiIdentityGetUsersRequest) Domain(domain string) ApiIdentityGetUsersRequest {
	r.domain = &domain
	return r
}

// Tenant to get users from.
func (r ApiIdentityGetUsersRequest) Tenant(tenant string) ApiIdentityGetUsersRequest {
	r.tenant = &tenant
	return r
}

// Specific user(s) to filter the results to. If not specified, all matching users are returned.  If set, &#x60;recursive&#x60; parameter is ignored and is implied &#x60;true&#x60;.
func (r ApiIdentityGetUsersRequest) User(user []string) ApiIdentityGetUsersRequest {
	r.user = &user
	return r
}

// Search for users that start with a string.  This parameter is exclusive with &#x60;contains&#x60;, and &#x60;matches&#x60;.
func (r ApiIdentityGetUsersRequest) StartsWith(startsWith string) ApiIdentityGetUsersRequest {
	r.startsWith = &startsWith
	return r
}

// Search for users that contain a string.  This parameter is exclusive with &#x60;startsWith&#x60;, and &#x60;matches&#x60;.
func (r ApiIdentityGetUsersRequest) Contains(contains string) ApiIdentityGetUsersRequest {
	r.contains = &contains
	return r
}

// Search for users that match a string.  This parameter is exclusive with &#x60;startsWith&#x60;, and &#x60;contains&#x60;.
func (r ApiIdentityGetUsersRequest) Matches(matches string) ApiIdentityGetUsersRequest {
	r.matches = &matches
	return r
}

// The parent OU to search.  If not specified, will search from the root OU.
func (r ApiIdentityGetUsersRequest) ParentOU(parentOU string) ApiIdentityGetUsersRequest {
	r.parentOU = &parentOU
	return r
}

// Indicates whether the search should be recursive.
func (r ApiIdentityGetUsersRequest) Recursive(recursive bool) ApiIdentityGetUsersRequest {
	r.recursive = &recursive
	return r
}

// Indicates user type(s) that should be retrieved.  If not specified, all user types will be searched.
func (r ApiIdentityGetUsersRequest) UserType(userType IdentityUserType) ApiIdentityGetUsersRequest {
	r.userType = &userType
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityGetUsersRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityGetUsersRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// Properties to retrieve.  This should be specified as an integer representing the OR-ed together values of the properties.  If not specified, all properties will be retrieved.
func (r ApiIdentityGetUsersRequest) PropertiesToRetrieve(propertiesToRetrieve int32) ApiIdentityGetUsersRequest {
	r.propertiesToRetrieve = &propertiesToRetrieve
	return r
}

// Maximum number of items to return.  If more items are available, a continuation token will be returned.  If not specified, all items will be returned.
func (r ApiIdentityGetUsersRequest) Limit(limit int32) ApiIdentityGetUsersRequest {
	r.limit = &limit
	return r
}

// If specified, a previous query will be continued.  The caller must specify the same query parameters and admin credentials as the initial query or else the behavior is undefined.
func (r ApiIdentityGetUsersRequest) ContinuationToken(continuationToken string) ApiIdentityGetUsersRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, the get users will be executed as a background task. The task will have JobType GetUsersIdentity. When the task is complete it will redirect to GetJobResults.
func (r ApiIdentityGetUsersRequest) Async(async bool) ApiIdentityGetUsersRequest {
	r.async = &async
	return r
}

// Instance id of the identity provider.
func (r ApiIdentityGetUsersRequest) IdpInstanceId(idpInstanceId string) ApiIdentityGetUsersRequest {
	r.idpInstanceId = &idpInstanceId
	return r
}

// Inlcude the identity claims in the results.
func (r ApiIdentityGetUsersRequest) IncludeIdentityClaims(includeIdentityClaims bool) ApiIdentityGetUsersRequest {
	r.includeIdentityClaims = &includeIdentityClaims
	return r
}

func (r ApiIdentityGetUsersRequest) Execute() (*IdentityUserResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityGetUsersExecute(r)
}

/*
IdentityGetUsers Get users from identity provider

Get users from identity provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetUsersRequest
*/
func (a *IdentityAPIsDAASService) IdentityGetUsers(ctx context.Context) ApiIdentityGetUsersRequest {
	return ApiIdentityGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityUserResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityGetUsersExecute(r ApiIdentityGetUsersRequest) (*IdentityUserResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityUserResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityGetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "")
	}
	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.tenant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", r.tenant, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.startsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startsWith", r.startsWith, "")
	}
	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.matches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matches", r.matches, "")
	}
	if r.parentOU != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentOU", r.parentOU, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "")
	}
	if r.userType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userType", r.userType, "")
	}
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.propertiesToRetrieve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertiesToRetrieve", r.propertiesToRetrieve, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.idpInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idpInstanceId", r.idpInstanceId, "")
	}
	if r.includeIdentityClaims != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeIdentityClaims", r.includeIdentityClaims, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityQueryAzureAdSecurityGroupsRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	azureAdTenantId string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAccessToken *string
	accept *string
	citrixLocale *string
	name *string
	assigned *bool
	maxCount *int32
	serviceAccountUid *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) UserAgent(userAgent string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) Authorization(authorization string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) XAccessToken(xAccessToken string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Must accept application/json.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) Accept(accept string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) CitrixLocale(citrixLocale string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Specific the group display name.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) Name(name string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.name = &name
	return r
}

// When name is empty, assigned only support the value of true.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) Assigned(assigned bool) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.assigned = &assigned
	return r
}

// The max return count,default is 300.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) MaxCount(maxCount int32) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.maxCount = &maxCount
	return r
}

// The service account uid.
func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) ServiceAccountUid(serviceAccountUid string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	r.serviceAccountUid = &serviceAccountUid
	return r
}

func (r ApiIdentityQueryAzureAdSecurityGroupsRequest) Execute() (*AzureADSecurityGroupResponseModelCollection, *http.Response, error) {
	return r.ApiService.IdentityQueryAzureAdSecurityGroupsExecute(r)
}

/*
IdentityQueryAzureAdSecurityGroups Query AzureAD security group by user's input.

When user's input all are empty, then all those assigned security group in a specific tenant it will be retrieved.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param azureAdTenantId The specific azure tenant id.
 @return ApiIdentityQueryAzureAdSecurityGroupsRequest
*/
func (a *IdentityAPIsDAASService) IdentityQueryAzureAdSecurityGroups(ctx context.Context, azureAdTenantId string) ApiIdentityQueryAzureAdSecurityGroupsRequest {
	return ApiIdentityQueryAzureAdSecurityGroupsRequest{
		ApiService: a,
		ctx: ctx,
		azureAdTenantId: azureAdTenantId,
	}
}

// Execute executes the request
//  @return AzureADSecurityGroupResponseModelCollection
func (a *IdentityAPIsDAASService) IdentityQueryAzureAdSecurityGroupsExecute(r ApiIdentityQueryAzureAdSecurityGroupsRequest) (*AzureADSecurityGroupResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AzureADSecurityGroupResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityQueryAzureAdSecurityGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/AzureADTenants/{azureAdTenantId}/AzureADSecurityGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"azureAdTenantId"+"}", url.PathEscape(parameterValueToString(r.azureAdTenantId, "azureAdTenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.assigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned", r.assigned, "")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.serviceAccountUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceAccountUid", r.serviceAccountUid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentitySetServiceAccountRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	serviceAccountUid string
	updateServiceAccountRequestModel *UpdateServiceAccountRequestModel
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentitySetServiceAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentitySetServiceAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentitySetServiceAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentitySetServiceAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// The object of UpdateServiceAccountRequestModel used to set an existing service account. 
func (r ApiIdentitySetServiceAccountRequest) UpdateServiceAccountRequestModel(updateServiceAccountRequestModel UpdateServiceAccountRequestModel) ApiIdentitySetServiceAccountRequest {
	r.updateServiceAccountRequestModel = &updateServiceAccountRequestModel
	return r
}

// User Agent type of the request.
func (r ApiIdentitySetServiceAccountRequest) UserAgent(userAgent string) ApiIdentitySetServiceAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentitySetServiceAccountRequest) Authorization(authorization string) ApiIdentitySetServiceAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentitySetServiceAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentitySetServiceAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentitySetServiceAccountRequest) Accept(accept string) ApiIdentitySetServiceAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentitySetServiceAccountRequest) CitrixLocale(citrixLocale string) ApiIdentitySetServiceAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentitySetServiceAccountRequest) Execute() (*ServiceAccountResponseModel, *http.Response, error) {
	return r.ApiService.IdentitySetServiceAccountExecute(r)
}

/*
IdentitySetServiceAccount Set properties of an existing service account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceAccountUid The ServiceAccountUid of service account. 
 @return ApiIdentitySetServiceAccountRequest
*/
func (a *IdentityAPIsDAASService) IdentitySetServiceAccount(ctx context.Context, serviceAccountUid string) ApiIdentitySetServiceAccountRequest {
	return ApiIdentitySetServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		serviceAccountUid: serviceAccountUid,
	}
}

// Execute executes the request
//  @return ServiceAccountResponseModel
func (a *IdentityAPIsDAASService) IdentitySetServiceAccountExecute(r ApiIdentitySetServiceAccountRequest) (*ServiceAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentitySetServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/ServiceAccount/{serviceAccountUid}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceAccountUid"+"}", url.PathEscape(parameterValueToString(r.serviceAccountUid, "serviceAccountUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.updateServiceAccountRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateServiceAccountRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.updateServiceAccountRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityTestServiceAccountRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	serviceAccountUid string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityTestServiceAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityTestServiceAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityTestServiceAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityTestServiceAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiIdentityTestServiceAccountRequest) UserAgent(userAgent string) ApiIdentityTestServiceAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityTestServiceAccountRequest) Authorization(authorization string) ApiIdentityTestServiceAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityTestServiceAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityTestServiceAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityTestServiceAccountRequest) Accept(accept string) ApiIdentityTestServiceAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityTestServiceAccountRequest) CitrixLocale(citrixLocale string) ApiIdentityTestServiceAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tests will run as a background task. This is recommended as the tests may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType TestServiceAccount. When the task is complete it will redirect to GetJobResults. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the service account being tested,
func (r ApiIdentityTestServiceAccountRequest) Async(async bool) ApiIdentityTestServiceAccountRequest {
	r.async = &async
	return r
}

func (r ApiIdentityTestServiceAccountRequest) Execute() (*ServiceAccountTestResponseModel, *http.Response, error) {
	return r.ApiService.IdentityTestServiceAccountExecute(r)
}

/*
IdentityTestServiceAccount Run tests on a service account and create a test report.

Run tests on a service account and create a test report.  Obtain the most
recent report from
GetServiceAccountTestReport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceAccountUid ID of the service account to test.
 @return ApiIdentityTestServiceAccountRequest
*/
func (a *IdentityAPIsDAASService) IdentityTestServiceAccount(ctx context.Context, serviceAccountUid string) ApiIdentityTestServiceAccountRequest {
	return ApiIdentityTestServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		serviceAccountUid: serviceAccountUid,
	}
}

// Execute executes the request
//  @return ServiceAccountTestResponseModel
func (a *IdentityAPIsDAASService) IdentityTestServiceAccountExecute(r ApiIdentityTestServiceAccountRequest) (*ServiceAccountTestResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceAccountTestResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityTestServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/serviceAccount/{serviceAccountUid}/$test"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceAccountUid"+"}", url.PathEscape(parameterValueToString(r.serviceAccountUid, "serviceAccountUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityUpdateMachineRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	machine string
	forest *string
	domain *string
	identityUpdateMachineRequestModel *IdentityUpdateMachineRequestModel
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	directoryServerHint *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityUpdateMachineRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityUpdateMachineRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityUpdateMachineRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityUpdateMachineRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Forest to update machine account within.  Required.
func (r ApiIdentityUpdateMachineRequest) Forest(forest string) ApiIdentityUpdateMachineRequest {
	r.forest = &forest
	return r
}

// Domain to update machine account within.  Required.
func (r ApiIdentityUpdateMachineRequest) Domain(domain string) ApiIdentityUpdateMachineRequest {
	r.domain = &domain
	return r
}

// Properties of the machine identity that should be updated.
func (r ApiIdentityUpdateMachineRequest) IdentityUpdateMachineRequestModel(identityUpdateMachineRequestModel IdentityUpdateMachineRequestModel) ApiIdentityUpdateMachineRequest {
	r.identityUpdateMachineRequestModel = &identityUpdateMachineRequestModel
	return r
}

// User Agent type of the request.
func (r ApiIdentityUpdateMachineRequest) UserAgent(userAgent string) ApiIdentityUpdateMachineRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityUpdateMachineRequest) Authorization(authorization string) ApiIdentityUpdateMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityUpdateMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityUpdateMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityUpdateMachineRequest) XAdminCredential(xAdminCredential string) ApiIdentityUpdateMachineRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityUpdateMachineRequest) Accept(accept string) ApiIdentityUpdateMachineRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityUpdateMachineRequest) CitrixLocale(citrixLocale string) ApiIdentityUpdateMachineRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityUpdateMachineRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityUpdateMachineRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// If &#x60;true&#x60;, the machine identity will be updated as a background task.
func (r ApiIdentityUpdateMachineRequest) Async(async bool) ApiIdentityUpdateMachineRequest {
	r.async = &async
	return r
}

func (r ApiIdentityUpdateMachineRequest) Execute() (*IdentityMachineResponseModel, *http.Response, error) {
	return r.ApiService.IdentityUpdateMachineExecute(r)
}

/*
IdentityUpdateMachine Update a machine identity

Update a machine identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param machine Machine identity to update.
 @return ApiIdentityUpdateMachineRequest
*/
func (a *IdentityAPIsDAASService) IdentityUpdateMachine(ctx context.Context, machine string) ApiIdentityUpdateMachineRequest {
	return ApiIdentityUpdateMachineRequest{
		ApiService: a,
		ctx: ctx,
		machine: machine,
	}
}

// Execute executes the request
//  @return IdentityMachineResponseModel
func (a *IdentityAPIsDAASService) IdentityUpdateMachineExecute(r ApiIdentityUpdateMachineRequest) (*IdentityMachineResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityMachineResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityUpdateMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Machines/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.forest == nil {
		return localVarReturnValue, nil, reportError("forest is required and must be specified")
	}
	if r.domain == nil {
		return localVarReturnValue, nil, reportError("domain is required and must be specified")
	}
	if r.identityUpdateMachineRequestModel == nil {
		return localVarReturnValue, nil, reportError("identityUpdateMachineRequestModel is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.identityUpdateMachineRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityUpdateUserRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	user string
	forest *string
	domain *string
	identityUpdateUserRequestModel *IdentityUpdateUserRequestModel
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	accept *string
	citrixLocale *string
	directoryServerHint *string
	async *bool
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityUpdateUserRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityUpdateUserRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityUpdateUserRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityUpdateUserRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Forest to update user account within.  Required.
func (r ApiIdentityUpdateUserRequest) Forest(forest string) ApiIdentityUpdateUserRequest {
	r.forest = &forest
	return r
}

// Domain to update user account within.  Required.
func (r ApiIdentityUpdateUserRequest) Domain(domain string) ApiIdentityUpdateUserRequest {
	r.domain = &domain
	return r
}

// Properties of the user identity that should be updated.
func (r ApiIdentityUpdateUserRequest) IdentityUpdateUserRequestModel(identityUpdateUserRequestModel IdentityUpdateUserRequestModel) ApiIdentityUpdateUserRequest {
	r.identityUpdateUserRequestModel = &identityUpdateUserRequestModel
	return r
}

// User Agent type of the request.
func (r ApiIdentityUpdateUserRequest) UserAgent(userAgent string) ApiIdentityUpdateUserRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityUpdateUserRequest) Authorization(authorization string) ApiIdentityUpdateUserRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityUpdateUserRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityUpdateUserRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiIdentityUpdateUserRequest) XAdminCredential(xAdminCredential string) ApiIdentityUpdateUserRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiIdentityUpdateUserRequest) Accept(accept string) ApiIdentityUpdateUserRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityUpdateUserRequest) CitrixLocale(citrixLocale string) ApiIdentityUpdateUserRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Hint to inform the system of a directory server which is most likely to successfully perform the operation.
func (r ApiIdentityUpdateUserRequest) DirectoryServerHint(directoryServerHint string) ApiIdentityUpdateUserRequest {
	r.directoryServerHint = &directoryServerHint
	return r
}

// If &#x60;true&#x60;, the user identity will be updated as a background task.
func (r ApiIdentityUpdateUserRequest) Async(async bool) ApiIdentityUpdateUserRequest {
	r.async = &async
	return r
}

func (r ApiIdentityUpdateUserRequest) Execute() (*IdentityUserResponseModel, *http.Response, error) {
	return r.ApiService.IdentityUpdateUserExecute(r)
}

/*
IdentityUpdateUser Update a user identity

Update a user identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param user User identity to update.
 @return ApiIdentityUpdateUserRequest
*/
func (a *IdentityAPIsDAASService) IdentityUpdateUser(ctx context.Context, user string) ApiIdentityUpdateUserRequest {
	return ApiIdentityUpdateUserRequest{
		ApiService: a,
		ctx: ctx,
		user: user,
	}
}

// Execute executes the request
//  @return IdentityUserResponseModel
func (a *IdentityAPIsDAASService) IdentityUpdateUserExecute(r ApiIdentityUpdateUserRequest) (*IdentityUserResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityUserResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityUpdateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Users/{user}"
	localVarPath = strings.Replace(localVarPath, "{"+"user"+"}", url.PathEscape(parameterValueToString(r.user, "user")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.forest == nil {
		return localVarReturnValue, nil, reportError("forest is required and must be specified")
	}
	if r.domain == nil {
		return localVarReturnValue, nil, reportError("domain is required and must be specified")
	}
	if r.identityUpdateUserRequestModel == nil {
		return localVarReturnValue, nil, reportError("identityUpdateUserRequestModel is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	if r.directoryServerHint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryServerHint", r.directoryServerHint, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.identityUpdateUserRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityValidateUserRequest struct {
	ctx context.Context
	ApiService *IdentityAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	identityValidateUserRequestModel *IdentityValidateUserRequestModel
	userAgent *string
	authorization *string
	citrixTransactionId *string
	accept *string
	citrixLocale *string
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiIdentityValidateUserRequest) CitrixCustomerId(citrixCustomerId string) ApiIdentityValidateUserRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiIdentityValidateUserRequest) CitrixInstanceId(citrixInstanceId string) ApiIdentityValidateUserRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details of the user credentials to validate.
func (r ApiIdentityValidateUserRequest) IdentityValidateUserRequestModel(identityValidateUserRequestModel IdentityValidateUserRequestModel) ApiIdentityValidateUserRequest {
	r.identityValidateUserRequestModel = &identityValidateUserRequestModel
	return r
}

// User Agent type of the request.
func (r ApiIdentityValidateUserRequest) UserAgent(userAgent string) ApiIdentityValidateUserRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiIdentityValidateUserRequest) Authorization(authorization string) ApiIdentityValidateUserRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiIdentityValidateUserRequest) CitrixTransactionId(citrixTransactionId string) ApiIdentityValidateUserRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiIdentityValidateUserRequest) Accept(accept string) ApiIdentityValidateUserRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiIdentityValidateUserRequest) CitrixLocale(citrixLocale string) ApiIdentityValidateUserRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiIdentityValidateUserRequest) Execute() (*IdentityUserResponseModel, *http.Response, error) {
	return r.ApiService.IdentityValidateUserExecute(r)
}

/*
IdentityValidateUser Validate a user's credentials

Validate a user's credentials, and if valid, get information about the user account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityValidateUserRequest
*/
func (a *IdentityAPIsDAASService) IdentityValidateUser(ctx context.Context) ApiIdentityValidateUserRequest {
	return ApiIdentityValidateUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IdentityUserResponseModel
func (a *IdentityAPIsDAASService) IdentityValidateUserExecute(r ApiIdentityValidateUserRequest) (*IdentityUserResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityUserResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIsDAASService.IdentityValidateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Identity/Users/$validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.identityValidateUserRequestModel == nil {
		return localVarReturnValue, nil, reportError("identityValidateUserRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.identityValidateUserRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
