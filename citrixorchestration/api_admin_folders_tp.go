/*
Citrix Virtual Apps and Desktops REST API TECHPREVIEW

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: techpreview
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AdminFoldersTPApiService AdminFoldersTPApi service
type AdminFoldersTPApiService service

type ApiAdminFoldersTPCreateAdminFolderRequest struct {
	ctx context.Context
	ApiService *AdminFoldersTPApiService
	customerid string
	siteid string
	request *CreateAdminFolderRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details of the admin folder to create.
func (r ApiAdminFoldersTPCreateAdminFolderRequest) Request(request CreateAdminFolderRequestModel) ApiAdminFoldersTPCreateAdminFolderRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the admin folder will be created as a background task. The task will have JobType \&quot;JobType.CreateAdminFolder\&quot;. When the task is complete it will redirect to \&quot;GetAdminFolder(string)\&quot; The job Parameters will contain properties:  * _Name_ - Name of the folder being created. * _Path_ - Path to the folder being created.
func (r ApiAdminFoldersTPCreateAdminFolderRequest) Async(async bool) ApiAdminFoldersTPCreateAdminFolderRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiAdminFoldersTPCreateAdminFolderRequest) Authorization(authorization string) ApiAdminFoldersTPCreateAdminFolderRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiAdminFoldersTPCreateAdminFolderRequest) CitrixTransactionId(citrixTransactionId string) ApiAdminFoldersTPCreateAdminFolderRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiAdminFoldersTPCreateAdminFolderRequest) XActionName(xActionName string) ApiAdminFoldersTPCreateAdminFolderRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiAdminFoldersTPCreateAdminFolderRequest) Execute() (*AdminFolderResponseModel, *http.Response, error) {
	return r.ApiService.AdminFoldersTPCreateAdminFolderExecute(r)
}

/*
AdminFoldersTPCreateAdminFolder Create an admin folder

Create an admin folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerid
 @param siteid
 @return ApiAdminFoldersTPCreateAdminFolderRequest
*/
func (a *AdminFoldersTPApiService) AdminFoldersTPCreateAdminFolder(ctx context.Context, customerid string, siteid string) ApiAdminFoldersTPCreateAdminFolderRequest {
	return ApiAdminFoldersTPCreateAdminFolderRequest{
		ApiService: a,
		ctx: ctx,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return AdminFolderResponseModel
func (a *AdminFoldersTPApiService) AdminFoldersTPCreateAdminFolderExecute(r ApiAdminFoldersTPCreateAdminFolderRequest) (*AdminFolderResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminFolderResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminFoldersTPApiService.AdminFoldersTPCreateAdminFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/AdminFolders"
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminFoldersTPDeleteAdminFolderRequest struct {
	ctx context.Context
	ApiService *AdminFoldersTPApiService
	pathOrId string
	customerid string
	siteid string
	objectsToRemove *[]AdminFolderObjects
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Identify which object should be removed from the adminFolder. If set to null, then the admin folder will be deleted if it hosts no object and no folder metaData with keys AdminFolderObjectIdentifier.  If set to Applications, the applications in the folder will be deleted. The folder will be deleted if it do not host other objects(MachineCatalogs, or DeliveryGroup, or ApplicationGroups) and no folder metaData with keysAdminFolderObjectIdentifier.; If the folder hosts any other objects, then this folder will not be deleted, folder metadata with key ContainsApplications will be removed.  If set to MachineCatalogs and this folder still hosts some MachineCatalogs, then this folder is not allowed to be deleted; If this folder do not host any MachineCatalogs but host other objects(Applications, DeliveryGroups, ApplicationGroups), the folder metaData with key ContainsMachineCatalogs will be removed; If this folder do not host any objects and no folder metaData with keys AdminFolderObjectIdentifier, the folder will be deleted.              If set to DeliveryGroups or ApplicationGroups, have the same behavior as set to MachineCatalogs.
func (r ApiAdminFoldersTPDeleteAdminFolderRequest) ObjectsToRemove(objectsToRemove []AdminFolderObjects) ApiAdminFoldersTPDeleteAdminFolderRequest {
	r.objectsToRemove = &objectsToRemove
	return r
}

// If &#x60;true&#x60;, the admin folder will be deleted as a background task. The task will have JobType DeleteAdminFolder. When the task is complete it will redirect to GetAdminFolders. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the admin folder being deleted, * _Path_ - Path of the admin folder being deleted.
func (r ApiAdminFoldersTPDeleteAdminFolderRequest) Async(async bool) ApiAdminFoldersTPDeleteAdminFolderRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiAdminFoldersTPDeleteAdminFolderRequest) Authorization(authorization string) ApiAdminFoldersTPDeleteAdminFolderRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiAdminFoldersTPDeleteAdminFolderRequest) CitrixTransactionId(citrixTransactionId string) ApiAdminFoldersTPDeleteAdminFolderRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiAdminFoldersTPDeleteAdminFolderRequest) XActionName(xActionName string) ApiAdminFoldersTPDeleteAdminFolderRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiAdminFoldersTPDeleteAdminFolderRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminFoldersTPDeleteAdminFolderExecute(r)
}

/*
AdminFoldersTPDeleteAdminFolder Delete an admin folder.

Delete an admin folder. An admin folder is not allowed to be deleted
when it contains any objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pathOrId Name or ID of the admin folder to delete.
 @param customerid
 @param siteid
 @return ApiAdminFoldersTPDeleteAdminFolderRequest
*/
func (a *AdminFoldersTPApiService) AdminFoldersTPDeleteAdminFolder(ctx context.Context, pathOrId string, customerid string, siteid string) ApiAdminFoldersTPDeleteAdminFolderRequest {
	return ApiAdminFoldersTPDeleteAdminFolderRequest{
		ApiService: a,
		ctx: ctx,
		pathOrId: pathOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *AdminFoldersTPApiService) AdminFoldersTPDeleteAdminFolderExecute(r ApiAdminFoldersTPDeleteAdminFolderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminFoldersTPApiService.AdminFoldersTPDeleteAdminFolder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/AdminFolders/{pathOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pathOrId"+"}", url.PathEscape(parameterValueToString(r.pathOrId, "pathOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.objectsToRemove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectsToRemove", r.objectsToRemove, "csv")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminFoldersTPGetAdminFolderRequest struct {
	ctx context.Context
	ApiService *AdminFoldersTPApiService
	pathOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiAdminFoldersTPGetAdminFolderRequest) Authorization(authorization string) ApiAdminFoldersTPGetAdminFolderRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiAdminFoldersTPGetAdminFolderRequest) CitrixTransactionId(citrixTransactionId string) ApiAdminFoldersTPGetAdminFolderRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiAdminFoldersTPGetAdminFolderRequest) XActionName(xActionName string) ApiAdminFoldersTPGetAdminFolderRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiAdminFoldersTPGetAdminFolderRequest) Execute() (*AdminFolderResponseModel, *http.Response, error) {
	return r.ApiService.AdminFoldersTPGetAdminFolderExecute(r)
}

/*
AdminFoldersTPGetAdminFolder Get details about a single admin folder.

Gets the details of a single admin folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pathOrId Path (URL-encoded) or ID of the admin folder.
 @param customerid
 @param siteid
 @return ApiAdminFoldersTPGetAdminFolderRequest
*/
func (a *AdminFoldersTPApiService) AdminFoldersTPGetAdminFolder(ctx context.Context, pathOrId string, customerid string, siteid string) ApiAdminFoldersTPGetAdminFolderRequest {
	return ApiAdminFoldersTPGetAdminFolderRequest{
		ApiService: a,
		ctx: ctx,
		pathOrId: pathOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return AdminFolderResponseModel
func (a *AdminFoldersTPApiService) AdminFoldersTPGetAdminFolderExecute(r ApiAdminFoldersTPGetAdminFolderRequest) (*AdminFolderResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminFolderResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminFoldersTPApiService.AdminFoldersTPGetAdminFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/AdminFolders/{pathOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pathOrId"+"}", url.PathEscape(parameterValueToString(r.pathOrId, "pathOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminFoldersTPGetAdminFolderApplicationsRequest struct {
	ctx context.Context
	ApiService *AdminFoldersTPApiService
	pathOrId string
	customerid string
	siteid string
	limit *int32
	continuationToken *string
	fields *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// The max number of applications returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) Limit(limit int32) ApiAdminFoldersTPGetAdminFolderApplicationsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) ContinuationToken(continuationToken string) ApiAdminFoldersTPGetAdminFolderApplicationsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) Fields(fields string) ApiAdminFoldersTPGetAdminFolderApplicationsRequest {
	r.fields = &fields
	return r
}

// If &#x60;true&#x60;, Fetch applications under admin folder will be a background task. The task will have JobType GetAdminFolderApplications
func (r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) Async(async bool) ApiAdminFoldersTPGetAdminFolderApplicationsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) Authorization(authorization string) ApiAdminFoldersTPGetAdminFolderApplicationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) CitrixTransactionId(citrixTransactionId string) ApiAdminFoldersTPGetAdminFolderApplicationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) XActionName(xActionName string) ApiAdminFoldersTPGetAdminFolderApplicationsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) Execute() (*ApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiService.AdminFoldersTPGetAdminFolderApplicationsExecute(r)
}

/*
AdminFoldersTPGetAdminFolderApplications Get the applications in an admin folder.

Get a list of all applications in an admin folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pathOrId Path (URL-encoded) or ID of the admin folder.
 @param customerid
 @param siteid
 @return ApiAdminFoldersTPGetAdminFolderApplicationsRequest
*/
func (a *AdminFoldersTPApiService) AdminFoldersTPGetAdminFolderApplications(ctx context.Context, pathOrId string, customerid string, siteid string) ApiAdminFoldersTPGetAdminFolderApplicationsRequest {
	return ApiAdminFoldersTPGetAdminFolderApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		pathOrId: pathOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return ApplicationResponseModelCollection
func (a *AdminFoldersTPApiService) AdminFoldersTPGetAdminFolderApplicationsExecute(r ApiAdminFoldersTPGetAdminFolderApplicationsRequest) (*ApplicationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminFoldersTPApiService.AdminFoldersTPGetAdminFolderApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/AdminFolders/{pathOrId}/Applications"
	localVarPath = strings.Replace(localVarPath, "{"+"pathOrId"+"}", url.PathEscape(parameterValueToString(r.pathOrId, "pathOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest struct {
	ctx context.Context
	ApiService *AdminFoldersTPApiService
	pathOrId string
	customerid string
	siteid string
	limit *int32
	continuationToken *string
	fields *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) Limit(limit int32) ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) ContinuationToken(continuationToken string) ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) Fields(fields string) ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest {
	r.fields = &fields
	return r
}

// If &#x60;true&#x60;, Fetch machineCatalogs under admin folder will be a background task. The task will have JobType GetAdminFolderMachineCatalogs
func (r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) Async(async bool) ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) Authorization(authorization string) ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) CitrixTransactionId(citrixTransactionId string) ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) XActionName(xActionName string) ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiService.AdminFoldersTPGetAdminFolderMachineCatalogsExecute(r)
}

/*
AdminFoldersTPGetAdminFolderMachineCatalogs Get the machineCatalogs in an admin folder.

Get a list of all machineCatalogs in an admin folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pathOrId Path (URL-encoded) or ID of the admin folder.
 @param customerid
 @param siteid
 @return ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest
*/
func (a *AdminFoldersTPApiService) AdminFoldersTPGetAdminFolderMachineCatalogs(ctx context.Context, pathOrId string, customerid string, siteid string) ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest {
	return ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest{
		ApiService: a,
		ctx: ctx,
		pathOrId: pathOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineCatalogResponseModelCollection
func (a *AdminFoldersTPApiService) AdminFoldersTPGetAdminFolderMachineCatalogsExecute(r ApiAdminFoldersTPGetAdminFolderMachineCatalogsRequest) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminFoldersTPApiService.AdminFoldersTPGetAdminFolderMachineCatalogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/AdminFolders/{pathOrId}/MachineCatalogs"
	localVarPath = strings.Replace(localVarPath, "{"+"pathOrId"+"}", url.PathEscape(parameterValueToString(r.pathOrId, "pathOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminFoldersTPGetAdminFoldersRequest struct {
	ctx context.Context
	ApiService *AdminFoldersTPApiService
	customerid string
	siteid string
	async *bool
	limit *int32
	continuationToken *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the admin folders will be fetched as a background task. The task will have JobType GetAdminFolders.
func (r ApiAdminFoldersTPGetAdminFoldersRequest) Async(async bool) ApiAdminFoldersTPGetAdminFoldersRequest {
	r.async = &async
	return r
}

// The max number of admin folders returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiAdminFoldersTPGetAdminFoldersRequest) Limit(limit int32) ApiAdminFoldersTPGetAdminFoldersRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiAdminFoldersTPGetAdminFoldersRequest) ContinuationToken(continuationToken string) ApiAdminFoldersTPGetAdminFoldersRequest {
	r.continuationToken = &continuationToken
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiAdminFoldersTPGetAdminFoldersRequest) Authorization(authorization string) ApiAdminFoldersTPGetAdminFoldersRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiAdminFoldersTPGetAdminFoldersRequest) CitrixTransactionId(citrixTransactionId string) ApiAdminFoldersTPGetAdminFoldersRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiAdminFoldersTPGetAdminFoldersRequest) XActionName(xActionName string) ApiAdminFoldersTPGetAdminFoldersRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiAdminFoldersTPGetAdminFoldersRequest) Execute() (*AdminFolderResponseModelCollection, *http.Response, error) {
	return r.ApiService.AdminFoldersTPGetAdminFoldersExecute(r)
}

/*
AdminFoldersTPGetAdminFolders Get admin folders.

Gets all admin folders within the site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerid
 @param siteid
 @return ApiAdminFoldersTPGetAdminFoldersRequest
*/
func (a *AdminFoldersTPApiService) AdminFoldersTPGetAdminFolders(ctx context.Context, customerid string, siteid string) ApiAdminFoldersTPGetAdminFoldersRequest {
	return ApiAdminFoldersTPGetAdminFoldersRequest{
		ApiService: a,
		ctx: ctx,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return AdminFolderResponseModelCollection
func (a *AdminFoldersTPApiService) AdminFoldersTPGetAdminFoldersExecute(r ApiAdminFoldersTPGetAdminFoldersRequest) (*AdminFolderResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminFolderResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminFoldersTPApiService.AdminFoldersTPGetAdminFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/AdminFolders"
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminFoldersTPUpdateAdminFolderRequest struct {
	ctx context.Context
	ApiService *AdminFoldersTPApiService
	pathOrId string
	customerid string
	siteid string
	folder *EditAdminFolderRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details of the admin folder to update.
func (r ApiAdminFoldersTPUpdateAdminFolderRequest) Folder(folder EditAdminFolderRequestModel) ApiAdminFoldersTPUpdateAdminFolderRequest {
	r.folder = &folder
	return r
}

// If &#x60;true&#x60;, the admin folder will be updated as a background task. The task will have JobType UpdateAdminFolder. When the task is complete it will redirect to GetAdminFolder. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the admin folder being updated. * _Path_ - Path of the admin folder being updated.
func (r ApiAdminFoldersTPUpdateAdminFolderRequest) Async(async bool) ApiAdminFoldersTPUpdateAdminFolderRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiAdminFoldersTPUpdateAdminFolderRequest) Authorization(authorization string) ApiAdminFoldersTPUpdateAdminFolderRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiAdminFoldersTPUpdateAdminFolderRequest) CitrixTransactionId(citrixTransactionId string) ApiAdminFoldersTPUpdateAdminFolderRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiAdminFoldersTPUpdateAdminFolderRequest) XActionName(xActionName string) ApiAdminFoldersTPUpdateAdminFolderRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiAdminFoldersTPUpdateAdminFolderRequest) Execute() (*AdminFolderResponseModel, *http.Response, error) {
	return r.ApiService.AdminFoldersTPUpdateAdminFolderExecute(r)
}

/*
AdminFoldersTPUpdateAdminFolder Update an admin folder.

Update an admin folder's properties.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pathOrId Path or ID of the admin folder path to update.
 @param customerid
 @param siteid
 @return ApiAdminFoldersTPUpdateAdminFolderRequest
*/
func (a *AdminFoldersTPApiService) AdminFoldersTPUpdateAdminFolder(ctx context.Context, pathOrId string, customerid string, siteid string) ApiAdminFoldersTPUpdateAdminFolderRequest {
	return ApiAdminFoldersTPUpdateAdminFolderRequest{
		ApiService: a,
		ctx: ctx,
		pathOrId: pathOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return AdminFolderResponseModel
func (a *AdminFoldersTPApiService) AdminFoldersTPUpdateAdminFolderExecute(r ApiAdminFoldersTPUpdateAdminFolderRequest) (*AdminFolderResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminFolderResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminFoldersTPApiService.AdminFoldersTPUpdateAdminFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/AdminFolders/{pathOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pathOrId"+"}", url.PathEscape(parameterValueToString(r.pathOrId, "pathOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.folder == nil {
		return localVarReturnValue, nil, reportError("folder is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.folder
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
