/*
Citrix Virtual Apps and Desktops Rest API for Developer Portal

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: devportal-ga
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MachineCatalogsAPIsDAASService MachineCatalogsAPIsDAAS service
type MachineCatalogsAPIsDAASService service

type ApiMachineCatalogsAddMachineCatalogMachineRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	addMachineToMachineCatalogDetailRequestModel *AddMachineToMachineCatalogDetailRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xAccessToken *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) UserAgent(userAgent string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.userAgent = &userAgent
	return r
}

// Details of the machine to add to the machine catalog.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) AddMachineToMachineCatalogDetailRequestModel(addMachineToMachineCatalogDetailRequestModel AddMachineToMachineCatalogDetailRequestModel) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.addMachineToMachineCatalogDetailRequestModel = &addMachineToMachineCatalogDetailRequestModel
	return r
}

// If &#x60;true&#x60;, the machine will be added into the machine catalog as a background task. The task will have JobType AddMachineCatalogMachine. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties: * _NameOrId_ - Name or ID of the machine being added.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) Async(async bool) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) Authorization(authorization string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) XActionName(xActionName string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) Accept(accept string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsAddMachineCatalogMachineExecute(r)
}

/*
MachineCatalogsAddMachineCatalogMachine Add machine to the machine catalog.

Add a machine to the machine catalog.  This is the first step in making the
machine available to run users' desktops and applications. The machine may
be physical or virtual.  The type of machine (physical or virtual) must
match the machine catalog configuration.


Note that due to
the long-running nature of the adding operation, it cannot
complete synchronously, would always initiate an asynchronous job to
run to completion.


The machine must support the expected capabilities of the machine catalog:
the  and
. The session
support of the machine is determined by the type of Citrix VDA software
installed (server or workstation) and the functional level depends on the
version of the Citrix VDA software installed.  The API will complete
successfully if these are not correct but the machine will be unable to register.


Note: to add multiple machines in a single call, use the
 API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to add machine to.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsAddMachineCatalogMachineRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogMachine(ctx context.Context, nameOrId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	return ApiMachineCatalogsAddMachineCatalogMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return JobResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogMachineExecute(r ApiMachineCatalogsAddMachineCatalogMachineRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsAddMachineCatalogMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Machines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.addMachineToMachineCatalogDetailRequestModel == nil {
		return localVarReturnValue, nil, reportError("addMachineToMachineCatalogDetailRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.addMachineToMachineCatalogDetailRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsAddMachineCatalogMachineAccountRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	machineAccountRequestModel *MachineAccountRequestModel
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) UserAgent(userAgent string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Machine account to add to the machine catalog.  The machine must not be a member of any other machine catalog.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) MachineAccountRequestModel(machineAccountRequestModel MachineAccountRequestModel) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.machineAccountRequestModel = &machineAccountRequestModel
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) XActionName(xActionName string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) Accept(accept string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsAddMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsAddMachineCatalogMachineAccount Add a machine account to the machine catalog.

Add a machine account to the machine catalog. This is only relevant for machine catalogs where ProvisioningType is MCS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to add the machine account to.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsAddMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogMachineAccount(ctx context.Context, nameOrId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsAddMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return ProvisioningSchemeMachineAccountResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogMachineAccountExecute(r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvisioningSchemeMachineAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsAddMachineCatalogMachineAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MachineAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.machineAccountRequestModel == nil {
		return localVarReturnValue, nil, reportError("machineAccountRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.machineAccountRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsAddMachineCatalogTagsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	tagNameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) UserAgent(userAgent string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) XActionName(xActionName string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) Accept(accept string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsAddMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsAddMachineCatalogTags Add a tag to a machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param tagNameOrId Name or ID of the tag to add.
 @return ApiMachineCatalogsAddMachineCatalogTagsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	return ApiMachineCatalogsAddMachineCatalogTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		tagNameOrId: tagNameOrId,
	}
}

// Execute executes the request
//  @return TagResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogTagsExecute(r ApiMachineCatalogsAddMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsAddMachineCatalogTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Tags/{tagNameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagNameOrId"+"}", url.PathEscape(parameterValueToString(r.tagNameOrId, "tagNameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsCheckMachineCatalogExistsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	name string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) UserAgent(userAgent string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) Authorization(authorization string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) XActionName(xActionName string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) Accept(accept string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsCheckMachineCatalogExistsExecute(r)
}

/*
MachineCatalogsCheckMachineCatalogExists Check for the existence of a machine catalog by name.

Check for the existence of a machine catalog by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsCheckMachineCatalogExistsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCheckMachineCatalogExists(ctx context.Context, name string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	return ApiMachineCatalogsCheckMachineCatalogExistsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCheckMachineCatalogExistsExecute(r ApiMachineCatalogsCheckMachineCatalogExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsCheckMachineCatalogExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	name string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) UserAgent(userAgent string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) Authorization(authorization string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) XActionName(xActionName string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) Accept(accept string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsCheckRemotePCEnrollmentScopeExistsExecute(r)
}

/*
MachineCatalogsCheckRemotePCEnrollmentScopeExists Check for the existence of a RemotePC enrollment scope by name.

Check for the existence of a RemotePC enrollment scope by name. Note that
RemotePC enrollment scope names must be unique within the site, so the
`nameOrId` parameter does not affect whether the RemotePC enrollment scope
name is found.
If the name is found to be available, this returns 404 Not Found.
If a RemotePC enrollment scope by that name exists and is associated with the
specified machine catalog, this returns 204 No Content. If a RemotePC
enrollment scope by that name exists and is associated with a different
machine catalog, this returns 303 See Other, and the `Location`
response header refers to location of the machine catalog which is associated
by the RemotePC enrollment scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param name Distinguished name of an OU containing machines allowed to enroll as remote PCs.
 @return ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCheckRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string, name string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	return ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		name: name,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCheckRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsCheckRemotePCEnrollmentScopeExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/RemotePCEnrollmentScopes/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsCreateMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	createMachineCatalogRequestModel *CreateMachineCatalogRequestModel
	async *bool
	sourceNameOrId *string
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xAccessToken *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// Details about the machine catalog to create.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CreateMachineCatalogRequestModel(createMachineCatalogRequestModel CreateMachineCatalogRequestModel) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.createMachineCatalogRequestModel = &createMachineCatalogRequestModel
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be created as a background task. The task will have JobType CreateMachineCatalog. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties: * _Name_ - Name of the machine catalog being created.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) Async(async bool) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.async = &async
	return r
}

// The machine catalog name or Id to recreate from. It is only used for catalog recreation scenario. Here specify name or Id of the failed catalog to recreate.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) SourceNameOrId(sourceNameOrId string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.sourceNameOrId = &sourceNameOrId
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsCreateMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsCreateMachineCatalogRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsCreateMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsCreateMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsCreateMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsCreateMachineCatalogExecute(r)
}

/*
MachineCatalogsCreateMachineCatalog Create a machine catalog.

Create a machine catalog.

Note that if a machine catalog uses 
of , the machine catalog creation will always invoke asynchronous
job(s) for the provisioning action.  If this API is invoked asynchronously, the asynchronous job
will include only the machine catalog creation, and the provisioning task(s) will be associated
with the newly created catalog.  If this API is invoked synchronously, the machine catalog
creation will complete synchronously but the provisioning task(s) may still be executing, and
will be associated with the newly created catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMachineCatalogsCreateMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCreateMachineCatalog(ctx context.Context) ApiMachineCatalogsCreateMachineCatalogRequest {
	return ApiMachineCatalogsCreateMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MachineCatalogDetailResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCreateMachineCatalogExecute(r ApiMachineCatalogsCreateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsCreateMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.createMachineCatalogRequestModel == nil {
		return localVarReturnValue, nil, reportError("createMachineCatalogRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.sourceNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNameOrId", r.sourceNameOrId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.createMachineCatalogRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	createUpgradeScheduleRequestModel *CreateUpgradeScheduleRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) UserAgent(userAgent string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.userAgent = &userAgent
	return r
}

// Details about the VDA upgrade schedule to create.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CreateUpgradeScheduleRequestModel(createUpgradeScheduleRequestModel CreateUpgradeScheduleRequestModel) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.createUpgradeScheduleRequestModel = &createUpgradeScheduleRequestModel
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be created as a background task.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) XActionName(xActionName string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Accept(accept string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsCreateMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsCreateMachineCatalogUpgradeSchedule Setup a new VDA upgrade schedule for a machine catalog.

A new VDA upgrade schedule can only be created for a machine catalog
when the upgrade status for the catalog is UpgradeSuccessful, UpgradeFailed or UpgradeCancelled.
If the status is ongoing or waiting to start, the operation fails.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCreateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCreateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsCreateMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}
	if r.createUpgradeScheduleRequestModel == nil {
		return nil, reportError("createUpgradeScheduleRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.createUpgradeScheduleRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsDeleteMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	deleteVm *bool
	deleteAccount *MachineCatalogsDeleteMachineCatalogDeleteAccountParameter
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xAccessToken *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// Specifies whether to delete virtual machines that were provisioned in the machine catalog. Only relevant when ProvisioningType is MCS; otherwise, ignored.  Optional; default is &#x60;true&#x60;.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) DeleteVm(deleteVm bool) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.deleteVm = &deleteVm
	return r
}

// Specifies what to do with AD machine accounts that are associated with the machine catalog.  Optional; default is .
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) DeleteAccount(deleteAccount MachineCatalogsDeleteMachineCatalogDeleteAccountParameter) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.deleteAccount = &deleteAccount
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be deleted as a background task. The task will have JobType DeleteMachineCatalog. When the task is complete it will redirect to GetMachineCatalogs. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being deleted, * _Name_ - Name of the machine catalog being deleted.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) Async(async bool) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsDeleteMachineCatalogRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsDeleteMachineCatalogExecute(r)
}

/*
MachineCatalogsDeleteMachineCatalog Delete a machine catalog.

Delete a machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to update.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsDeleteMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsDeleteMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	return ApiMachineCatalogsDeleteMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsDeleteMachineCatalogExecute(r ApiMachineCatalogsDeleteMachineCatalogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsDeleteMachineCatalog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}

	if r.deleteVm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteVm", r.deleteVm, "")
	}
	if r.deleteAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAccount", r.deleteAccount, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsDoMachineCatalogSearchRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	catalogSearchRequestModel *CatalogSearchRequestModel
	async *bool
	limit *int32
	continuationToken *string
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) UserAgent(userAgent string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.userAgent = &userAgent
	return r
}

// Specifies the advanced search parameters.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CatalogSearchRequestModel(catalogSearchRequestModel CatalogSearchRequestModel) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.catalogSearchRequestModel = &catalogSearchRequestModel
	return r
}

// If &#x60;true&#x60;, the catalogs (and associated objects) will be added as a background task. The task will have JobType SearchMachineCatalogs.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Async(async bool) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.async = &async
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Limit(limit int32) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Fields(fields string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Authorization(authorization string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) XActionName(xActionName string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Accept(accept string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Execute() (*CatalogSearchResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsDoMachineCatalogSearchExecute(r)
}

/*
MachineCatalogsDoMachineCatalogSearch Perform an advanced search for machinecatalogs.

Perform an advanced search for machinecatalogs.  Note that some combinations
of search parameters may result in slow performance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMachineCatalogsDoMachineCatalogSearchRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsDoMachineCatalogSearch(ctx context.Context) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	return ApiMachineCatalogsDoMachineCatalogSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CatalogSearchResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsDoMachineCatalogSearchExecute(r ApiMachineCatalogsDoMachineCatalogSearchRequest) (*CatalogSearchResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogSearchResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsDoMachineCatalogSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Machinecatalogs/$search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.catalogSearchRequestModel == nil {
		return localVarReturnValue, nil, reportError("catalogSearchRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.catalogSearchRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	async *bool
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogRequest {
	r.async = &async
	return r
}

// Optional parameters, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsGetMachineCatalogRequest) Fields(fields string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogExecute(r)
}

/*
MachineCatalogsGetMachineCatalog Get details about a single machine catalog.

Get details about a single machine catalog by name or ID of machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogRequest {
	return ApiMachineCatalogsGetMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return MachineCatalogDetailResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogExecute(r ApiMachineCatalogsGetMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	limit *int32
	continuationToken *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.userAgent = &userAgent
	return r
}

// The max number of delivery group associations returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Execute() (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogDeliveryGroupAssociationsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogDeliveryGroupAssociations Get delivery group associations of a machine catalog.

Get delivery group associations by name or Id of a remote pc machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogDeliveryGroupAssociations(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	return ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return DeliveryGroupAssociationResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogDeliveryGroupAssociationsExecute(r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeliveryGroupAssociationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogDeliveryGroupAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/DeliveryGroupAssociations"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Execute() (*VMImageResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogLastMasterImageExecute(r)
}

/*
MachineCatalogsGetMachineCatalogLastMasterImage Get the last master VM images used by the machine catalog.

Get the last master VM images used by the machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogLastMasterImage(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	return ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return VMImageResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogLastMasterImageExecute(r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) (*VMImageResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMImageResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogLastMasterImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/LastMasterImage"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	limit *int32
	continuationToken *string
	async *bool
	accountState *MachineCatalogsGetMachineCatalogMachineAccountsAccountStateParameter
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.userAgent = &userAgent
	return r
}

// The max number of machine accounts returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, the machine accounts will be queried as a background task. The task will have JobType GetMachineCatalogMachineAccounts. When the task is complete it will redirect to GetJobResults.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.async = &async
	return r
}

// The state of accounts for query.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) AccountState(accountState MachineCatalogsGetMachineCatalogMachineAccountsAccountStateParameter) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.accountState = &accountState
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogMachineAccountsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogMachineAccounts Get all machine accounts associated with a machine catalog.

Get all machine accounts associated with a machine catalog.  This returns
all machine accounts for the machine catalog regardless of whether they are
in-use, available, locked, etc.


This is only relevant for machine catalogs where ProvisioningType is MCS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to get machine accounts for.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMachineAccounts(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	return ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return ProvisioningSchemeMachineAccountResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMachineAccountsExecute(r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvisioningSchemeMachineAccountResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogMachineAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MachineAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.accountState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountState", r.accountState, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogMachinesRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	limit *int32
	continuationToken *string
	async *bool
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.userAgent = &userAgent
	return r
}

// The max number of machines returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.async = &async
	return r
}

// Optional parameters, only the specified properties in the fields are required.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Fields(fields string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Execute() (*MachineResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogMachinesExecute(r)
}

/*
MachineCatalogsGetMachineCatalogMachines GET the machines of a catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogMachinesRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	return ApiMachineCatalogsGetMachineCatalogMachinesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return MachineResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMachinesExecute(r ApiMachineCatalogsGetMachineCatalogMachinesRequest) (*MachineResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogMachines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Machines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) Execute() (*VMImageResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogMasterImageHistoryExecute(r)
}

/*
MachineCatalogsGetMachineCatalogMasterImageHistory Get the history of master VM images used by the machine catalog.

Get the history of master VM images used by the machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog.
 @return ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMasterImageHistory(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	return ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return VMImageResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMasterImageHistoryExecute(r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) (*VMImageResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMImageResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogMasterImageHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MasterImageHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	machines *[]string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.userAgent = &userAgent
	return r
}

// The machines to get start menu applications
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Machines(machines []string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.machines = &machines
	return r
}

// If &#x60;true&#x60;, the start menu applications will be queried as a background task. This is recommended as this operation may cause a power action, turning on a machine in order to gather the data. This may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType GetStartMenuApplications. When the task is complete it will redirect to \&quot;JobsControllerTP.GetJobResults(string)\&quot;. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog from which start menu applications are being obtained, * _Name_ - Name of the machine catalog from which start menu applications are being obtained. * _MachineId_ - ID of the machine selected, from which the start menu applications are being obtained; will be present in Parameters only after a machine is selected. * _MachineName_ - Name of the machine selected, from which the start menu applications are being obtained; will be present in Parameters only after a machine is selected.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Execute() (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogStartMenuApplicationsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogStartMenuApplications Get the start menu applications from a machine in the machine catalog.

Get the start menu applications from a machine in the machine catalog

Note that this API may require a machine within a catalog to be
booted, if no machines are currently available.  Therefore the API
may take quite some time to complete.  Consider using the `async=true`
parameter to mitigate this.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogStartMenuApplications(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	return ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return StartMenuApplicationResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogStartMenuApplicationsExecute(r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StartMenuApplicationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogStartMenuApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/StartMenuApplications"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.machines != nil {
		t := *r.machines
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "machines", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "machines", t, "multi")
		}
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogTagsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.userAgent = &userAgent
	return r
}

// Optional parameters, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) Fields(fields string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogTags Get tags associated with a machine catalog.

Get tags associated with a machine catalog.  This includes tags which are
directly associated with the machine catalog, as well as tags associated with
machines that are associated with the machine catalog.
To find only tags directly associated with the machine catalog,
filter the results to those with
NumMachineCatalogs equal to `1`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogTagsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogTags(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	return ApiMachineCatalogsGetMachineCatalogTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return TagResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogTagsExecute(r ApiMachineCatalogsGetMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Tags"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogTestReportRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) Execute() (*TestReportResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogTestReportExecute(r)
}

/*
MachineCatalogsGetMachineCatalogTestReport Get the most recent test report of a machine catalog.

Get the test report from the last run of
TestMachineCatalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogTestReportRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogTestReport(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	return ApiMachineCatalogsGetMachineCatalogTestReportRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return TestReportResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogTestReportExecute(r ApiMachineCatalogsGetMachineCatalogTestReportRequest) (*TestReportResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TestReportResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogTestReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/TestReport"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) Execute() (*MachineCatalogVusComponentResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesExecute(r)
}

/*
MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures Get the components and features of VDAs associated with a machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	return ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return MachineCatalogVusComponentResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesExecute(r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) (*MachineCatalogVusComponentResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogVusComponentResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/VDAComponentsAndFeatures"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	adminFolder *string
	async *bool
	limit *int32
	continuationToken *string
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.userAgent = &userAgent
	return r
}

// Admin folder path or Id.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) AdminFolder(adminFolder string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.adminFolder = &adminFolder
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.async = &async
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Fields(fields string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogsRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogsRequest) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogs Get all machine catalogs.

Get all machine catalogs in the site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMachineCatalogsGetMachineCatalogsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogs(ctx context.Context) ApiMachineCatalogsGetMachineCatalogsRequest {
	return ApiMachineCatalogsGetMachineCatalogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MachineCatalogResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogsExecute(r ApiMachineCatalogsGetMachineCatalogsRequest) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.adminFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adminFolder", r.adminFolder, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) XActionName(xActionName string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) Execute() (*AdministratorResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogsAdministratorsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogsAdministrators Get administrators who can administer a machine catalog.

Get administrators who can administer a machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogsAdministrators(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	return ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return AdministratorResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogsAdministratorsExecute(r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) (*AdministratorResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdministratorResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogsAdministrators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Administrators"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsRebootMachineCatalogMachinesRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	rebootMachinesRequestModel *RebootMachinesRequestModel
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) UserAgent(userAgent string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.userAgent = &userAgent
	return r
}

// Reboot options.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) RebootMachinesRequestModel(rebootMachinesRequestModel RebootMachinesRequestModel) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.rebootMachinesRequestModel = &rebootMachinesRequestModel
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) Authorization(authorization string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) XActionName(xActionName string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) Accept(accept string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRebootMachineCatalogMachinesExecute(r)
}

/*
MachineCatalogsRebootMachineCatalogMachines Reboot all machines in a machine catalog.

Reboot all machines in a machine catalog.


Note that there is no job representation for the reboot operation.
The call returns immediately even though the machines reboot over time.
If you want to follow the progress of the reboot operation, check
the 
property of the machines in the machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsRebootMachineCatalogMachinesRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRebootMachineCatalogMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	return ApiMachineCatalogsRebootMachineCatalogMachinesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRebootMachineCatalogMachinesExecute(r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRebootMachineCatalogMachines")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$RebootMachines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}
	if r.rebootMachinesRequestModel == nil {
		return nil, reportError("rebootMachinesRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.rebootMachinesRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRemoveMachineCatalogMachineRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	machine string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) UserAgent(userAgent string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) Authorization(authorization string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) XActionName(xActionName string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) Accept(accept string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRemoveMachineCatalogMachineExecute(r)
}

/*
MachineCatalogsRemoveMachineCatalogMachine Remove a machine from the machine catalog.

Remove a machine from the machine catalog.  Removing the machine from the machine
catalog removes it from the site.


A machine cannot be removed from the machine catalog if it is a member of a delivery group.


Note: to remove multiple machines in a single call, use the
 API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to remove the machine from.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param machine Machine to remove from the catalog.  May be specified by name, ID, or SID.
 @return ApiMachineCatalogsRemoveMachineCatalogMachineRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogMachine(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	return ApiMachineCatalogsRemoveMachineCatalogMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		machine: machine,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogMachineExecute(r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRemoveMachineCatalogMachine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Machines/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	machine string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	deleteAccount *MachineCatalogsDeleteMachineCatalogDeleteAccountParameter
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) UserAgent(userAgent string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Specifies what to do with the machine account in AD.  Optional; default is None.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) DeleteAccount(deleteAccount MachineCatalogsDeleteMachineCatalogDeleteAccountParameter) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.deleteAccount = &deleteAccount
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) XActionName(xActionName string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) Accept(accept string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRemoveMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsRemoveMachineCatalogMachineAccount Remove a machine account from the machine catalog.

Remove a machine account from the machine catalog. This is only relevant for machine catalogs where ProvisioningType is MCS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to remove the machine account from.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param machine Machine account to remove.  May be specified by SamName, UPN, or SID.
 @return ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		machine: machine,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogMachineAccountExecute(r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRemoveMachineCatalogMachineAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MachineAccounts/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}

	if r.deleteAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAccount", r.deleteAccount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRemoveMachineCatalogTagsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	tagNameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) UserAgent(userAgent string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) XActionName(xActionName string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) Accept(accept string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRemoveMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsRemoveMachineCatalogTags Remove a tag from a machine catalog.

Remove a tag from a machine catalog.  Does not delete the tag,
only its association to the machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param tagNameOrId Name or ID of the tag.
 @return ApiMachineCatalogsRemoveMachineCatalogTagsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	return ApiMachineCatalogsRemoveMachineCatalogTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		tagNameOrId: tagNameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogTagsExecute(r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRemoveMachineCatalogTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Tags/{tagNameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagNameOrId"+"}", url.PathEscape(parameterValueToString(r.tagNameOrId, "tagNameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	force *bool
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) UserAgent(userAgent string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, VDA upgrade schedules existing with all machines within the catalog will be removed except those upgrade status in progressing. If &#x60;false&#x60;, only the perform removing when catalog level schedule not started.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Force(force bool) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.force = &force
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be removed as a background task.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) XActionName(xActionName string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Accept(accept string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRemoveMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsRemoveMachineCatalogUpgradeSchedule Remove a pending VDA upgrade schedule for a machine catalog.

A VDA upgrade schedule can only be cancelled for a machine catalog
when the upgrade status is waiting to start. If the current upgrade is
in another status, the operation fails with HTTP response status 404.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRemoveMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	rebootMachinesRequestModel *RebootMachinesRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) UserAgent(userAgent string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.userAgent = &userAgent
	return r
}

// Details about the image update to be performed.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) RebootMachinesRequestModel(rebootMachinesRequestModel RebootMachinesRequestModel) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.rebootMachinesRequestModel = &rebootMachinesRequestModel
	return r
}

// Due to the long-running nature of the update operation, it cannot complete synchronously, and always initiates an asynchronous job to run to completion.  If the &#x60;async&#x60; parameter is &#x60;true&#x60;, the only difference is that instead of returning the initial job status in the payload, the response is instead &#x60;202&#x60; with the &#x60;Location&#x60; header pointing to the job status API.  This may be desirable for clients that wish to unify their logic for handling asynchronous jobs.  The task will have JobType . When the task is complete it will redirect to . The job&#39;s  will contain properties:   * _Id_ - ID of the machine catalog for which the provisioning scheme is being updated, * _Name_ - Name of the machine catalog for which the provisioning scheme is being updated.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Async(async bool) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Authorization(authorization string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) XActionName(xActionName string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Accept(accept string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsRollbackMachineCatalogProvisioningSchemeExecute(r)
}

/*
MachineCatalogsRollbackMachineCatalogProvisioningScheme Rollback the machine catalog's provisioning scheme.

Rollback the machine catalog's provisioning scheme.


Only valid when the machine catalog's ProvisioningType is MCS.


Provides the ability to roll back the hard disk image used to provision
virtual machines. If the provisioning scheme has CleanOnBoot equal to
`true`, then the next time that virtual machines are started, their
hard disks are updated to this new image. Regardless of CleanOnBoot,
all new virtual machines created after this call succeeds will use this
new hard disk image.


*Note:* The provisioning scheme for a machine catalog cannot be
changed while any provisioning tasks are already executing for the
machine catalog.  Cancel existing provisioning tasks or wait for
their completion before updating the provisioning scheme.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRollbackMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	return ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return JobResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRollbackMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRollbackMachineCatalogProvisioningScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$RollbackProvisioningScheme"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.rebootMachinesRequestModel == nil {
		return localVarReturnValue, nil, reportError("rebootMachinesRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.rebootMachinesRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsSetMachineCatalogTagsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	tagsRequestModel *TagsRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) UserAgent(userAgent string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.userAgent = &userAgent
	return r
}

// Details of the tags to set on the machine catalog.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) TagsRequestModel(tagsRequestModel TagsRequestModel) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.tagsRequestModel = &tagsRequestModel
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) XActionName(xActionName string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) Accept(accept string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsSetMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsSetMachineCatalogTags Set tags associated with a machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsSetMachineCatalogTagsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsSetMachineCatalogTags(ctx context.Context, nameOrId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	return ApiMachineCatalogsSetMachineCatalogTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsSetMachineCatalogTagsExecute(r ApiMachineCatalogsSetMachineCatalogTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsSetMachineCatalogTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Tags"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}
	if r.tagsRequestModel == nil {
		return nil, reportError("tagsRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.tagsRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTestMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsTestMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsTestMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsTestMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, the tests will run as a background task. This is recommended as the tests may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType TestMachineCatalog. When the task is complete it will redirect to GetJobResults. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being tested, * _Name_ - Name of the machine catalog being tested.
func (r ApiMachineCatalogsTestMachineCatalogRequest) Async(async bool) ApiMachineCatalogsTestMachineCatalogRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsTestMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTestMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTestMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsTestMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsTestMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsTestMachineCatalogRequest) Execute() (*MachineCatalogTestResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTestMachineCatalogExecute(r)
}

/*
MachineCatalogsTestMachineCatalog Run tests on a machine catalog and create a test report.

Run tests on a machine catalog and create a test report.  Obtain the
most recent report from
GetMachineCatalogTestReport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to test.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsTestMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsTestMachineCatalogRequest {
	return ApiMachineCatalogsTestMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return MachineCatalogTestResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestMachineCatalogExecute(r ApiMachineCatalogsTestMachineCatalogRequest) (*MachineCatalogTestResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogTestResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsTestMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$test"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTestMachineCatalogExistsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	catalogNameCheckRequestModel *CatalogNameCheckRequestModel
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) UserAgent(userAgent string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Name of the machine catalog.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CatalogNameCheckRequestModel(catalogNameCheckRequestModel CatalogNameCheckRequestModel) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.catalogNameCheckRequestModel = &catalogNameCheckRequestModel
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) Authorization(authorization string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) XActionName(xActionName string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) Accept(accept string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTestMachineCatalogExistsExecute(r)
}

/*
MachineCatalogsTestMachineCatalogExists Test the existence of a machine catalog by name.

Check for the existence of a machine catalog by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMachineCatalogsTestMachineCatalogExistsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestMachineCatalogExists(ctx context.Context) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	return ApiMachineCatalogsTestMachineCatalogExistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestMachineCatalogExistsExecute(r ApiMachineCatalogsTestMachineCatalogExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsTestMachineCatalogExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/$checkCatalogName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}
	if r.catalogNameCheckRequestModel == nil {
		return nil, reportError("catalogNameCheckRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.catalogNameCheckRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	remotePCEnrollmentScopeCheckModel *RemotePCEnrollmentScopeCheckModel
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) UserAgent(userAgent string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Request model that contains distinguished name of an OU containing machines allowed to enroll as remote PCs.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) RemotePCEnrollmentScopeCheckModel(remotePCEnrollmentScopeCheckModel RemotePCEnrollmentScopeCheckModel) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.remotePCEnrollmentScopeCheckModel = &remotePCEnrollmentScopeCheckModel
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) Authorization(authorization string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) XActionName(xActionName string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) Accept(accept string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTestRemotePCEnrollmentScopeExistsExecute(r)
}

/*
MachineCatalogsTestRemotePCEnrollmentScopeExists Check for the existence of a RemotePC enrollment scope by name in the request body. Use HttpPost and take name in body as this name may be very long, and cause url too long exception.

Check for the existence of a RemotePC enrollment scope by name. Note that
RemotePC enrollment scope names must be unique within the site, so the
`nameOrId` parameter does not affect whether the RemotePC enrollment scope
name is found.
If the name is found to be available, this returns 404 Not Found.
If a RemotePC enrollment scope by that name exists and is associated with the
specified machine catalog, this returns 204 No Content. If a RemotePC
enrollment scope by that name exists and is associated with a different
machine catalog, this returns 303 See Other, and the `Location`
response header refers to location of the machine catalog which is associated
by the RemotePC enrollment scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	return ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsTestRemotePCEnrollmentScopeExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/RemotePCEnrollmentScopes/$checkScopeName"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}
	if r.remotePCEnrollmentScopeCheckModel == nil {
		return nil, reportError("remotePCEnrollmentScopeCheckModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.remotePCEnrollmentScopeCheckModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsUpdateMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	updateMachineCatalogRequestModel *UpdateMachineCatalogRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xAccessToken *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// Properties of the machine catalog to update.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) UpdateMachineCatalogRequestModel(updateMachineCatalogRequestModel UpdateMachineCatalogRequestModel) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.updateMachineCatalogRequestModel = &updateMachineCatalogRequestModel
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be updated as a background task. The task will have JobType UpdateMachineCatalog. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being updated, * _Name_ - Name of the machine catalog being updated.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) Async(async bool) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) XActionName(xActionName string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsUpdateMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsUpdateMachineCatalogExecute(r)
}

/*
MachineCatalogsUpdateMachineCatalog Update a machine catalog.

Update a machine catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog to update.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsUpdateMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	return ApiMachineCatalogsUpdateMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return MachineCatalogDetailResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogExecute(r ApiMachineCatalogsUpdateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsUpdateMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.updateMachineCatalogRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateMachineCatalogRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.updateMachineCatalogRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	machine string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	updateMachineAccountRequestModel *UpdateMachineAccountRequestModel
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) UserAgent(userAgent string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.userAgent = &userAgent
	return r
}

// New details for the machine account record.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) UpdateMachineAccountRequestModel(updateMachineAccountRequestModel UpdateMachineAccountRequestModel) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.updateMachineAccountRequestModel = &updateMachineAccountRequestModel
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) XActionName(xActionName string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) Accept(accept string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsUpdateMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsUpdateMachineCatalogMachineAccount Update a machine account within the machine catalog.

Update a machine account within the machine catalog.  This is typically used to reset or
update the machine password so that the site is able to apply the machine account to a
provisioned VM.


This is only relevant for machine catalogs where ProvisioningType is MCS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog containing the machine account.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @param machine Machine account to update.  May be specified by SamName, UPN, or SID.
 @return ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		machine: machine,
	}
}

// Execute executes the request
//  @return ProvisioningSchemeMachineAccountResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogMachineAccountExecute(r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvisioningSchemeMachineAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsUpdateMachineCatalogMachineAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MachineAccounts/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.updateMachineAccountRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateMachineAccountRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.updateMachineAccountRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	updateMachineCatalogProvisioningSchemeRequestModel *UpdateMachineCatalogProvisioningSchemeRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) UserAgent(userAgent string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.userAgent = &userAgent
	return r
}

// Details about the image update to be performed.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) UpdateMachineCatalogProvisioningSchemeRequestModel(updateMachineCatalogProvisioningSchemeRequestModel UpdateMachineCatalogProvisioningSchemeRequestModel) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.updateMachineCatalogProvisioningSchemeRequestModel = &updateMachineCatalogProvisioningSchemeRequestModel
	return r
}

// Due to the long-running nature of the update operation, it cannot complete synchronously, and always initiates an asynchronous job to run to completion.  If the &#x60;async&#x60; parameter is &#x60;true&#x60;, the only difference is that instead of returning the initial job status in the payload, the response is instead &#x60;202&#x60; with the &#x60;Location&#x60; header pointing to the job status API.  This may be desirable for clients that wish to unify their logic for handling asynchronous jobs.  The task will have JobType . When the task is complete it will redirect to . The job&#39;s  will contain properties:   * _Id_ - ID of the machine catalog for which the provisioning scheme is being updated, * _Name_ - Name of the machine catalog for which the provisioning scheme is being updated, * _MasterImageXDPath_ - Path to the new image specified for the provisioning scheme, in XenApp &amp; XenDesktop path format. * _MasterImageFullPath_ - Path to the new image specified for the provisioning scheme, relative to the root of the API. * _MasterImageRelativePath_ - Path to the new image specified for the provisioning scheme, relative to the resource pool.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Async(async bool) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Authorization(authorization string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) XActionName(xActionName string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Accept(accept string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsUpdateMachineCatalogProvisioningSchemeExecute(r)
}

/*
MachineCatalogsUpdateMachineCatalogProvisioningScheme Update the machine catalog's provisioning scheme.

Update the machine catalog's provisioning scheme.


Only valid when the machine catalog's ProvisioningType is MCS.


Provides the ability to update the hard disk image used to provision
virtual machines. If the provisioning scheme has CleanOnBoot equal to
`true`, then the next time that virtual machines are started, their
hard disks are updated to this new image. Regardless of CleanOnBoot,
all new virtual machines created after this call succeeds will use this
new hard disk image.


A snapshot or VM template is used rather than a VM, so that the
content of the hard disk for the provisioning scheme can be easily
determined.


The previous hard disk image path is stored into the history (see
).  The
data stored in the history allows for a rollback to be undertaken,
to revert to the previous hard disk image if required.


*Note:* The provisioning scheme for a machine catalog cannot be
changed while any provisioning tasks are already executing for the
machine catalog.  Cancel existing provisioning tasks or wait for
their completion before updating the provisioning scheme.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	return ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return JobResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsUpdateMachineCatalogProvisioningScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$UpdateProvisioningScheme"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.updateMachineCatalogProvisioningSchemeRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateMachineCatalogProvisioningSchemeRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.updateMachineCatalogProvisioningSchemeRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	updateUpgradeScheduleRequestModel *UpdateUpgradeScheduleRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) UserAgent(userAgent string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.userAgent = &userAgent
	return r
}

// Details about the updated VDA upgrade schedule.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) UpdateUpgradeScheduleRequestModel(updateUpgradeScheduleRequestModel UpdateUpgradeScheduleRequestModel) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.updateUpgradeScheduleRequestModel = &updateUpgradeScheduleRequestModel
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be updated as a background task.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) XActionName(xActionName string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Accept(accept string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsUpdateMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsUpdateMachineCatalogUpgradeSchedule Reschedule a pending VDA upgrade schedule for a machine catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsUpdateMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return nil, reportError("userAgent is required and must be specified")
	}
	if r.updateUpgradeScheduleRequestModel == nil {
		return nil, reportError("updateUpgradeScheduleRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.updateUpgradeScheduleRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest struct {
	ctx context.Context
	ApiService *MachineCatalogsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	vDAComponentsSelectionValidationRequestModel *VDAComponentsSelectionValidationRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) UserAgent(userAgent string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.userAgent = &userAgent
	return r
}

// More details attached to this validation.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) VDAComponentsSelectionValidationRequestModel(vDAComponentsSelectionValidationRequestModel VDAComponentsSelectionValidationRequestModel) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.vDAComponentsSelectionValidationRequestModel = &vDAComponentsSelectionValidationRequestModel
	return r
}

// If async execute.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Async(async bool) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Authorization(authorization string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) XActionName(xActionName string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Accept(accept string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Execute() (*VDAComponentsSelectionValidationResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute(r)
}

/*
MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection Validate the VDA component selection at catalog level that can be Included/Excluded and features that need enable during an VDA upgrade using VDA Upgrade Service.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
 @return ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection(ctx context.Context, nameOrId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	return ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return VDAComponentsSelectionValidationResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute(r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) (*VDAComponentsSelectionValidationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VDAComponentsSelectionValidationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/VDAComponentsAndFeatures/$validate"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}
	if r.vDAComponentsSelectionValidationRequestModel == nil {
		return localVarReturnValue, nil, reportError("vDAComponentsSelectionValidationRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	// body params
	localVarPostBody = r.vDAComponentsSelectionValidationRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
