/*
Citrix Virtual Apps and Desktops Rest API for Developer Portal

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: devportal-onprem-ga
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"

	"github.com/stretchr/testify/mock"
)

type MachineCatalogsAPIsDAAS interface {

	/*
			MachineCatalogsAddMachineCatalogMachine Add machine to the machine catalog.

			Add a machine to the machine catalog.  This is the first step in making the
		machine available to run users' desktops and applications. The machine may
		be physical or virtual.  The type of machine (physical or virtual) must
		match the machine catalog configuration.


		Note that due to
		the long-running nature of the adding operation, it cannot
		complete synchronously, would always initiate an asynchronous job to
		run to completion.


		The machine must support the expected capabilities of the machine catalog:
		the  and
		. The session
		support of the machine is determined by the type of Citrix VDA software
		installed (server or workstation) and the functional level depends on the
		version of the Citrix VDA software installed.  The API will complete
		successfully if these are not correct but the machine will be unable to register.


		Note: to add multiple machines in a single call, use the
		 API.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog to add machine to.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsAddMachineCatalogMachineRequest
	*/
	MachineCatalogsAddMachineCatalogMachine(ctx context.Context, nameOrId string) ApiMachineCatalogsAddMachineCatalogMachineRequest

	// MachineCatalogsAddMachineCatalogMachineExecute executes the request
	//  @return JobResponseModel
	MachineCatalogsAddMachineCatalogMachineExecute(r ApiMachineCatalogsAddMachineCatalogMachineRequest) (*JobResponseModel, *http.Response, error)

	/*
		MachineCatalogsAddMachineCatalogMachineAccount Add a machine account to the machine catalog.

		Add a machine account to the machine catalog. This is only relevant for machine catalogs where ProvisioningType is MCS.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog to add the machine account to.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsAddMachineCatalogMachineAccountRequest
	*/
	MachineCatalogsAddMachineCatalogMachineAccount(ctx context.Context, nameOrId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest

	// MachineCatalogsAddMachineCatalogMachineAccountExecute executes the request
	//  @return ProvisioningSchemeMachineAccountResponseModel
	MachineCatalogsAddMachineCatalogMachineAccountExecute(r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error)

	/*
		MachineCatalogsAddMachineCatalogTags Add a tag to a machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@param tagNameOrId Name or ID of the tag to add.
		@return ApiMachineCatalogsAddMachineCatalogTagsRequest
	*/
	MachineCatalogsAddMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string) ApiMachineCatalogsAddMachineCatalogTagsRequest

	// MachineCatalogsAddMachineCatalogTagsExecute executes the request
	//  @return TagResponseModelCollection
	MachineCatalogsAddMachineCatalogTagsExecute(r ApiMachineCatalogsAddMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsCheckMachineCatalogExists Check for the existence of a machine catalog by name.

		Check for the existence of a machine catalog by name

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param name Name of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsCheckMachineCatalogExistsRequest
	*/
	MachineCatalogsCheckMachineCatalogExists(ctx context.Context, name string) ApiMachineCatalogsCheckMachineCatalogExistsRequest

	// MachineCatalogsCheckMachineCatalogExistsExecute executes the request
	MachineCatalogsCheckMachineCatalogExistsExecute(r ApiMachineCatalogsCheckMachineCatalogExistsRequest) (*http.Response, error)

	/*
			MachineCatalogsCheckRemotePCEnrollmentScopeExists Check for the existence of a RemotePC enrollment scope by name.

			Check for the existence of a RemotePC enrollment scope by name. Note that
		RemotePC enrollment scope names must be unique within the site, so the
		`nameOrId` parameter does not affect whether the RemotePC enrollment scope
		name is found.
		If the name is found to be available, this returns 404 Not Found.
		If a RemotePC enrollment scope by that name exists and is associated with the
		specified machine catalog, this returns 204 No Content. If a RemotePC
		enrollment scope by that name exists and is associated with a different
		machine catalog, this returns 303 See Other, and the `Location`
		response header refers to location of the machine catalog which is associated
		by the RemotePC enrollment scope.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@param name Distinguished name of an OU containing machines allowed to enroll as remote PCs.
			@return ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest
	*/
	MachineCatalogsCheckRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string, name string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest

	// MachineCatalogsCheckRemotePCEnrollmentScopeExistsExecute executes the request
	MachineCatalogsCheckRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) (*http.Response, error)

	/*
			MachineCatalogsCreateMachineCatalog Create a machine catalog.

			Create a machine catalog.

		Note that if a machine catalog uses
		of , the machine catalog creation will always invoke asynchronous
		job(s) for the provisioning action.  If this API is invoked asynchronously, the asynchronous job
		will include only the machine catalog creation, and the provisioning task(s) will be associated
		with the newly created catalog.  If this API is invoked synchronously, the machine catalog
		creation will complete synchronously but the provisioning task(s) may still be executing, and
		will be associated with the newly created catalog.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiMachineCatalogsCreateMachineCatalogRequest
	*/
	MachineCatalogsCreateMachineCatalog(ctx context.Context) ApiMachineCatalogsCreateMachineCatalogRequest

	// MachineCatalogsCreateMachineCatalogExecute executes the request
	//  @return MachineCatalogDetailResponseModel
	MachineCatalogsCreateMachineCatalogExecute(r ApiMachineCatalogsCreateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error)

	/*
			MachineCatalogsCreateMachineCatalogUpgradeSchedule Setup a new VDA upgrade schedule for a machine catalog.

			A new VDA upgrade schedule can only be created for a machine catalog
		when the upgrade status for the catalog is UpgradeSuccessful, UpgradeFailed or UpgradeCancelled.
		If the status is ongoing or waiting to start, the operation fails.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest
	*/
	MachineCatalogsCreateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest

	// MachineCatalogsCreateMachineCatalogUpgradeScheduleExecute executes the request
	MachineCatalogsCreateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) (*http.Response, error)

	/*
		MachineCatalogsDeleteMachineCatalog Delete a machine catalog.

		Delete a machine catalog

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog to update.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsDeleteMachineCatalogRequest
	*/
	MachineCatalogsDeleteMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsDeleteMachineCatalogRequest

	// MachineCatalogsDeleteMachineCatalogExecute executes the request
	MachineCatalogsDeleteMachineCatalogExecute(r ApiMachineCatalogsDeleteMachineCatalogRequest) (*http.Response, error)

	/*
			MachineCatalogsDoMachineCatalogSearch Perform an advanced search for machinecatalogs.

			Perform an advanced search for machinecatalogs.  Note that some combinations
		of search parameters may result in slow performance.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiMachineCatalogsDoMachineCatalogSearchRequest
	*/
	MachineCatalogsDoMachineCatalogSearch(ctx context.Context) ApiMachineCatalogsDoMachineCatalogSearchRequest

	// MachineCatalogsDoMachineCatalogSearchExecute executes the request
	//  @return CatalogSearchResponseModelCollection
	MachineCatalogsDoMachineCatalogSearchExecute(r ApiMachineCatalogsDoMachineCatalogSearchRequest) (*CatalogSearchResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsExport Exports a MCS machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId The machine catalog
		@return ApiMachineCatalogsExportRequest
	*/
	MachineCatalogsExport(ctx context.Context, nameOrId string) ApiMachineCatalogsExportRequest

	// MachineCatalogsExportExecute executes the request
	//  @return ExportMachineCatalogResponseModel
	MachineCatalogsExportExecute(r ApiMachineCatalogsExportRequest) (*ExportMachineCatalogResponseModel, *http.Response, error)

	/*
		MachineCatalogsExportMachineProfile Exports a MCS machine catalog's machine profile.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId The name or id of machine catalog.
		@return ApiMachineCatalogsExportMachineProfileRequest
	*/
	MachineCatalogsExportMachineProfile(ctx context.Context, nameOrId string) ApiMachineCatalogsExportMachineProfileRequest

	// MachineCatalogsExportMachineProfileExecute executes the request
	//  @return ExportMachineProfileResponseModel
	MachineCatalogsExportMachineProfileExecute(r ApiMachineCatalogsExportMachineProfileRequest) (*ExportMachineProfileResponseModel, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalog Get details about a single machine catalog.

		Get details about a single machine catalog by name or ID of machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsGetMachineCatalogRequest
	*/
	MachineCatalogsGetMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogRequest

	// MachineCatalogsGetMachineCatalogExecute executes the request
	//  @return MachineCatalogDetailResponseModel
	MachineCatalogsGetMachineCatalogExecute(r ApiMachineCatalogsGetMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogCostSummary Get the machine catalog's cost summary.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId The name or ID of the machine catalog.
		@return ApiMachineCatalogsGetMachineCatalogCostSummaryRequest
	*/
	MachineCatalogsGetMachineCatalogCostSummary(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest

	// MachineCatalogsGetMachineCatalogCostSummaryExecute executes the request
	//  @return ResourceCostResponseModelCollection
	MachineCatalogsGetMachineCatalogCostSummaryExecute(r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) (*ResourceCostResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogDailyCost Get the machine catalog's daily cost.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId The name or ID of the machine catalog.
		@return ApiMachineCatalogsGetMachineCatalogDailyCostRequest
	*/
	MachineCatalogsGetMachineCatalogDailyCost(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest

	// MachineCatalogsGetMachineCatalogDailyCostExecute executes the request
	//  @return DailyCostResponseModelCollection
	MachineCatalogsGetMachineCatalogDailyCostExecute(r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) (*DailyCostResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogDeliveryGroupAssociations Get delivery group associations of a machine catalog.

		Get delivery group associations by name or Id of a remote pc machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest
	*/
	MachineCatalogsGetMachineCatalogDeliveryGroupAssociations(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest

	// MachineCatalogsGetMachineCatalogDeliveryGroupAssociationsExecute executes the request
	//  @return DeliveryGroupAssociationResponseModelCollection
	MachineCatalogsGetMachineCatalogDeliveryGroupAssociationsExecute(r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogEnrollments Get the list of enrollments in the machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog.
		@return ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest
	*/
	MachineCatalogsGetMachineCatalogEnrollments(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest

	// MachineCatalogsGetMachineCatalogEnrollmentsExecute executes the request
	//  @return EnrollmentResponseModelCollection
	MachineCatalogsGetMachineCatalogEnrollmentsExecute(r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) (*EnrollmentResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogLastMasterImage Get the last master VM images used by the machine catalog.

		Get the last master VM images used by the machine catalog

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest
	*/
	MachineCatalogsGetMachineCatalogLastMasterImage(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest

	// MachineCatalogsGetMachineCatalogLastMasterImageExecute executes the request
	//  @return VMImageResponseModel
	MachineCatalogsGetMachineCatalogLastMasterImageExecute(r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) (*VMImageResponseModel, *http.Response, error)

	/*
			MachineCatalogsGetMachineCatalogMachineAccounts Get all machine accounts associated with a machine catalog.

			Get all machine accounts associated with a machine catalog.  This returns
		all machine accounts for the machine catalog regardless of whether they are
		in-use, available, locked, etc.


		This is only relevant for machine catalogs where ProvisioningType is MCS.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog to get machine accounts for.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest
	*/
	MachineCatalogsGetMachineCatalogMachineAccounts(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest

	// MachineCatalogsGetMachineCatalogMachineAccountsExecute executes the request
	//  @return ProvisioningSchemeMachineAccountResponseModelCollection
	MachineCatalogsGetMachineCatalogMachineAccountsExecute(r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogMachines GET the machines of a catalog

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsGetMachineCatalogMachinesRequest
	*/
	MachineCatalogsGetMachineCatalogMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest

	// MachineCatalogsGetMachineCatalogMachinesExecute executes the request
	//  @return MachineResponseModelCollection
	MachineCatalogsGetMachineCatalogMachinesExecute(r ApiMachineCatalogsGetMachineCatalogMachinesRequest) (*MachineResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogMasterImageHistory Get the history of master VM images used by the machine catalog.

		Get the history of master VM images used by the machine catalog

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog.
		@return ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest
	*/
	MachineCatalogsGetMachineCatalogMasterImageHistory(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest

	// MachineCatalogsGetMachineCatalogMasterImageHistoryExecute executes the request
	//  @return VMImageResponseModelCollection
	MachineCatalogsGetMachineCatalogMasterImageHistoryExecute(r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) (*VMImageResponseModelCollection, *http.Response, error)

	/*
			MachineCatalogsGetMachineCatalogStartMenuApplications Get the start menu applications from a machine in the machine catalog.

			Get the start menu applications from a machine in the machine catalog

		Note that this API may require a machine within a catalog to be
		booted, if no machines are currently available.  Therefore the API
		may take quite some time to complete.  Consider using the `async=true`
		parameter to mitigate this.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest
	*/
	MachineCatalogsGetMachineCatalogStartMenuApplications(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest

	// MachineCatalogsGetMachineCatalogStartMenuApplicationsExecute executes the request
	//  @return StartMenuApplicationResponseModelCollection
	MachineCatalogsGetMachineCatalogStartMenuApplicationsExecute(r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) (*StartMenuApplicationResponseModelCollection, *http.Response, error)

	/*
			MachineCatalogsGetMachineCatalogTags Get tags associated with a machine catalog.

			Get tags associated with a machine catalog.  This includes tags which are
		directly associated with the machine catalog, as well as tags associated with
		machines that are associated with the machine catalog.
		To find only tags directly associated with the machine catalog,
		filter the results to those with
		NumMachineCatalogs equal to `1`.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsGetMachineCatalogTagsRequest
	*/
	MachineCatalogsGetMachineCatalogTags(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogTagsRequest

	// MachineCatalogsGetMachineCatalogTagsExecute executes the request
	//  @return TagResponseModelCollection
	MachineCatalogsGetMachineCatalogTagsExecute(r ApiMachineCatalogsGetMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error)

	/*
			MachineCatalogsGetMachineCatalogTestReport Get the most recent test report of a machine catalog.

			Get the test report from the last run of
		TestMachineCatalog.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsGetMachineCatalogTestReportRequest
	*/
	MachineCatalogsGetMachineCatalogTestReport(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest

	// MachineCatalogsGetMachineCatalogTestReportExecute executes the request
	//  @return TestReportResponseModel
	MachineCatalogsGetMachineCatalogTestReportExecute(r ApiMachineCatalogsGetMachineCatalogTestReportRequest) (*TestReportResponseModel, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures Get the components and features of VDAs associated with a machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest
	*/
	MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest

	// MachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesExecute executes the request
	//  @return MachineCatalogVusComponentResponseModel
	MachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesExecute(r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) (*MachineCatalogVusComponentResponseModel, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogVDAUpgradeVersions Get the available VDA upgrade versions associated with a machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest
	*/
	MachineCatalogsGetMachineCatalogVDAUpgradeVersions(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest

	// MachineCatalogsGetMachineCatalogVDAUpgradeVersionsExecute executes the request
	//  @return []string
	MachineCatalogsGetMachineCatalogVDAUpgradeVersionsExecute(r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) ([]string, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogs Get all machine catalogs.

		Get all machine catalogs in the site.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiMachineCatalogsGetMachineCatalogsRequest
	*/
	MachineCatalogsGetMachineCatalogs(ctx context.Context) ApiMachineCatalogsGetMachineCatalogsRequest

	// MachineCatalogsGetMachineCatalogsExecute executes the request
	//  @return MachineCatalogResponseModelCollection
	MachineCatalogsGetMachineCatalogsExecute(r ApiMachineCatalogsGetMachineCatalogsRequest) (*MachineCatalogResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogsAdministrators Get administrators who can administer a machine catalog.

		Get administrators who can administer a machine catalog

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest
	*/
	MachineCatalogsGetMachineCatalogsAdministrators(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest

	// MachineCatalogsGetMachineCatalogsAdministratorsExecute executes the request
	//  @return AdministratorResponseModelCollection
	MachineCatalogsGetMachineCatalogsAdministratorsExecute(r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) (*AdministratorResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsGetMachineCatalogsV2 The V2  version of get all machine catalogs.

		Get all machine catalogs in the site with default response fields if no fields parameters specified.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiMachineCatalogsGetMachineCatalogsV2Request
	*/
	MachineCatalogsGetMachineCatalogsV2(ctx context.Context) ApiMachineCatalogsGetMachineCatalogsV2Request

	// MachineCatalogsGetMachineCatalogsV2Execute executes the request
	//  @return MachineCatalogResponseModelCollection
	MachineCatalogsGetMachineCatalogsV2Execute(r ApiMachineCatalogsGetMachineCatalogsV2Request) (*MachineCatalogResponseModelCollection, *http.Response, error)

	/*
		MachineCatalogsImportProvisionedVirtualMachines Import existing provisioned virtual machines.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId The machineCatalog name or Id.
		@return ApiMachineCatalogsImportProvisionedVirtualMachinesRequest
	*/
	MachineCatalogsImportProvisionedVirtualMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest

	// MachineCatalogsImportProvisionedVirtualMachinesExecute executes the request
	//  @return ImportProvisionedVirtualMachineResponseModelCollection
	MachineCatalogsImportProvisionedVirtualMachinesExecute(r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) (*ImportProvisionedVirtualMachineResponseModelCollection, *http.Response, error)

	/*
			MachineCatalogsRebootMachineCatalogMachines Reboot all machines in a machine catalog.

			Reboot all machines in a machine catalog.


		Note that there is no job representation for the reboot operation.
		The call returns immediately even though the machines reboot over time.
		If you want to follow the progress of the reboot operation, check
		the
		property of the machines in the machine catalog.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsRebootMachineCatalogMachinesRequest
	*/
	MachineCatalogsRebootMachineCatalogMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest

	// MachineCatalogsRebootMachineCatalogMachinesExecute executes the request
	MachineCatalogsRebootMachineCatalogMachinesExecute(r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) (*http.Response, error)

	/*
			MachineCatalogsRemoveMachineCatalogMachine Remove a machine from the machine catalog.

			Remove a machine from the machine catalog.  Removing the machine from the machine
		catalog removes it from the site.


		A machine cannot be removed from the machine catalog if it is a member of a delivery group.


		Note: to remove multiple machines in a single call, use the
		 API.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog to remove the machine from.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@param machine Machine to remove from the catalog. May be specified by name, ID, or SID. If param is Name, currently it should get rid of '\\\\' and replace it using '|'.             For instance, if a MachineName is \"DomainA\\NameB\", the param will be \"DomainA|NameB\".
			@return ApiMachineCatalogsRemoveMachineCatalogMachineRequest
	*/
	MachineCatalogsRemoveMachineCatalogMachine(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest

	// MachineCatalogsRemoveMachineCatalogMachineExecute executes the request
	MachineCatalogsRemoveMachineCatalogMachineExecute(r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) (*http.Response, error)

	/*
		MachineCatalogsRemoveMachineCatalogMachineAccount Remove a machine account from the machine catalog.

		Remove a machine account from the machine catalog. This is only relevant for machine catalogs where ProvisioningType is MCS.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog to remove the machine account from.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@param machine Machine account to remove.  May be specified by SamName, UPN, or SID.
		@return ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest
	*/
	MachineCatalogsRemoveMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest

	// MachineCatalogsRemoveMachineCatalogMachineAccountExecute executes the request
	MachineCatalogsRemoveMachineCatalogMachineAccountExecute(r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) (*http.Response, error)

	/*
			MachineCatalogsRemoveMachineCatalogTags Remove a tag from a machine catalog.

			Remove a tag from a machine catalog.  Does not delete the tag,
		only its association to the machine catalog.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@param tagNameOrId Name or ID of the tag.
			@return ApiMachineCatalogsRemoveMachineCatalogTagsRequest
	*/
	MachineCatalogsRemoveMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest

	// MachineCatalogsRemoveMachineCatalogTagsExecute executes the request
	MachineCatalogsRemoveMachineCatalogTagsExecute(r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) (*http.Response, error)

	/*
			MachineCatalogsRemoveMachineCatalogUpgradeSchedule Remove a pending VDA upgrade schedule for a machine catalog.

			A VDA upgrade schedule can only be cancelled for a machine catalog
		when the upgrade status is waiting to start. If the current upgrade is
		in another status, the operation fails with HTTP response status 404.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest
	*/
	MachineCatalogsRemoveMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest

	// MachineCatalogsRemoveMachineCatalogUpgradeScheduleExecute executes the request
	MachineCatalogsRemoveMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) (*http.Response, error)

	/*
		MachineCatalogsRepairMachineCatalogMachineAccounts Repair all machine accounts in a machine catalog.

		Repair all machine accounts in a machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog.
		@return ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest
	*/
	MachineCatalogsRepairMachineCatalogMachineAccounts(ctx context.Context, nameOrId string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest

	// MachineCatalogsRepairMachineCatalogMachineAccountsExecute executes the request
	MachineCatalogsRepairMachineCatalogMachineAccountsExecute(r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) (*http.Response, error)

	/*
			MachineCatalogsRollbackMachineCatalogProvisioningScheme Rollback the machine catalog's provisioning scheme.

			Rollback the machine catalog's provisioning scheme.


		Only valid when the machine catalog's ProvisioningType is MCS.


		Provides the ability to roll back the hard disk image used to provision
		virtual machines. If the provisioning scheme has CleanOnBoot equal to
		`true`, then the next time that virtual machines are started, their
		hard disks are updated to this new image. Regardless of CleanOnBoot,
		all new virtual machines created after this call succeeds will use this
		new hard disk image.


		*Note:* The provisioning scheme for a machine catalog cannot be
		changed while any provisioning tasks are already executing for the
		machine catalog.  Cancel existing provisioning tasks or wait for
		their completion before updating the provisioning scheme.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest
	*/
	MachineCatalogsRollbackMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest

	// MachineCatalogsRollbackMachineCatalogProvisioningSchemeExecute executes the request
	//  @return JobResponseModel
	MachineCatalogsRollbackMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error)

	/*
		MachineCatalogsSetMachineCatalogTags Set tags associated with a machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsSetMachineCatalogTagsRequest
	*/
	MachineCatalogsSetMachineCatalogTags(ctx context.Context, nameOrId string) ApiMachineCatalogsSetMachineCatalogTagsRequest

	// MachineCatalogsSetMachineCatalogTagsExecute executes the request
	MachineCatalogsSetMachineCatalogTagsExecute(r ApiMachineCatalogsSetMachineCatalogTagsRequest) (*http.Response, error)

	/*
			MachineCatalogsTestMachineCatalog Run tests on a machine catalog and create a test report.

			Run tests on a machine catalog and create a test report.  Obtain the
		most recent report from
		GetMachineCatalogTestReport.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog to test.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsTestMachineCatalogRequest
	*/
	MachineCatalogsTestMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsTestMachineCatalogRequest

	// MachineCatalogsTestMachineCatalogExecute executes the request
	//  @return MachineCatalogTestResponseModel
	MachineCatalogsTestMachineCatalogExecute(r ApiMachineCatalogsTestMachineCatalogRequest) (*MachineCatalogTestResponseModel, *http.Response, error)

	/*
		MachineCatalogsTestMachineCatalogExists Test the existence of a machine catalog by name.

		Check for the existence of a machine catalog by name

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiMachineCatalogsTestMachineCatalogExistsRequest
	*/
	MachineCatalogsTestMachineCatalogExists(ctx context.Context) ApiMachineCatalogsTestMachineCatalogExistsRequest

	// MachineCatalogsTestMachineCatalogExistsExecute executes the request
	MachineCatalogsTestMachineCatalogExistsExecute(r ApiMachineCatalogsTestMachineCatalogExistsRequest) (*http.Response, error)

	/*
			MachineCatalogsTestRemotePCEnrollmentScopeExists Check for the existence of a RemotePC enrollment scope by name in the request body. Use HttpPost and take name in body as this name may be very long, and cause url too long exception.

			Check for the existence of a RemotePC enrollment scope by name. Note that
		RemotePC enrollment scope names must be unique within the site, so the
		`nameOrId` parameter does not affect whether the RemotePC enrollment scope
		name is found.
		If the name is found to be available, this returns 404 Not Found.
		If a RemotePC enrollment scope by that name exists and is associated with the
		specified machine catalog, this returns 204 No Content. If a RemotePC
		enrollment scope by that name exists and is associated with a different
		machine catalog, this returns 303 See Other, and the `Location`
		response header refers to location of the machine catalog which is associated
		by the RemotePC enrollment scope.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest
	*/
	MachineCatalogsTestRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest

	// MachineCatalogsTestRemotePCEnrollmentScopeExistsExecute executes the request
	MachineCatalogsTestRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) (*http.Response, error)

	/*
		MachineCatalogsUpdateMachineCatalog Update a machine catalog.

		Update a machine catalog

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog to update.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsUpdateMachineCatalogRequest
	*/
	MachineCatalogsUpdateMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogRequest

	// MachineCatalogsUpdateMachineCatalogExecute executes the request
	//  @return MachineCatalogDetailResponseModel
	MachineCatalogsUpdateMachineCatalogExecute(r ApiMachineCatalogsUpdateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error)

	/*
			MachineCatalogsUpdateMachineCatalogMachineAccount Update a machine account within the machine catalog.

			Update a machine account within the machine catalog.  This is typically used to reset or
		update the machine password so that the site is able to apply the machine account to a
		provisioned VM.


		This is only relevant for machine catalogs where ProvisioningType is MCS.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog containing the machine account.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@param machine Machine account to update.  May be specified by SamName, UPN, or SID.
			@return ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest
	*/
	MachineCatalogsUpdateMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest

	// MachineCatalogsUpdateMachineCatalogMachineAccountExecute executes the request
	//  @return ProvisioningSchemeMachineAccountResponseModel
	MachineCatalogsUpdateMachineCatalogMachineAccountExecute(r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error)

	/*
			MachineCatalogsUpdateMachineCatalogProvisioningScheme Update the machine catalog's provisioning scheme.

			Update the machine catalog's provisioning scheme.


		Only valid when the machine catalog's ProvisioningType is MCS.


		Provides the ability to update the hard disk image used to provision
		virtual machines. If the provisioning scheme has CleanOnBoot equal to
		`true`, then the next time that virtual machines are started, their
		hard disks are updated to this new image. Regardless of CleanOnBoot,
		all new virtual machines created after this call succeeds will use this
		new hard disk image.


		A snapshot or VM template is used rather than a VM, so that the
		content of the hard disk for the provisioning scheme can be easily
		determined.


		The previous hard disk image path is stored into the history (see
		).  The
		data stored in the history allows for a rollback to be undertaken,
		to revert to the previous hard disk image if required.


		*Note:* The provisioning scheme for a machine catalog cannot be
		changed while any provisioning tasks are already executing for the
		machine catalog.  Cancel existing provisioning tasks or wait for
		their completion before updating the provisioning scheme.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
			@return ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest
	*/
	MachineCatalogsUpdateMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest

	// MachineCatalogsUpdateMachineCatalogProvisioningSchemeExecute executes the request
	//  @return JobResponseModel
	MachineCatalogsUpdateMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error)

	/*
		MachineCatalogsUpdateMachineCatalogUpgradeSchedule Reschedule a pending VDA upgrade schedule for a machine catalog.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest
	*/
	MachineCatalogsUpdateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest

	// MachineCatalogsUpdateMachineCatalogUpgradeScheduleExecute executes the request
	MachineCatalogsUpdateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) (*http.Response, error)

	/*
		MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection Validate the VDA component selection at catalog level that can be Included/Excluded and features that need enable during an VDA upgrade using VDA Upgrade Service.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
		@return ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest
	*/
	MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection(ctx context.Context, nameOrId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest

	// MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute executes the request
	//  @return VDAComponentsSelectionValidationResponseModel
	MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute(r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) (*VDAComponentsSelectionValidationResponseModel, *http.Response, error)
}

// MachineCatalogsAPIsDAASService MachineCatalogsAPIsDAAS service
type MachineCatalogsAPIsDAASService service

type ApiMachineCatalogsAddMachineCatalogMachineRequest struct {
	ctx                                          context.Context
	ApiService                                   MachineCatalogsAPIsDAAS
	citrixCustomerId                             *string
	citrixInstanceId                             *string
	nameOrId                                     string
	addMachineToMachineCatalogDetailRequestModel *AddMachineToMachineCatalogDetailRequestModel
	userAgent                                    *string
	authorization                                *string
	citrixTransactionId                          *string
	xAdminCredential                             *string
	xAccessToken                                 *string
	accept                                       *string
	citrixLocale                                 *string
	async                                        *bool
}

// MockApiMachineCatalogsAddMachineCatalogMachineRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsAddMachineCatalogMachineRequest struct {
	ApiMachineCatalogsAddMachineCatalogMachineRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetAddMachineToMachineCatalogDetailRequestModel returns the addMachineToMachineCatalogDetailRequestModel parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetAddMachineToMachineCatalogDetailRequestModel() *AddMachineToMachineCatalogDetailRequestModel {
	return r.addMachineToMachineCatalogDetailRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAdminCredential returns the xAdminCredential parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetXAdminCredential() *string {
	return r.xAdminCredential
}

// GetXAccessToken returns the xAccessToken parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetXAccessToken() *string {
	return r.xAccessToken
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsAddMachineCatalogMachineRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsAddMachineCatalogMachineRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details of the machine to add to the machine catalog.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) AddMachineToMachineCatalogDetailRequestModel(addMachineToMachineCatalogDetailRequestModel AddMachineToMachineCatalogDetailRequestModel) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.addMachineToMachineCatalogDetailRequestModel = &addMachineToMachineCatalogDetailRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) UserAgent(userAgent string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) Authorization(authorization string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) Accept(accept string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the machine will be added into the machine catalog as a background task. The task will have JobType AddMachineCatalogMachine. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties: * _NameOrId_ - Name or ID of the machine being added.
func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) Async(async bool) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsAddMachineCatalogMachineRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsAddMachineCatalogMachineExecute(r)
}

/*
MachineCatalogsAddMachineCatalogMachine Add machine to the machine catalog.

Add a machine to the machine catalog.  This is the first step in making the
machine available to run users' desktops and applications. The machine may
be physical or virtual.  The type of machine (physical or virtual) must
match the machine catalog configuration.

Note that due to
the long-running nature of the adding operation, it cannot
complete synchronously, would always initiate an asynchronous job to
run to completion.

The machine must support the expected capabilities of the machine catalog:
the  and
. The session
support of the machine is determined by the type of Citrix VDA software
installed (server or workstation) and the functional level depends on the
version of the Citrix VDA software installed.  The API will complete
successfully if these are not correct but the machine will be unable to register.

Note: to add multiple machines in a single call, use the

	API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog to add machine to.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsAddMachineCatalogMachineRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogMachine(ctx context.Context, nameOrId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	return ApiMachineCatalogsAddMachineCatalogMachineRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return JobResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogMachineExecute(r ApiMachineCatalogsAddMachineCatalogMachineRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsAddMachineCatalogMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Machines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.addMachineToMachineCatalogDetailRequestModel == nil {
		return localVarReturnValue, nil, reportError("addMachineToMachineCatalogDetailRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "simple", "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.addMachineToMachineCatalogDetailRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsAddMachineCatalogMachineAccountRequest struct {
	ctx                        context.Context
	ApiService                 MachineCatalogsAPIsDAAS
	citrixCustomerId           *string
	citrixInstanceId           *string
	nameOrId                   string
	machineAccountRequestModel *MachineAccountRequestModel
	userAgent                  *string
	authorization              *string
	citrixTransactionId        *string
	xAdminCredential           *string
	accept                     *string
	citrixLocale               *string
}

// MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest struct {
	ApiMachineCatalogsAddMachineCatalogMachineAccountRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetMachineAccountRequestModel returns the machineAccountRequestModel parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetMachineAccountRequestModel() *MachineAccountRequestModel {
	return r.machineAccountRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAdminCredential returns the xAdminCredential parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetXAdminCredential() *string {
	return r.xAdminCredential
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsAddMachineCatalogMachineAccountRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsAddMachineCatalogMachineAccountRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Machine account to add to the machine catalog.  The machine must not be a member of any other machine catalog.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) MachineAccountRequestModel(machineAccountRequestModel MachineAccountRequestModel) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.machineAccountRequestModel = &machineAccountRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) UserAgent(userAgent string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) Accept(accept string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsAddMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsAddMachineCatalogMachineAccount Add a machine account to the machine catalog.

Add a machine account to the machine catalog. This is only relevant for machine catalogs where ProvisioningType is MCS.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog to add the machine account to.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsAddMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogMachineAccount(ctx context.Context, nameOrId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsAddMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return ProvisioningSchemeMachineAccountResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogMachineAccountExecute(r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProvisioningSchemeMachineAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsAddMachineCatalogMachineAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MachineAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.machineAccountRequestModel == nil {
		return localVarReturnValue, nil, reportError("machineAccountRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.machineAccountRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsAddMachineCatalogTagsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	tagNameOrId         string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// MockApiMachineCatalogsAddMachineCatalogTagsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsAddMachineCatalogTagsRequest struct {
	ApiMachineCatalogsAddMachineCatalogTagsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetTagNameOrId returns the tagNameOrId parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetTagNameOrId() string {
	return r.tagNameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsAddMachineCatalogTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsAddMachineCatalogTagsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) UserAgent(userAgent string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) Accept(accept string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsAddMachineCatalogTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsAddMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsAddMachineCatalogTags Add a tag to a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@param tagNameOrId Name or ID of the tag to add.
	@return ApiMachineCatalogsAddMachineCatalogTagsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	return ApiMachineCatalogsAddMachineCatalogTagsRequest{
		ApiService:  a,
		ctx:         ctx,
		nameOrId:    nameOrId,
		tagNameOrId: tagNameOrId,
	}
}

// Execute executes the request
//
//	@return TagResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsAddMachineCatalogTagsExecute(r ApiMachineCatalogsAddMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsAddMachineCatalogTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Tags/{tagNameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagNameOrId"+"}", url.PathEscape(parameterValueToString(r.tagNameOrId, "tagNameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsCheckMachineCatalogExistsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	name                string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsCheckMachineCatalogExistsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsCheckMachineCatalogExistsRequest struct {
	ApiMachineCatalogsCheckMachineCatalogExistsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetName returns the name parameter
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetName() string {
	return r.name
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsCheckMachineCatalogExistsRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsCheckMachineCatalogExistsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) UserAgent(userAgent string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) Authorization(authorization string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) Accept(accept string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsCheckMachineCatalogExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsCheckMachineCatalogExistsExecute(r)
}

/*
MachineCatalogsCheckMachineCatalogExists Check for the existence of a machine catalog by name.

Check for the existence of a machine catalog by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsCheckMachineCatalogExistsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCheckMachineCatalogExists(ctx context.Context, name string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	return ApiMachineCatalogsCheckMachineCatalogExistsRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCheckMachineCatalogExistsExecute(r ApiMachineCatalogsCheckMachineCatalogExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsCheckMachineCatalogExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	name                string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest struct {
	ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetName returns the name parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetName() string {
	return r.name
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) UserAgent(userAgent string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) Authorization(authorization string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) Accept(accept string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsCheckRemotePCEnrollmentScopeExistsExecute(r)
}

/*
MachineCatalogsCheckRemotePCEnrollmentScopeExists Check for the existence of a RemotePC enrollment scope by name.

Check for the existence of a RemotePC enrollment scope by name. Note that
RemotePC enrollment scope names must be unique within the site, so the
`nameOrId` parameter does not affect whether the RemotePC enrollment scope
name is found.
If the name is found to be available, this returns 404 Not Found.
If a RemotePC enrollment scope by that name exists and is associated with the
specified machine catalog, this returns 204 No Content. If a RemotePC
enrollment scope by that name exists and is associated with a different
machine catalog, this returns 303 See Other, and the `Location`
response header refers to location of the machine catalog which is associated
by the RemotePC enrollment scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@param name Distinguished name of an OU containing machines allowed to enroll as remote PCs.
	@return ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCheckRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string, name string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	return ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
		name:       name,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCheckRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsCheckRemotePCEnrollmentScopeExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/RemotePCEnrollmentScopes/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsCreateMachineCatalogRequest struct {
	ctx                              context.Context
	ApiService                       MachineCatalogsAPIsDAAS
	citrixCustomerId                 *string
	citrixInstanceId                 *string
	createMachineCatalogRequestModel *CreateMachineCatalogRequestModel
	userAgent                        *string
	authorization                    *string
	citrixTransactionId              *string
	xAdminCredential                 *string
	xAccessToken                     *string
	accept                           *string
	citrixLocale                     *string
	async                            *bool
	sourceNameOrId                   *string
}

// MockApiMachineCatalogsCreateMachineCatalogRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsCreateMachineCatalogRequest struct {
	ApiMachineCatalogsCreateMachineCatalogRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetCreateMachineCatalogRequestModel returns the createMachineCatalogRequestModel parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetCreateMachineCatalogRequestModel() *CreateMachineCatalogRequestModel {
	return r.createMachineCatalogRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAdminCredential returns the xAdminCredential parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetXAdminCredential() *string {
	return r.xAdminCredential
}

// GetXAccessToken returns the xAccessToken parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetXAccessToken() *string {
	return r.xAccessToken
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetAsync() *bool {
	return r.async
}

// GetSourceNameOrId returns the sourceNameOrId parameter
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) GetSourceNameOrId() *string {
	return r.sourceNameOrId
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsCreateMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsCreateMachineCatalogRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details about the machine catalog to create.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CreateMachineCatalogRequestModel(createMachineCatalogRequestModel CreateMachineCatalogRequestModel) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.createMachineCatalogRequestModel = &createMachineCatalogRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsCreateMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsCreateMachineCatalogRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsCreateMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be created as a background task. The task will have JobType CreateMachineCatalog. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties: * _Name_ - Name of the machine catalog being created.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) Async(async bool) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.async = &async
	return r
}

// The machine catalog name or Id to recreate from. It is only used for catalog recreation scenario. Here specify name or Id of the failed catalog to recreate.
func (r ApiMachineCatalogsCreateMachineCatalogRequest) SourceNameOrId(sourceNameOrId string) ApiMachineCatalogsCreateMachineCatalogRequest {
	r.sourceNameOrId = &sourceNameOrId
	return r
}

func (r ApiMachineCatalogsCreateMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsCreateMachineCatalogExecute(r)
}

/*
MachineCatalogsCreateMachineCatalog Create a machine catalog.

Create a machine catalog.

Note that if a machine catalog uses
of , the machine catalog creation will always invoke asynchronous
job(s) for the provisioning action.  If this API is invoked asynchronously, the asynchronous job
will include only the machine catalog creation, and the provisioning task(s) will be associated
with the newly created catalog.  If this API is invoked synchronously, the machine catalog
creation will complete synchronously but the provisioning task(s) may still be executing, and
will be associated with the newly created catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMachineCatalogsCreateMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCreateMachineCatalog(ctx context.Context) ApiMachineCatalogsCreateMachineCatalogRequest {
	return ApiMachineCatalogsCreateMachineCatalogRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MachineCatalogDetailResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCreateMachineCatalogExecute(r ApiMachineCatalogsCreateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsCreateMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.createMachineCatalogRequestModel == nil {
		return localVarReturnValue, nil, reportError("createMachineCatalogRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.sourceNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNameOrId", r.sourceNameOrId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "simple", "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.createMachineCatalogRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest struct {
	ctx                               context.Context
	ApiService                        MachineCatalogsAPIsDAAS
	citrixCustomerId                  *string
	citrixInstanceId                  *string
	nameOrId                          string
	createUpgradeScheduleRequestModel *CreateUpgradeScheduleRequestModel
	userAgent                         *string
	authorization                     *string
	citrixTransactionId               *string
	accept                            *string
	citrixLocale                      *string
	async                             *bool
}

// MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest struct {
	ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetCreateUpgradeScheduleRequestModel returns the createUpgradeScheduleRequestModel parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetCreateUpgradeScheduleRequestModel() *CreateUpgradeScheduleRequestModel {
	return r.createUpgradeScheduleRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details about the VDA upgrade schedule to create.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CreateUpgradeScheduleRequestModel(createUpgradeScheduleRequestModel CreateUpgradeScheduleRequestModel) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.createUpgradeScheduleRequestModel = &createUpgradeScheduleRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) UserAgent(userAgent string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Accept(accept string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be created as a background task.
func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsCreateMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsCreateMachineCatalogUpgradeSchedule Setup a new VDA upgrade schedule for a machine catalog.

A new VDA upgrade schedule can only be created for a machine catalog
when the upgrade status for the catalog is UpgradeSuccessful, UpgradeFailed or UpgradeCancelled.
If the status is ongoing or waiting to start, the operation fails.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCreateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsCreateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsCreateMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.createUpgradeScheduleRequestModel == nil {
		return nil, reportError("createUpgradeScheduleRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.createUpgradeScheduleRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsDeleteMachineCatalogRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	xAdminCredential    *string
	xAccessToken        *string
	accept              *string
	citrixLocale        *string
	deleteVm            *bool
	deleteAccount       *MachineAccountDeleteOption
	purgeDBOnly         *bool
	async               *bool
}

// MockApiMachineCatalogsDeleteMachineCatalogRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsDeleteMachineCatalogRequest struct {
	ApiMachineCatalogsDeleteMachineCatalogRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAdminCredential returns the xAdminCredential parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetXAdminCredential() *string {
	return r.xAdminCredential
}

// GetXAccessToken returns the xAccessToken parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetXAccessToken() *string {
	return r.xAccessToken
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetDeleteVm returns the deleteVm parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetDeleteVm() *bool {
	return r.deleteVm
}

// GetDeleteAccount returns the deleteAccount parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetDeleteAccount() *MachineAccountDeleteOption {
	return r.deleteAccount
}

// GetPurgeDBOnly returns the purgeDBOnly parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetPurgeDBOnly() *bool {
	return r.purgeDBOnly
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsDeleteMachineCatalogRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsDeleteMachineCatalogRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Specifies whether to delete virtual machines that were provisioned in the machine catalog. Only relevant when ProvisioningType is MCS; otherwise, ignored.  Optional; default is &#x60;true&#x60;.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) DeleteVm(deleteVm bool) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.deleteVm = &deleteVm
	return r
}

// Specifies what to do with AD machine accounts that are associated with the machine catalog.  Optional; default is .
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) DeleteAccount(deleteAccount MachineAccountDeleteOption) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.deleteAccount = &deleteAccount
	return r
}

// Specifies whether to only delete virtual machines record that were provisioned in the machine catalog from database, not access hypervisor to delete virtual machines, this is recommended only when hypervisor cannot be accessed.  Optional; default is &#x60;false&#x60;.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) PurgeDBOnly(purgeDBOnly bool) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.purgeDBOnly = &purgeDBOnly
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be deleted as a background task. The task will have JobType DeleteMachineCatalog. When the task is complete it will redirect to GetMachineCatalogs. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being deleted, * _Name_ - Name of the machine catalog being deleted.
func (r ApiMachineCatalogsDeleteMachineCatalogRequest) Async(async bool) ApiMachineCatalogsDeleteMachineCatalogRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsDeleteMachineCatalogRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsDeleteMachineCatalogExecute(r)
}

/*
MachineCatalogsDeleteMachineCatalog Delete a machine catalog.

Delete a machine catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog to update.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsDeleteMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsDeleteMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	return ApiMachineCatalogsDeleteMachineCatalogRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsDeleteMachineCatalogExecute(r ApiMachineCatalogsDeleteMachineCatalogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsDeleteMachineCatalog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.deleteVm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteVm", r.deleteVm, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteVm = &defaultValue
	}
	if r.deleteAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAccount", r.deleteAccount, "form", "")
	} else {
		var defaultValue MachineAccountDeleteOption = "None"
		r.deleteAccount = &defaultValue
	}
	if r.purgeDBOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDBOnly", r.purgeDBOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.purgeDBOnly = &defaultValue
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "simple", "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsDoMachineCatalogSearchRequest struct {
	ctx                       context.Context
	ApiService                MachineCatalogsAPIsDAAS
	citrixCustomerId          *string
	citrixInstanceId          *string
	catalogSearchRequestModel *CatalogSearchRequestModel
	userAgent                 *string
	authorization             *string
	citrixTransactionId       *string
	accept                    *string
	citrixLocale              *string
	async                     *bool
	limit                     *int32
	continuationToken         *string
	fields                    *string
}

// MockApiMachineCatalogsDoMachineCatalogSearchRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsDoMachineCatalogSearchRequest struct {
	ApiMachineCatalogsDoMachineCatalogSearchRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetCatalogSearchRequestModel returns the catalogSearchRequestModel parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetCatalogSearchRequestModel() *CatalogSearchRequestModel {
	return r.catalogSearchRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetAsync() *bool {
	return r.async
}

// GetLimit returns the limit parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetLimit() *int32 {
	return r.limit
}

// GetContinuationToken returns the continuationToken parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetContinuationToken() *string {
	return r.continuationToken
}

// GetFields returns the fields parameter
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) GetFields() *string {
	return r.fields
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsDoMachineCatalogSearchRequest) Execute() (*CatalogSearchResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsDoMachineCatalogSearchRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Specifies the advanced search parameters.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CatalogSearchRequestModel(catalogSearchRequestModel CatalogSearchRequestModel) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.catalogSearchRequestModel = &catalogSearchRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) UserAgent(userAgent string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Authorization(authorization string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Accept(accept string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the catalogs (and associated objects) will be added as a background task. The task will have JobType SearchMachineCatalogs.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Async(async bool) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.async = &async
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Limit(limit int32) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Fields(fields string) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	r.fields = &fields
	return r
}

func (r ApiMachineCatalogsDoMachineCatalogSearchRequest) Execute() (*CatalogSearchResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsDoMachineCatalogSearchExecute(r)
}

/*
MachineCatalogsDoMachineCatalogSearch Perform an advanced search for machinecatalogs.

Perform an advanced search for machinecatalogs.  Note that some combinations
of search parameters may result in slow performance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMachineCatalogsDoMachineCatalogSearchRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsDoMachineCatalogSearch(ctx context.Context) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	return ApiMachineCatalogsDoMachineCatalogSearchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CatalogSearchResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsDoMachineCatalogSearchExecute(r ApiMachineCatalogsDoMachineCatalogSearchRequest) (*CatalogSearchResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CatalogSearchResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsDoMachineCatalogSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Machinecatalogs/$search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.catalogSearchRequestModel == nil {
		return localVarReturnValue, nil, reportError("catalogSearchRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.catalogSearchRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsExportRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	fields              *string
}

// MockApiMachineCatalogsExportRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsExportRequest struct {
	ApiMachineCatalogsExportRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsExportRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsExportRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsExportRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsExportRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsExportRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsExportRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsExportRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsExportRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsExportRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetFields returns the fields parameter
func (r MockApiMachineCatalogsExportRequest) GetFields() *string {
	return r.fields
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsExportRequest) Execute() (*ExportMachineCatalogResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsExportRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsExportRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsExportRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsExportRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsExportRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsExportRequest) UserAgent(userAgent string) ApiMachineCatalogsExportRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsExportRequest) Authorization(authorization string) ApiMachineCatalogsExportRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsExportRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsExportRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsExportRequest) Accept(accept string) ApiMachineCatalogsExportRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsExportRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsExportRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The required fields
func (r ApiMachineCatalogsExportRequest) Fields(fields string) ApiMachineCatalogsExportRequest {
	r.fields = &fields
	return r
}

func (r ApiMachineCatalogsExportRequest) Execute() (*ExportMachineCatalogResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsExportExecute(r)
}

/*
MachineCatalogsExport Exports a MCS machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId The machine catalog
	@return ApiMachineCatalogsExportRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsExport(ctx context.Context, nameOrId string) ApiMachineCatalogsExportRequest {
	return ApiMachineCatalogsExportRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return ExportMachineCatalogResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsExportExecute(r ApiMachineCatalogsExportRequest) (*ExportMachineCatalogResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExportMachineCatalogResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$export"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsExportMachineProfileRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsExportMachineProfileRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsExportMachineProfileRequest struct {
	ApiMachineCatalogsExportMachineProfileRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsExportMachineProfileRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsExportMachineProfileRequest) Execute() (*ExportMachineProfileResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsExportMachineProfileRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsExportMachineProfileRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsExportMachineProfileRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsExportMachineProfileRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsExportMachineProfileRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsExportMachineProfileRequest) UserAgent(userAgent string) ApiMachineCatalogsExportMachineProfileRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsExportMachineProfileRequest) Authorization(authorization string) ApiMachineCatalogsExportMachineProfileRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsExportMachineProfileRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsExportMachineProfileRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsExportMachineProfileRequest) Accept(accept string) ApiMachineCatalogsExportMachineProfileRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsExportMachineProfileRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsExportMachineProfileRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsExportMachineProfileRequest) Execute() (*ExportMachineProfileResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsExportMachineProfileExecute(r)
}

/*
MachineCatalogsExportMachineProfile Exports a MCS machine catalog's machine profile.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId The name or id of machine catalog.
	@return ApiMachineCatalogsExportMachineProfileRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsExportMachineProfile(ctx context.Context, nameOrId string) ApiMachineCatalogsExportMachineProfileRequest {
	return ApiMachineCatalogsExportMachineProfileRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return ExportMachineProfileResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsExportMachineProfileExecute(r ApiMachineCatalogsExportMachineProfileRequest) (*ExportMachineProfileResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExportMachineProfileResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsExportMachineProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$exportMachineProfile"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
	fields              *string
}

// MockApiMachineCatalogsGetMachineCatalogRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogRequest struct {
	ApiMachineCatalogsGetMachineCatalogRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetAsync() *bool {
	return r.async
}

// GetFields returns the fields parameter
func (r MockApiMachineCatalogsGetMachineCatalogRequest) GetFields() *string {
	return r.fields
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogRequest {
	r.async = &async
	return r
}

// Optional parameters, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsGetMachineCatalogRequest) Fields(fields string) ApiMachineCatalogsGetMachineCatalogRequest {
	r.fields = &fields
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogExecute(r)
}

/*
MachineCatalogsGetMachineCatalog Get details about a single machine catalog.

Get details about a single machine catalog by name or ID of machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogRequest {
	return ApiMachineCatalogsGetMachineCatalogRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return MachineCatalogDetailResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogExecute(r ApiMachineCatalogsGetMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogCostSummaryRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	start               *time.Time
	end                 *time.Time
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	summaryType         *SummaryType
	async               *bool
}

// MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest struct {
	ApiMachineCatalogsGetMachineCatalogCostSummaryRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetStart returns the start parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetStart() *time.Time {
	return r.start
}

// GetEnd returns the end parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetEnd() *time.Time {
	return r.end
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetSummaryType returns the summaryType parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetSummaryType() *SummaryType {
	return r.summaryType
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogCostSummaryRequest) Execute() (*ResourceCostResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogCostSummaryRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// The start date of the cost summary, the date format is &#x60;yyyy-MM-ddT00:00:00Z&#x60;.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) Start(start time.Time) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.start = &start
	return r
}

// The end date of the cost summary, the date format is &#x60;yyyy-MM-ddT00:00:00Z&#x60;.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) End(end time.Time) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.end = &end
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The summary type of the cost, Currently only &#x60;VM&#x60; and &#x60;Disk&#x60; are supported.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) SummaryType(summaryType SummaryType) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.summaryType = &summaryType
	return r
}

// if the value is &#x60;true&#x60;, the machine catalog&#39;s cost summary will be calculated asynchronously.
func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) Execute() (*ResourceCostResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogCostSummaryExecute(r)
}

/*
MachineCatalogsGetMachineCatalogCostSummary Get the machine catalog's cost summary.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId The name or ID of the machine catalog.
	@return ApiMachineCatalogsGetMachineCatalogCostSummaryRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogCostSummary(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	return ApiMachineCatalogsGetMachineCatalogCostSummaryRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return ResourceCostResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogCostSummaryExecute(r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) (*ResourceCostResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResourceCostResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogCostSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/CostSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	if r.summaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryType", r.summaryType, "form", "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogDailyCostRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	start               *time.Time
	end                 *time.Time
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// MockApiMachineCatalogsGetMachineCatalogDailyCostRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogDailyCostRequest struct {
	ApiMachineCatalogsGetMachineCatalogDailyCostRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetStart returns the start parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetStart() *time.Time {
	return r.start
}

// GetEnd returns the end parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetEnd() *time.Time {
	return r.end
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogDailyCostRequest) Execute() (*DailyCostResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogDailyCostRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// The start date of the daily cost, the date format is &#x60;yyyy-MM-ddT00:00:00Z&#x60;.
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) Start(start time.Time) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.start = &start
	return r
}

// The end date of the daily cost, the date format is &#x60;yyyy-MM-ddT00:00:00Z&#x60;.
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) End(end time.Time) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.end = &end
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If the value is &#x60;true&#x60;, the machine catalog&#39;s daily cost will be calculated asynchronously.
func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) Execute() (*DailyCostResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogDailyCostExecute(r)
}

/*
MachineCatalogsGetMachineCatalogDailyCost Get the machine catalog's daily cost.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId The name or ID of the machine catalog.
	@return ApiMachineCatalogsGetMachineCatalogDailyCostRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogDailyCost(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	return ApiMachineCatalogsGetMachineCatalogDailyCostRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return DailyCostResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogDailyCostExecute(r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) (*DailyCostResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DailyCostResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogDailyCost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/DailyCost"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
	async               *bool
}

// MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest struct {
	ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetLimit returns the limit parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetLimit() *int32 {
	return r.limit
}

// GetContinuationToken returns the continuationToken parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetContinuationToken() *string {
	return r.continuationToken
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Execute() (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of delivery group associations returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) Execute() (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogDeliveryGroupAssociationsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogDeliveryGroupAssociations Get delivery group associations of a machine catalog.

Get delivery group associations by name or Id of a remote pc machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogDeliveryGroupAssociations(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	return ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return DeliveryGroupAssociationResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogDeliveryGroupAssociationsExecute(r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeliveryGroupAssociationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogDeliveryGroupAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/DeliveryGroupAssociations"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "form", "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest struct {
	ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) Execute() (*EnrollmentResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) Execute() (*EnrollmentResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogEnrollmentsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogEnrollments Get the list of enrollments in the machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog.
	@return ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogEnrollments(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	return ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return EnrollmentResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogEnrollmentsExecute(r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) (*EnrollmentResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnrollmentResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogEnrollments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Enrollments"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest struct {
	ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Execute() (*VMImageResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) Execute() (*VMImageResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogLastMasterImageExecute(r)
}

/*
MachineCatalogsGetMachineCatalogLastMasterImage Get the last master VM images used by the machine catalog.

Get the last master VM images used by the machine catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogLastMasterImage(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	return ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return VMImageResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogLastMasterImageExecute(r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) (*VMImageResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VMImageResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogLastMasterImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/LastMasterImage"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
	async               *bool
	accountState        *ProvisioningSchemeMachineAccountState
}

// MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest struct {
	ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetLimit returns the limit parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetLimit() *int32 {
	return r.limit
}

// GetContinuationToken returns the continuationToken parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetContinuationToken() *string {
	return r.continuationToken
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetAsync() *bool {
	return r.async
}

// GetAccountState returns the accountState parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) GetAccountState() *ProvisioningSchemeMachineAccountState {
	return r.accountState
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of machine accounts returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, the machine accounts will be queried as a background task. The task will have JobType GetMachineCatalogMachineAccounts. When the task is complete it will redirect to GetJobResults.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.async = &async
	return r
}

// The state of accounts for query.
func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) AccountState(accountState ProvisioningSchemeMachineAccountState) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	r.accountState = &accountState
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogMachineAccountsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogMachineAccounts Get all machine accounts associated with a machine catalog.

Get all machine accounts associated with a machine catalog.  This returns
all machine accounts for the machine catalog regardless of whether they are
in-use, available, locked, etc.

This is only relevant for machine catalogs where ProvisioningType is MCS.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog to get machine accounts for.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMachineAccounts(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	return ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return ProvisioningSchemeMachineAccountResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMachineAccountsExecute(r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProvisioningSchemeMachineAccountResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogMachineAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MachineAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "form", "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.accountState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountState", r.accountState, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogMachinesRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	limit               *int32
	continuationToken   *string
	async               *bool
	fields              *string
}

// MockApiMachineCatalogsGetMachineCatalogMachinesRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogMachinesRequest struct {
	ApiMachineCatalogsGetMachineCatalogMachinesRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetLimit returns the limit parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetLimit() *int32 {
	return r.limit
}

// GetContinuationToken returns the continuationToken parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetContinuationToken() *string {
	return r.continuationToken
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetAsync() *bool {
	return r.async
}

// GetFields returns the fields parameter
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) GetFields() *string {
	return r.fields
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogMachinesRequest) Execute() (*MachineResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogMachinesRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The max number of machines returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.async = &async
	return r
}

// Optional parameters, only the specified properties in the fields are required.
func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Fields(fields string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	r.fields = &fields
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogMachinesRequest) Execute() (*MachineResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogMachinesExecute(r)
}

/*
MachineCatalogsGetMachineCatalogMachines GET the machines of a catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogMachinesRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	return ApiMachineCatalogsGetMachineCatalogMachinesRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return MachineResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMachinesExecute(r ApiMachineCatalogsGetMachineCatalogMachinesRequest) (*MachineResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogMachines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Machines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "form", "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest struct {
	ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) Execute() (*VMImageResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) Execute() (*VMImageResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogMasterImageHistoryExecute(r)
}

/*
MachineCatalogsGetMachineCatalogMasterImageHistory Get the history of master VM images used by the machine catalog.

Get the history of master VM images used by the machine catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog.
	@return ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMasterImageHistory(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	return ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return VMImageResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogMasterImageHistoryExecute(r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) (*VMImageResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VMImageResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogMasterImageHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MasterImageHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	machines            *[]string
	async               *bool
}

// MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest struct {
	ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetMachines returns the machines parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetMachines() *[]string {
	return r.machines
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Execute() (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The machines to get start menu applications
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Machines(machines []string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.machines = &machines
	return r
}

// If &#x60;true&#x60;, the start menu applications will be queried as a background task. This is recommended as this operation may cause a power action, turning on a machine in order to gather the data. This may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType GetStartMenuApplications. When the task is complete it will redirect to \&quot;JobsControllerTP.GetJobResults(string)\&quot;. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog from which start menu applications are being obtained, * _Name_ - Name of the machine catalog from which start menu applications are being obtained. * _MachineId_ - ID of the machine selected, from which the start menu applications are being obtained; will be present in Parameters only after a machine is selected. * _MachineName_ - Name of the machine selected, from which the start menu applications are being obtained; will be present in Parameters only after a machine is selected.
func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) Execute() (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogStartMenuApplicationsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogStartMenuApplications Get the start menu applications from a machine in the machine catalog.

# Get the start menu applications from a machine in the machine catalog

Note that this API may require a machine within a catalog to be
booted, if no machines are currently available.  Therefore the API
may take quite some time to complete.  Consider using the `async=true`
parameter to mitigate this.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogStartMenuApplications(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	return ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return StartMenuApplicationResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogStartMenuApplicationsExecute(r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StartMenuApplicationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogStartMenuApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/StartMenuApplications"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.machines != nil {
		t := *r.machines
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "machines", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "machines", t, "form", "multi")
		}
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogTagsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	fields              *string
}

// MockApiMachineCatalogsGetMachineCatalogTagsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogTagsRequest struct {
	ApiMachineCatalogsGetMachineCatalogTagsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetFields returns the fields parameter
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) GetFields() *string {
	return r.fields
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogTagsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Optional parameters, removing unspecified properties that otherwise would have been sent by the server.
func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) Fields(fields string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	r.fields = &fields
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogTags Get tags associated with a machine catalog.

Get tags associated with a machine catalog.  This includes tags which are
directly associated with the machine catalog, as well as tags associated with
machines that are associated with the machine catalog.
To find only tags directly associated with the machine catalog,
filter the results to those with
NumMachineCatalogs equal to `1`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogTagsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogTags(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	return ApiMachineCatalogsGetMachineCatalogTagsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return TagResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogTagsExecute(r ApiMachineCatalogsGetMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Tags"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogTestReportRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsGetMachineCatalogTestReportRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogTestReportRequest struct {
	ApiMachineCatalogsGetMachineCatalogTestReportRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogTestReportRequest) Execute() (*TestReportResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogTestReportRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogTestReportRequest) Execute() (*TestReportResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogTestReportExecute(r)
}

/*
MachineCatalogsGetMachineCatalogTestReport Get the most recent test report of a machine catalog.

Get the test report from the last run of
TestMachineCatalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogTestReportRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogTestReport(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	return ApiMachineCatalogsGetMachineCatalogTestReportRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return TestReportResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogTestReportExecute(r ApiMachineCatalogsGetMachineCatalogTestReportRequest) (*TestReportResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TestReportResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogTestReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/TestReport"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	upgradeVersion      *string
}

// MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest struct {
	ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetUpgradeVersion returns the upgradeVersion parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) GetUpgradeVersion() *string {
	return r.upgradeVersion
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) Execute() (*MachineCatalogVusComponentResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// The version of the VDA to upgrade to.
func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) UpgradeVersion(upgradeVersion string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	r.upgradeVersion = &upgradeVersion
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) Execute() (*MachineCatalogVusComponentResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesExecute(r)
}

/*
MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures Get the components and features of VDAs associated with a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	return ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return MachineCatalogVusComponentResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesExecute(r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) (*MachineCatalogVusComponentResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineCatalogVusComponentResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/VDAComponentsAndFeatures"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.upgradeVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upgradeVersion", r.upgradeVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest struct {
	ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogVDAUpgradeVersionsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogVDAUpgradeVersions Get the available VDA upgrade versions associated with a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogVDAUpgradeVersions(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	return ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return []string
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogVDAUpgradeVersionsExecute(r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogVDAUpgradeVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/VDAUpgradeVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	adminFolder         *string
	async               *bool
	limit               *int32
	continuationToken   *string
	fields              *string
}

// MockApiMachineCatalogsGetMachineCatalogsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogsRequest struct {
	ApiMachineCatalogsGetMachineCatalogsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAdminFolder returns the adminFolder parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetAdminFolder() *string {
	return r.adminFolder
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetAsync() *bool {
	return r.async
}

// GetLimit returns the limit parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetLimit() *int32 {
	return r.limit
}

// GetContinuationToken returns the continuationToken parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetContinuationToken() *string {
	return r.continuationToken
}

// GetFields returns the fields parameter
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) GetFields() *string {
	return r.fields
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogsRequest) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Admin folder path or Id.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) AdminFolder(adminFolder string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.adminFolder = &adminFolder
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Async(async bool) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.async = &async
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional. A filter string containing object fields requested to be returned, the requested fields are separated by comma&#39;,&#39;.
func (r ApiMachineCatalogsGetMachineCatalogsRequest) Fields(fields string) ApiMachineCatalogsGetMachineCatalogsRequest {
	r.fields = &fields
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogsRequest) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogs Get all machine catalogs.

Get all machine catalogs in the site.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMachineCatalogsGetMachineCatalogsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogs(ctx context.Context) ApiMachineCatalogsGetMachineCatalogsRequest {
	return ApiMachineCatalogsGetMachineCatalogsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MachineCatalogResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogsExecute(r ApiMachineCatalogsGetMachineCatalogsRequest) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineCatalogResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.adminFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adminFolder", r.adminFolder, "form", "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest struct {
	ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) Execute() (*AdministratorResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) Accept(accept string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) Execute() (*AdministratorResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogsAdministratorsExecute(r)
}

/*
MachineCatalogsGetMachineCatalogsAdministrators Get administrators who can administer a machine catalog.

Get administrators who can administer a machine catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogsAdministrators(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	return ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return AdministratorResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogsAdministratorsExecute(r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) (*AdministratorResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AdministratorResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogsAdministrators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Administrators"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsGetMachineCatalogsV2Request struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	adminFolder         *string
	async               *bool
	limit               *int32
	continuationToken   *string
	fields              *string
}

// MockApiMachineCatalogsGetMachineCatalogsV2Request wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsGetMachineCatalogsV2Request struct {
	ApiMachineCatalogsGetMachineCatalogsV2Request
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAdminFolder returns the adminFolder parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetAdminFolder() *string {
	return r.adminFolder
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetAsync() *bool {
	return r.async
}

// GetLimit returns the limit parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetLimit() *int32 {
	return r.limit
}

// GetContinuationToken returns the continuationToken parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetContinuationToken() *string {
	return r.continuationToken
}

// GetFields returns the fields parameter
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) GetFields() *string {
	return r.fields
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsGetMachineCatalogsV2Request) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsGetMachineCatalogsV2Request.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) UserAgent(userAgent string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) Authorization(authorization string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) Accept(accept string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) CitrixLocale(citrixLocale string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.citrixLocale = &citrixLocale
	return r
}

// Admin folder path or Id.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) AdminFolder(adminFolder string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.adminFolder = &adminFolder
	return r
}

// If &#x60;true&#x60;, it will be queried as a background task.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) Async(async bool) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.async = &async
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) Limit(limit int32) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) ContinuationToken(continuationToken string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.continuationToken = &continuationToken
	return r
}

// Optional. A filter string containing object fields requested to be returned, the requested fields are separated by comma&#39;,&#39;.
func (r ApiMachineCatalogsGetMachineCatalogsV2Request) Fields(fields string) ApiMachineCatalogsGetMachineCatalogsV2Request {
	r.fields = &fields
	return r
}

func (r ApiMachineCatalogsGetMachineCatalogsV2Request) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsGetMachineCatalogsV2Execute(r)
}

/*
MachineCatalogsGetMachineCatalogsV2 The V2  version of get all machine catalogs.

Get all machine catalogs in the site with default response fields if no fields parameters specified.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMachineCatalogsGetMachineCatalogsV2Request
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogsV2(ctx context.Context) ApiMachineCatalogsGetMachineCatalogsV2Request {
	return ApiMachineCatalogsGetMachineCatalogsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MachineCatalogResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsGetMachineCatalogsV2Execute(r ApiMachineCatalogsGetMachineCatalogsV2Request) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineCatalogResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsGetMachineCatalogsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogsV2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.adminFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adminFolder", r.adminFolder, "form", "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsImportProvisionedVirtualMachinesRequest struct {
	ctx                                          context.Context
	ApiService                                   MachineCatalogsAPIsDAAS
	citrixCustomerId                             *string
	citrixInstanceId                             *string
	nameOrId                                     string
	importProvisionedVirtualMachinesRequestModel *ImportProvisionedVirtualMachinesRequestModel
	userAgent                                    *string
	authorization                                *string
	citrixTransactionId                          *string
	accept                                       *string
	citrixLocale                                 *string
	async                                        *bool
}

// MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest struct {
	ApiMachineCatalogsImportProvisionedVirtualMachinesRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetImportProvisionedVirtualMachinesRequestModel returns the importProvisionedVirtualMachinesRequestModel parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetImportProvisionedVirtualMachinesRequestModel() *ImportProvisionedVirtualMachinesRequestModel {
	return r.importProvisionedVirtualMachinesRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsImportProvisionedVirtualMachinesRequest) Execute() (*ImportProvisionedVirtualMachineResponseModelCollection, *http.Response, error) {
	return r.ApiMachineCatalogsImportProvisionedVirtualMachinesRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// The existing provisioned virtual machines data.
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) ImportProvisionedVirtualMachinesRequestModel(importProvisionedVirtualMachinesRequestModel ImportProvisionedVirtualMachinesRequestModel) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.importProvisionedVirtualMachinesRequestModel = &importProvisionedVirtualMachinesRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) UserAgent(userAgent string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) Authorization(authorization string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) Accept(accept string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the machine accounts repair will be performed as a background task.
func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) Async(async bool) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) Execute() (*ImportProvisionedVirtualMachineResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachineCatalogsImportProvisionedVirtualMachinesExecute(r)
}

/*
MachineCatalogsImportProvisionedVirtualMachines Import existing provisioned virtual machines.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId The machineCatalog name or Id.
	@return ApiMachineCatalogsImportProvisionedVirtualMachinesRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsImportProvisionedVirtualMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	return ApiMachineCatalogsImportProvisionedVirtualMachinesRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return ImportProvisionedVirtualMachineResponseModelCollection
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsImportProvisionedVirtualMachinesExecute(r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) (*ImportProvisionedVirtualMachineResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImportProvisionedVirtualMachineResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsImportProvisionedVirtualMachines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$importProvisionedVirtualMachines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.importProvisionedVirtualMachinesRequestModel == nil {
		return localVarReturnValue, nil, reportError("importProvisionedVirtualMachinesRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.importProvisionedVirtualMachinesRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsRebootMachineCatalogMachinesRequest struct {
	ctx                        context.Context
	ApiService                 MachineCatalogsAPIsDAAS
	citrixCustomerId           *string
	citrixInstanceId           *string
	nameOrId                   string
	rebootMachinesRequestModel *RebootMachinesRequestModel
	userAgent                  *string
	authorization              *string
	citrixTransactionId        *string
	accept                     *string
	citrixLocale               *string
}

// MockApiMachineCatalogsRebootMachineCatalogMachinesRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsRebootMachineCatalogMachinesRequest struct {
	ApiMachineCatalogsRebootMachineCatalogMachinesRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetRebootMachinesRequestModel returns the rebootMachinesRequestModel parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetRebootMachinesRequestModel() *RebootMachinesRequestModel {
	return r.rebootMachinesRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsRebootMachineCatalogMachinesRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsRebootMachineCatalogMachinesRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Reboot options.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) RebootMachinesRequestModel(rebootMachinesRequestModel RebootMachinesRequestModel) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.rebootMachinesRequestModel = &rebootMachinesRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) UserAgent(userAgent string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) Authorization(authorization string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) Accept(accept string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRebootMachineCatalogMachinesExecute(r)
}

/*
MachineCatalogsRebootMachineCatalogMachines Reboot all machines in a machine catalog.

Reboot all machines in a machine catalog.

Note that there is no job representation for the reboot operation.
The call returns immediately even though the machines reboot over time.
If you want to follow the progress of the reboot operation, check
the
property of the machines in the machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsRebootMachineCatalogMachinesRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRebootMachineCatalogMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	return ApiMachineCatalogsRebootMachineCatalogMachinesRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRebootMachineCatalogMachinesExecute(r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRebootMachineCatalogMachines")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$RebootMachines"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.rebootMachinesRequestModel == nil {
		return nil, reportError("rebootMachinesRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.rebootMachinesRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRemoveMachineCatalogMachineRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	machine             string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
}

// MockApiMachineCatalogsRemoveMachineCatalogMachineRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsRemoveMachineCatalogMachineRequest struct {
	ApiMachineCatalogsRemoveMachineCatalogMachineRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetMachine returns the machine parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetMachine() string {
	return r.machine
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsRemoveMachineCatalogMachineRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) UserAgent(userAgent string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) Authorization(authorization string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) Accept(accept string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRemoveMachineCatalogMachineExecute(r)
}

/*
MachineCatalogsRemoveMachineCatalogMachine Remove a machine from the machine catalog.

Remove a machine from the machine catalog.  Removing the machine from the machine
catalog removes it from the site.

A machine cannot be removed from the machine catalog if it is a member of a delivery group.

Note: to remove multiple machines in a single call, use the

	API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog to remove the machine from.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@param machine Machine to remove from the catalog. May be specified by name, ID, or SID. If param is Name, currently it should get rid of '\\\\' and replace it using '|'.             For instance, if a MachineName is \"DomainA\\NameB\", the param will be \"DomainA|NameB\".
	@return ApiMachineCatalogsRemoveMachineCatalogMachineRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogMachine(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	return ApiMachineCatalogsRemoveMachineCatalogMachineRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
		machine:    machine,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogMachineExecute(r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRemoveMachineCatalogMachine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Machines/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	machine             string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	xAdminCredential    *string
	accept              *string
	citrixLocale        *string
	deleteAccount       *MachineAccountDeleteOption
}

// MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest struct {
	ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetMachine returns the machine parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetMachine() string {
	return r.machine
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAdminCredential returns the xAdminCredential parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetXAdminCredential() *string {
	return r.xAdminCredential
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetDeleteAccount returns the deleteAccount parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) GetDeleteAccount() *MachineAccountDeleteOption {
	return r.deleteAccount
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) UserAgent(userAgent string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) Accept(accept string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Specifies what to do with the machine account in AD.  Optional; default is None.
func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) DeleteAccount(deleteAccount MachineAccountDeleteOption) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	r.deleteAccount = &deleteAccount
	return r
}

func (r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRemoveMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsRemoveMachineCatalogMachineAccount Remove a machine account from the machine catalog.

Remove a machine account from the machine catalog. This is only relevant for machine catalogs where ProvisioningType is MCS.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog to remove the machine account from.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@param machine Machine account to remove.  May be specified by SamName, UPN, or SID.
	@return ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
		machine:    machine,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogMachineAccountExecute(r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRemoveMachineCatalogMachineAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MachineAccounts/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.deleteAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAccount", r.deleteAccount, "form", "")
	} else {
		var defaultValue MachineAccountDeleteOption = "None"
		r.deleteAccount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRemoveMachineCatalogTagsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	tagNameOrId         string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// MockApiMachineCatalogsRemoveMachineCatalogTagsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsRemoveMachineCatalogTagsRequest struct {
	ApiMachineCatalogsRemoveMachineCatalogTagsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetTagNameOrId returns the tagNameOrId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetTagNameOrId() string {
	return r.tagNameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsRemoveMachineCatalogTagsRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsRemoveMachineCatalogTagsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) UserAgent(userAgent string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) Accept(accept string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRemoveMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsRemoveMachineCatalogTags Remove a tag from a machine catalog.

Remove a tag from a machine catalog.  Does not delete the tag,
only its association to the machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@param tagNameOrId Name or ID of the tag.
	@return ApiMachineCatalogsRemoveMachineCatalogTagsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	return ApiMachineCatalogsRemoveMachineCatalogTagsRequest{
		ApiService:  a,
		ctx:         ctx,
		nameOrId:    nameOrId,
		tagNameOrId: tagNameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogTagsExecute(r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRemoveMachineCatalogTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Tags/{tagNameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagNameOrId"+"}", url.PathEscape(parameterValueToString(r.tagNameOrId, "tagNameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	force               *bool
	async               *bool
}

// MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest struct {
	ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetForce returns the force parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetForce() *bool {
	return r.force
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) UserAgent(userAgent string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Accept(accept string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, VDA upgrade schedules existing with all machines within the catalog will be removed except those upgrade status in progressing. If &#x60;false&#x60;, only the perform removing when catalog level schedule not started.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Force(force bool) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.force = &force
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be removed as a background task.
func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRemoveMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsRemoveMachineCatalogUpgradeSchedule Remove a pending VDA upgrade schedule for a machine catalog.

A VDA upgrade schedule can only be cancelled for a machine catalog
when the upgrade status is waiting to start. If the current upgrade is
in another status, the operation fails with HTTP response status 404.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRemoveMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRemoveMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	} else {
		var defaultValue bool = false
		r.force = &defaultValue
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	repairOption        *MachineAccountRepairOption
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	xAdminCredential    *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest struct {
	ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetRepairOption returns the repairOption parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetRepairOption() *MachineAccountRepairOption {
	return r.repairOption
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAdminCredential returns the xAdminCredential parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetXAdminCredential() *string {
	return r.xAdminCredential
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// The repair option of the machine accounts
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) RepairOption(repairOption MachineAccountRepairOption) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.repairOption = &repairOption
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) UserAgent(userAgent string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) Authorization(authorization string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) Accept(accept string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the machine accounts repair will be performed as a background task.
func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) Async(async bool) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsRepairMachineCatalogMachineAccountsExecute(r)
}

/*
MachineCatalogsRepairMachineCatalogMachineAccounts Repair all machine accounts in a machine catalog.

Repair all machine accounts in a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog.
	@return ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRepairMachineCatalogMachineAccounts(ctx context.Context, nameOrId string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	return ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRepairMachineCatalogMachineAccountsExecute(r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRepairMachineCatalogMachineAccounts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$repairMachineAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.repairOption == nil {
		return nil, reportError("repairOption is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "repairOption", r.repairOption, "form", "")
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest struct {
	ctx                        context.Context
	ApiService                 MachineCatalogsAPIsDAAS
	citrixCustomerId           *string
	citrixInstanceId           *string
	nameOrId                   string
	rebootMachinesRequestModel *RebootMachinesRequestModel
	userAgent                  *string
	authorization              *string
	citrixTransactionId        *string
	xAdminCredential           *string
	accept                     *string
	citrixLocale               *string
	async                      *bool
}

// MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest struct {
	ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetRebootMachinesRequestModel returns the rebootMachinesRequestModel parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetRebootMachinesRequestModel() *RebootMachinesRequestModel {
	return r.rebootMachinesRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAdminCredential returns the xAdminCredential parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetXAdminCredential() *string {
	return r.xAdminCredential
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details about the image update to be performed.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) RebootMachinesRequestModel(rebootMachinesRequestModel RebootMachinesRequestModel) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.rebootMachinesRequestModel = &rebootMachinesRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) UserAgent(userAgent string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Authorization(authorization string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Accept(accept string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Due to the long-running nature of the update operation, it cannot complete synchronously, and always initiates an asynchronous job to run to completion.  If the &#x60;async&#x60; parameter is &#x60;true&#x60;, the only difference is that instead of returning the initial job status in the payload, the response is instead &#x60;202&#x60; with the &#x60;Location&#x60; header pointing to the job status API.  This may be desirable for clients that wish to unify their logic for handling asynchronous jobs.  The task will have JobType . When the task is complete it will redirect to . The job&#39;s  will contain properties:   * _Id_ - ID of the machine catalog for which the provisioning scheme is being updated, * _Name_ - Name of the machine catalog for which the provisioning scheme is being updated.
func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Async(async bool) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsRollbackMachineCatalogProvisioningSchemeExecute(r)
}

/*
MachineCatalogsRollbackMachineCatalogProvisioningScheme Rollback the machine catalog's provisioning scheme.

Rollback the machine catalog's provisioning scheme.

Only valid when the machine catalog's ProvisioningType is MCS.

Provides the ability to roll back the hard disk image used to provision
virtual machines. If the provisioning scheme has CleanOnBoot equal to
`true`, then the next time that virtual machines are started, their
hard disks are updated to this new image. Regardless of CleanOnBoot,
all new virtual machines created after this call succeeds will use this
new hard disk image.

*Note:* The provisioning scheme for a machine catalog cannot be
changed while any provisioning tasks are already executing for the
machine catalog.  Cancel existing provisioning tasks or wait for
their completion before updating the provisioning scheme.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRollbackMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	return ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return JobResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsRollbackMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsRollbackMachineCatalogProvisioningScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$RollbackProvisioningScheme"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.rebootMachinesRequestModel == nil {
		return localVarReturnValue, nil, reportError("rebootMachinesRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.rebootMachinesRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsSetMachineCatalogTagsRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	tagsRequestModel    *TagsRequestModel
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// MockApiMachineCatalogsSetMachineCatalogTagsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsSetMachineCatalogTagsRequest struct {
	ApiMachineCatalogsSetMachineCatalogTagsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetTagsRequestModel returns the tagsRequestModel parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetTagsRequestModel() *TagsRequestModel {
	return r.tagsRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsSetMachineCatalogTagsRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsSetMachineCatalogTagsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details of the tags to set on the machine catalog.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) TagsRequestModel(tagsRequestModel TagsRequestModel) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.tagsRequestModel = &tagsRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) UserAgent(userAgent string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) Authorization(authorization string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) Accept(accept string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) Async(async bool) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsSetMachineCatalogTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsSetMachineCatalogTagsExecute(r)
}

/*
MachineCatalogsSetMachineCatalogTags Set tags associated with a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsSetMachineCatalogTagsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsSetMachineCatalogTags(ctx context.Context, nameOrId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	return ApiMachineCatalogsSetMachineCatalogTagsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsSetMachineCatalogTagsExecute(r ApiMachineCatalogsSetMachineCatalogTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsSetMachineCatalogTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/Tags"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.tagsRequestModel == nil {
		return nil, reportError("tagsRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.tagsRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTestMachineCatalogRequest struct {
	ctx                 context.Context
	ApiService          MachineCatalogsAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	nameOrId            string
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// MockApiMachineCatalogsTestMachineCatalogRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsTestMachineCatalogRequest struct {
	ApiMachineCatalogsTestMachineCatalogRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsTestMachineCatalogRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsTestMachineCatalogRequest) Execute() (*MachineCatalogTestResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsTestMachineCatalogRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsTestMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsTestMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsTestMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsTestMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTestMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsTestMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsTestMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsTestMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the tests will run as a background task. This is recommended as the tests may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType TestMachineCatalog. When the task is complete it will redirect to GetJobResults. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being tested, * _Name_ - Name of the machine catalog being tested.
func (r ApiMachineCatalogsTestMachineCatalogRequest) Async(async bool) ApiMachineCatalogsTestMachineCatalogRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsTestMachineCatalogRequest) Execute() (*MachineCatalogTestResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsTestMachineCatalogExecute(r)
}

/*
MachineCatalogsTestMachineCatalog Run tests on a machine catalog and create a test report.

Run tests on a machine catalog and create a test report.  Obtain the
most recent report from
GetMachineCatalogTestReport.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog to test.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsTestMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsTestMachineCatalogRequest {
	return ApiMachineCatalogsTestMachineCatalogRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return MachineCatalogTestResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestMachineCatalogExecute(r ApiMachineCatalogsTestMachineCatalogRequest) (*MachineCatalogTestResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineCatalogTestResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsTestMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$test"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsTestMachineCatalogExistsRequest struct {
	ctx                          context.Context
	ApiService                   MachineCatalogsAPIsDAAS
	citrixCustomerId             *string
	citrixInstanceId             *string
	catalogNameCheckRequestModel *CatalogNameCheckRequestModel
	userAgent                    *string
	authorization                *string
	citrixTransactionId          *string
	accept                       *string
	citrixLocale                 *string
}

// MockApiMachineCatalogsTestMachineCatalogExistsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsTestMachineCatalogExistsRequest struct {
	ApiMachineCatalogsTestMachineCatalogExistsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetCatalogNameCheckRequestModel returns the catalogNameCheckRequestModel parameter
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetCatalogNameCheckRequestModel() *CatalogNameCheckRequestModel {
	return r.catalogNameCheckRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsTestMachineCatalogExistsRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsTestMachineCatalogExistsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Name of the machine catalog.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CatalogNameCheckRequestModel(catalogNameCheckRequestModel CatalogNameCheckRequestModel) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.catalogNameCheckRequestModel = &catalogNameCheckRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) UserAgent(userAgent string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) Authorization(authorization string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) Accept(accept string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsTestMachineCatalogExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTestMachineCatalogExistsExecute(r)
}

/*
MachineCatalogsTestMachineCatalogExists Test the existence of a machine catalog by name.

Check for the existence of a machine catalog by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMachineCatalogsTestMachineCatalogExistsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestMachineCatalogExists(ctx context.Context) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	return ApiMachineCatalogsTestMachineCatalogExistsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestMachineCatalogExistsExecute(r ApiMachineCatalogsTestMachineCatalogExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsTestMachineCatalogExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/$checkCatalogName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.catalogNameCheckRequestModel == nil {
		return nil, reportError("catalogNameCheckRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.catalogNameCheckRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest struct {
	ctx                               context.Context
	ApiService                        MachineCatalogsAPIsDAAS
	citrixCustomerId                  *string
	citrixInstanceId                  *string
	nameOrId                          string
	remotePCEnrollmentScopeCheckModel *RemotePCEnrollmentScopeCheckModel
	userAgent                         *string
	authorization                     *string
	citrixTransactionId               *string
	accept                            *string
	citrixLocale                      *string
}

// MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest struct {
	ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetRemotePCEnrollmentScopeCheckModel returns the remotePCEnrollmentScopeCheckModel parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetRemotePCEnrollmentScopeCheckModel() *RemotePCEnrollmentScopeCheckModel {
	return r.remotePCEnrollmentScopeCheckModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Request model that contains distinguished name of an OU containing machines allowed to enroll as remote PCs.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) RemotePCEnrollmentScopeCheckModel(remotePCEnrollmentScopeCheckModel RemotePCEnrollmentScopeCheckModel) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.remotePCEnrollmentScopeCheckModel = &remotePCEnrollmentScopeCheckModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) UserAgent(userAgent string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) Authorization(authorization string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) Accept(accept string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsTestRemotePCEnrollmentScopeExistsExecute(r)
}

/*
MachineCatalogsTestRemotePCEnrollmentScopeExists Check for the existence of a RemotePC enrollment scope by name in the request body. Use HttpPost and take name in body as this name may be very long, and cause url too long exception.

Check for the existence of a RemotePC enrollment scope by name. Note that
RemotePC enrollment scope names must be unique within the site, so the
`nameOrId` parameter does not affect whether the RemotePC enrollment scope
name is found.
If the name is found to be available, this returns 404 Not Found.
If a RemotePC enrollment scope by that name exists and is associated with the
specified machine catalog, this returns 204 No Content. If a RemotePC
enrollment scope by that name exists and is associated with a different
machine catalog, this returns 303 See Other, and the `Location`
response header refers to location of the machine catalog which is associated
by the RemotePC enrollment scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	return ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsTestRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsTestRemotePCEnrollmentScopeExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/RemotePCEnrollmentScopes/$checkScopeName"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.remotePCEnrollmentScopeCheckModel == nil {
		return nil, reportError("remotePCEnrollmentScopeCheckModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.remotePCEnrollmentScopeCheckModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsUpdateMachineCatalogRequest struct {
	ctx                              context.Context
	ApiService                       MachineCatalogsAPIsDAAS
	citrixCustomerId                 *string
	citrixInstanceId                 *string
	nameOrId                         string
	updateMachineCatalogRequestModel *UpdateMachineCatalogRequestModel
	userAgent                        *string
	authorization                    *string
	citrixTransactionId              *string
	xAccessToken                     *string
	accept                           *string
	citrixLocale                     *string
	async                            *bool
}

// MockApiMachineCatalogsUpdateMachineCatalogRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsUpdateMachineCatalogRequest struct {
	ApiMachineCatalogsUpdateMachineCatalogRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUpdateMachineCatalogRequestModel returns the updateMachineCatalogRequestModel parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetUpdateMachineCatalogRequestModel() *UpdateMachineCatalogRequestModel {
	return r.updateMachineCatalogRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAccessToken returns the xAccessToken parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetXAccessToken() *string {
	return r.xAccessToken
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsUpdateMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsUpdateMachineCatalogRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Properties of the machine catalog to update.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) UpdateMachineCatalogRequestModel(updateMachineCatalogRequestModel UpdateMachineCatalogRequestModel) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.updateMachineCatalogRequestModel = &updateMachineCatalogRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) UserAgent(userAgent string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) Authorization(authorization string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Access token to use when performing the operation. If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; UTF8-encoded, then base64-encoded, then the \&quot;Bearer\&quot; scheme prepended.  Example: Bearer bGljaGVuZy5saW5AY2l0cml4LmNvbQ&#x3D;&#x3D;
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) XAccessToken(xAccessToken string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.xAccessToken = &xAccessToken
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) Accept(accept string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the machine catalog (and associated objects) will be updated as a background task. The task will have JobType UpdateMachineCatalog. When the task is complete it will redirect to GetMachineCatalog. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine catalog being updated, * _Name_ - Name of the machine catalog being updated.
func (r ApiMachineCatalogsUpdateMachineCatalogRequest) Async(async bool) ApiMachineCatalogsUpdateMachineCatalogRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsUpdateMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsUpdateMachineCatalogExecute(r)
}

/*
MachineCatalogsUpdateMachineCatalog Update a machine catalog.

Update a machine catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog to update.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsUpdateMachineCatalogRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	return ApiMachineCatalogsUpdateMachineCatalogRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return MachineCatalogDetailResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogExecute(r ApiMachineCatalogsUpdateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsUpdateMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.updateMachineCatalogRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateMachineCatalogRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAccessToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AccessToken", r.xAccessToken, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.updateMachineCatalogRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest struct {
	ctx                              context.Context
	ApiService                       MachineCatalogsAPIsDAAS
	citrixCustomerId                 *string
	citrixInstanceId                 *string
	nameOrId                         string
	machine                          string
	updateMachineAccountRequestModel *UpdateMachineAccountRequestModel
	userAgent                        *string
	authorization                    *string
	citrixTransactionId              *string
	xAdminCredential                 *string
	accept                           *string
	citrixLocale                     *string
}

// MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest struct {
	ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetMachine returns the machine parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetMachine() string {
	return r.machine
}

// GetUpdateMachineAccountRequestModel returns the updateMachineAccountRequestModel parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetUpdateMachineAccountRequestModel() *UpdateMachineAccountRequestModel {
	return r.updateMachineAccountRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetXAdminCredential returns the xAdminCredential parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetXAdminCredential() *string {
	return r.xAdminCredential
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// New details for the machine account record.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) UpdateMachineAccountRequestModel(updateMachineAccountRequestModel UpdateMachineAccountRequestModel) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.updateMachineAccountRequestModel = &updateMachineAccountRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) UserAgent(userAgent string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) Authorization(authorization string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) XAdminCredential(xAdminCredential string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) Accept(accept string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) Execute() (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsUpdateMachineCatalogMachineAccountExecute(r)
}

/*
MachineCatalogsUpdateMachineCatalogMachineAccount Update a machine account within the machine catalog.

Update a machine account within the machine catalog.  This is typically used to reset or
update the machine password so that the site is able to apply the machine account to a
provisioned VM.

This is only relevant for machine catalogs where ProvisioningType is MCS.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog containing the machine account.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@param machine Machine account to update.  May be specified by SamName, UPN, or SID.
	@return ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
		machine:    machine,
	}
}

// Execute executes the request
//
//	@return ProvisioningSchemeMachineAccountResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogMachineAccountExecute(r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProvisioningSchemeMachineAccountResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsUpdateMachineCatalogMachineAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/MachineAccounts/{machine}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine"+"}", url.PathEscape(parameterValueToString(r.machine, "machine")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.updateMachineAccountRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateMachineAccountRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.updateMachineAccountRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest struct {
	ctx                                                context.Context
	ApiService                                         MachineCatalogsAPIsDAAS
	citrixCustomerId                                   *string
	citrixInstanceId                                   *string
	nameOrId                                           string
	updateMachineCatalogProvisioningSchemeRequestModel *UpdateMachineCatalogProvisioningSchemeRequestModel
	userAgent                                          *string
	authorization                                      *string
	citrixTransactionId                                *string
	accept                                             *string
	citrixLocale                                       *string
	async                                              *bool
}

// MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest struct {
	ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUpdateMachineCatalogProvisioningSchemeRequestModel returns the updateMachineCatalogProvisioningSchemeRequestModel parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetUpdateMachineCatalogProvisioningSchemeRequestModel() *UpdateMachineCatalogProvisioningSchemeRequestModel {
	return r.updateMachineCatalogProvisioningSchemeRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details about the image update to be performed.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) UpdateMachineCatalogProvisioningSchemeRequestModel(updateMachineCatalogProvisioningSchemeRequestModel UpdateMachineCatalogProvisioningSchemeRequestModel) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.updateMachineCatalogProvisioningSchemeRequestModel = &updateMachineCatalogProvisioningSchemeRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) UserAgent(userAgent string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Authorization(authorization string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Accept(accept string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// Due to the long-running nature of the update operation, it cannot complete synchronously, and always initiates an asynchronous job to run to completion.  If the &#x60;async&#x60; parameter is &#x60;true&#x60;, the only difference is that instead of returning the initial job status in the payload, the response is instead &#x60;202&#x60; with the &#x60;Location&#x60; header pointing to the job status API.  This may be desirable for clients that wish to unify their logic for handling asynchronous jobs.  The task will have JobType . When the task is complete it will redirect to . The job&#39;s  will contain properties:   * _Id_ - ID of the machine catalog for which the provisioning scheme is being updated, * _Name_ - Name of the machine catalog for which the provisioning scheme is being updated, * _MasterImageXDPath_ - Path to the new image specified for the provisioning scheme, in XenApp &amp; XenDesktop path format. * _MasterImageFullPath_ - Path to the new image specified for the provisioning scheme, relative to the root of the API. * _MasterImageRelativePath_ - Path to the new image specified for the provisioning scheme, relative to the resource pool.
func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Async(async bool) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) Execute() (*JobResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsUpdateMachineCatalogProvisioningSchemeExecute(r)
}

/*
MachineCatalogsUpdateMachineCatalogProvisioningScheme Update the machine catalog's provisioning scheme.

Update the machine catalog's provisioning scheme.

Only valid when the machine catalog's ProvisioningType is MCS.

Provides the ability to update the hard disk image used to provision
virtual machines. If the provisioning scheme has CleanOnBoot equal to
`true`, then the next time that virtual machines are started, their
hard disks are updated to this new image. Regardless of CleanOnBoot,
all new virtual machines created after this call succeeds will use this
new hard disk image.

A snapshot or VM template is used rather than a VM, so that the
content of the hard disk for the provisioning scheme can be easily
determined.

The previous hard disk image path is stored into the history (see
).  The
data stored in the history allows for a rollback to be undertaken,
to revert to the previous hard disk image if required.

*Note:* The provisioning scheme for a machine catalog cannot be
changed while any provisioning tasks are already executing for the
machine catalog.  Cancel existing provisioning tasks or wait for
their completion before updating the provisioning scheme.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	return ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return JobResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JobResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsUpdateMachineCatalogProvisioningScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/$UpdateProvisioningScheme"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.updateMachineCatalogProvisioningSchemeRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateMachineCatalogProvisioningSchemeRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.updateMachineCatalogProvisioningSchemeRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest struct {
	ctx                               context.Context
	ApiService                        MachineCatalogsAPIsDAAS
	citrixCustomerId                  *string
	citrixInstanceId                  *string
	nameOrId                          string
	updateUpgradeScheduleRequestModel *UpdateUpgradeScheduleRequestModel
	userAgent                         *string
	authorization                     *string
	citrixTransactionId               *string
	accept                            *string
	citrixLocale                      *string
	async                             *bool
}

// MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest struct {
	ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetUpdateUpgradeScheduleRequestModel returns the updateUpgradeScheduleRequestModel parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetUpdateUpgradeScheduleRequestModel() *UpdateUpgradeScheduleRequestModel {
	return r.updateUpgradeScheduleRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// Details about the updated VDA upgrade schedule.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) UpdateUpgradeScheduleRequestModel(updateUpgradeScheduleRequestModel UpdateUpgradeScheduleRequestModel) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.updateUpgradeScheduleRequestModel = &updateUpgradeScheduleRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) UserAgent(userAgent string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Authorization(authorization string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Accept(accept string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be updated as a background task.
func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Async(async bool) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachineCatalogsUpdateMachineCatalogUpgradeScheduleExecute(r)
}

/*
MachineCatalogsUpdateMachineCatalogUpgradeSchedule Reschedule a pending VDA upgrade schedule for a machine catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog.             If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsUpdateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsUpdateMachineCatalogUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.updateUpgradeScheduleRequestModel == nil {
		return nil, reportError("updateUpgradeScheduleRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.updateUpgradeScheduleRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest struct {
	ctx                                          context.Context
	ApiService                                   MachineCatalogsAPIsDAAS
	citrixCustomerId                             *string
	citrixInstanceId                             *string
	nameOrId                                     string
	vDAComponentsSelectionValidationRequestModel *VDAComponentsSelectionValidationRequestModel
	userAgent                                    *string
	authorization                                *string
	citrixTransactionId                          *string
	accept                                       *string
	citrixLocale                                 *string
	async                                        *bool
}

// MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest wraps the request struct to provide getter methods for testing
type MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest struct {
	ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest
}

// GetCtx returns the context from the request
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetNameOrId returns the nameOrId parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetNameOrId() string {
	return r.nameOrId
}

// GetVDAComponentsSelectionValidationRequestModel returns the vDAComponentsSelectionValidationRequestModel parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetVDAComponentsSelectionValidationRequestModel() *VDAComponentsSelectionValidationRequestModel {
	return r.vDAComponentsSelectionValidationRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Execute() (*VDAComponentsSelectionValidationResponseModel, *http.Response, error) {
	return r.ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixCustomerId(citrixCustomerId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixInstanceId(citrixInstanceId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// More details attached to this validation.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) VDAComponentsSelectionValidationRequestModel(vDAComponentsSelectionValidationRequestModel VDAComponentsSelectionValidationRequestModel) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.vDAComponentsSelectionValidationRequestModel = &vDAComponentsSelectionValidationRequestModel
	return r
}

// User Agent type of the request.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) UserAgent(userAgent string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Authorization(authorization string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixTransactionId(citrixTransactionId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Accept(accept string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) CitrixLocale(citrixLocale string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If async execute.
func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Async(async bool) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	r.async = &async
	return r
}

func (r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) Execute() (*VDAComponentsSelectionValidationResponseModel, *http.Response, error) {
	return r.ApiService.MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute(r)
}

/*
MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection Validate the VDA component selection at catalog level that can be Included/Excluded and features that need enable during an VDA upgrade using VDA Upgrade Service.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param nameOrId Name or ID of the machine catalog. If the catalog is present in a catalog folder,             specify the name in this format: {catalog folder path plus catalog name}.             For example, FolderName1|FolderName2|CatalogName.
	@return ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest
*/
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection(ctx context.Context, nameOrId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	return ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

// Execute executes the request
//
//	@return VDAComponentsSelectionValidationResponseModel
func (a *MachineCatalogsAPIsDAASService) MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute(r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) (*VDAComponentsSelectionValidationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VDAComponentsSelectionValidationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineCatalogsAPIsDAASService.MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MachineCatalogs/{nameOrId}/VDAComponentsAndFeatures/$validate"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.vDAComponentsSelectionValidationRequestModel == nil {
		return localVarReturnValue, nil, reportError("vDAComponentsSelectionValidationRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.vDAComponentsSelectionValidationRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetMockMachineCatalogsAPIsDAAS extracts the MockMachineCatalogsAPIsDAAS from the APIClient.
// This is a convenience function to avoid verbose type assertions in tests.
//
// Example usage:
//
//	mockClient := NewMockAPIClient()
//	mockAPI := GetMockMachineCatalogsAPIsDAAS(mockClient.APIClient)
//	mockAPI.On("OperationExecute", mock.Anything).Return(...)
func GetMockMachineCatalogsAPIsDAAS(client *APIClient) *MockMachineCatalogsAPIsDAAS {
	return client.MachineCatalogsAPIsDAAS.(*MockMachineCatalogsAPIsDAAS)
}

// MockMachineCatalogsAPIsDAAS is a mock implementation of the MachineCatalogsAPIsDAAS interface for testing
var _ MachineCatalogsAPIsDAAS = (*MockMachineCatalogsAPIsDAAS)(nil)

type MockMachineCatalogsAPIsDAAS struct {
	mock.Mock
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsAddMachineCatalogMachine(ctx context.Context, nameOrId string) ApiMachineCatalogsAddMachineCatalogMachineRequest {
	return ApiMachineCatalogsAddMachineCatalogMachineRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsAddMachineCatalogMachineExecute(r ApiMachineCatalogsAddMachineCatalogMachineRequest) (*JobResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*JobResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsAddMachineCatalogMachineAccount(ctx context.Context, nameOrId string) ApiMachineCatalogsAddMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsAddMachineCatalogMachineAccountRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsAddMachineCatalogMachineAccountExecute(r ApiMachineCatalogsAddMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*ProvisioningSchemeMachineAccountResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsAddMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string) ApiMachineCatalogsAddMachineCatalogTagsRequest {
	return ApiMachineCatalogsAddMachineCatalogTagsRequest{
		ctx:         ctx,
		ApiService:  m,
		nameOrId:    nameOrId,
		tagNameOrId: tagNameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsAddMachineCatalogTagsExecute(r ApiMachineCatalogsAddMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*TagResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsCheckMachineCatalogExists(ctx context.Context, name string) ApiMachineCatalogsCheckMachineCatalogExistsRequest {
	return ApiMachineCatalogsCheckMachineCatalogExistsRequest{
		ctx:        ctx,
		ApiService: m,
		name:       name,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsCheckMachineCatalogExistsExecute(r ApiMachineCatalogsCheckMachineCatalogExistsRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsCheckRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string, name string) ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest {
	return ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
		name:       name,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsCheckRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsCheckRemotePCEnrollmentScopeExistsRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsCreateMachineCatalog(ctx context.Context) ApiMachineCatalogsCreateMachineCatalogRequest {
	return ApiMachineCatalogsCreateMachineCatalogRequest{
		ctx:        ctx,
		ApiService: m,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsCreateMachineCatalogExecute(r ApiMachineCatalogsCreateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*MachineCatalogDetailResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsCreateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsCreateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsCreateMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsDeleteMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsDeleteMachineCatalogRequest {
	return ApiMachineCatalogsDeleteMachineCatalogRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsDeleteMachineCatalogExecute(r ApiMachineCatalogsDeleteMachineCatalogRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsDoMachineCatalogSearch(ctx context.Context) ApiMachineCatalogsDoMachineCatalogSearchRequest {
	return ApiMachineCatalogsDoMachineCatalogSearchRequest{
		ctx:        ctx,
		ApiService: m,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsDoMachineCatalogSearchExecute(r ApiMachineCatalogsDoMachineCatalogSearchRequest) (*CatalogSearchResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*CatalogSearchResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsExport(ctx context.Context, nameOrId string) ApiMachineCatalogsExportRequest {
	return ApiMachineCatalogsExportRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsExportExecute(r ApiMachineCatalogsExportRequest) (*ExportMachineCatalogResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*ExportMachineCatalogResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsExportMachineProfile(ctx context.Context, nameOrId string) ApiMachineCatalogsExportMachineProfileRequest {
	return ApiMachineCatalogsExportMachineProfileRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsExportMachineProfileExecute(r ApiMachineCatalogsExportMachineProfileRequest) (*ExportMachineProfileResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*ExportMachineProfileResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogRequest {
	return ApiMachineCatalogsGetMachineCatalogRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogExecute(r ApiMachineCatalogsGetMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*MachineCatalogDetailResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogCostSummary(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogCostSummaryRequest {
	return ApiMachineCatalogsGetMachineCatalogCostSummaryRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogCostSummaryExecute(r ApiMachineCatalogsGetMachineCatalogCostSummaryRequest) (*ResourceCostResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*ResourceCostResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogDailyCost(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogDailyCostRequest {
	return ApiMachineCatalogsGetMachineCatalogDailyCostRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogDailyCostExecute(r ApiMachineCatalogsGetMachineCatalogDailyCostRequest) (*DailyCostResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*DailyCostResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogDeliveryGroupAssociations(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest {
	return ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogDeliveryGroupAssociationsExecute(r ApiMachineCatalogsGetMachineCatalogDeliveryGroupAssociationsRequest) (*DeliveryGroupAssociationResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*DeliveryGroupAssociationResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogEnrollments(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest {
	return ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogEnrollmentsExecute(r ApiMachineCatalogsGetMachineCatalogEnrollmentsRequest) (*EnrollmentResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*EnrollmentResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogLastMasterImage(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest {
	return ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogLastMasterImageExecute(r ApiMachineCatalogsGetMachineCatalogLastMasterImageRequest) (*VMImageResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*VMImageResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogMachineAccounts(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest {
	return ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogMachineAccountsExecute(r ApiMachineCatalogsGetMachineCatalogMachineAccountsRequest) (*ProvisioningSchemeMachineAccountResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*ProvisioningSchemeMachineAccountResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMachinesRequest {
	return ApiMachineCatalogsGetMachineCatalogMachinesRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogMachinesExecute(r ApiMachineCatalogsGetMachineCatalogMachinesRequest) (*MachineResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*MachineResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogMasterImageHistory(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest {
	return ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogMasterImageHistoryExecute(r ApiMachineCatalogsGetMachineCatalogMasterImageHistoryRequest) (*VMImageResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*VMImageResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogStartMenuApplications(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest {
	return ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogStartMenuApplicationsExecute(r ApiMachineCatalogsGetMachineCatalogStartMenuApplicationsRequest) (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*StartMenuApplicationResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogTags(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogTagsRequest {
	return ApiMachineCatalogsGetMachineCatalogTagsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogTagsExecute(r ApiMachineCatalogsGetMachineCatalogTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*TagResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogTestReport(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogTestReportRequest {
	return ApiMachineCatalogsGetMachineCatalogTestReportRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogTestReportExecute(r ApiMachineCatalogsGetMachineCatalogTestReportRequest) (*TestReportResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*TestReportResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogVDAComponentsAndFeatures(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest {
	return ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesExecute(r ApiMachineCatalogsGetMachineCatalogVDAComponentsAndFeaturesRequest) (*MachineCatalogVusComponentResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*MachineCatalogVusComponentResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogVDAUpgradeVersions(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest {
	return ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogVDAUpgradeVersionsExecute(r ApiMachineCatalogsGetMachineCatalogVDAUpgradeVersionsRequest) ([]string, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).([]string), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogs(ctx context.Context) ApiMachineCatalogsGetMachineCatalogsRequest {
	return ApiMachineCatalogsGetMachineCatalogsRequest{
		ctx:        ctx,
		ApiService: m,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogsExecute(r ApiMachineCatalogsGetMachineCatalogsRequest) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*MachineCatalogResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogsAdministrators(ctx context.Context, nameOrId string) ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest {
	return ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogsAdministratorsExecute(r ApiMachineCatalogsGetMachineCatalogsAdministratorsRequest) (*AdministratorResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*AdministratorResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogsV2(ctx context.Context) ApiMachineCatalogsGetMachineCatalogsV2Request {
	return ApiMachineCatalogsGetMachineCatalogsV2Request{
		ctx:        ctx,
		ApiService: m,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsGetMachineCatalogsV2Execute(r ApiMachineCatalogsGetMachineCatalogsV2Request) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*MachineCatalogResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsImportProvisionedVirtualMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsImportProvisionedVirtualMachinesRequest {
	return ApiMachineCatalogsImportProvisionedVirtualMachinesRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsImportProvisionedVirtualMachinesExecute(r ApiMachineCatalogsImportProvisionedVirtualMachinesRequest) (*ImportProvisionedVirtualMachineResponseModelCollection, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*ImportProvisionedVirtualMachineResponseModelCollection), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRebootMachineCatalogMachines(ctx context.Context, nameOrId string) ApiMachineCatalogsRebootMachineCatalogMachinesRequest {
	return ApiMachineCatalogsRebootMachineCatalogMachinesRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRebootMachineCatalogMachinesExecute(r ApiMachineCatalogsRebootMachineCatalogMachinesRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRemoveMachineCatalogMachine(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsRemoveMachineCatalogMachineRequest {
	return ApiMachineCatalogsRemoveMachineCatalogMachineRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
		machine:    machine,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRemoveMachineCatalogMachineExecute(r ApiMachineCatalogsRemoveMachineCatalogMachineRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRemoveMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
		machine:    machine,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRemoveMachineCatalogMachineAccountExecute(r ApiMachineCatalogsRemoveMachineCatalogMachineAccountRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRemoveMachineCatalogTags(ctx context.Context, nameOrId string, tagNameOrId string) ApiMachineCatalogsRemoveMachineCatalogTagsRequest {
	return ApiMachineCatalogsRemoveMachineCatalogTagsRequest{
		ctx:         ctx,
		ApiService:  m,
		nameOrId:    nameOrId,
		tagNameOrId: tagNameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRemoveMachineCatalogTagsExecute(r ApiMachineCatalogsRemoveMachineCatalogTagsRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRemoveMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRemoveMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsRemoveMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRepairMachineCatalogMachineAccounts(ctx context.Context, nameOrId string) ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest {
	return ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRepairMachineCatalogMachineAccountsExecute(r ApiMachineCatalogsRepairMachineCatalogMachineAccountsRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRollbackMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string) ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest {
	return ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsRollbackMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsRollbackMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*JobResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsSetMachineCatalogTags(ctx context.Context, nameOrId string) ApiMachineCatalogsSetMachineCatalogTagsRequest {
	return ApiMachineCatalogsSetMachineCatalogTagsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsSetMachineCatalogTagsExecute(r ApiMachineCatalogsSetMachineCatalogTagsRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsTestMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsTestMachineCatalogRequest {
	return ApiMachineCatalogsTestMachineCatalogRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsTestMachineCatalogExecute(r ApiMachineCatalogsTestMachineCatalogRequest) (*MachineCatalogTestResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*MachineCatalogTestResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsTestMachineCatalogExists(ctx context.Context) ApiMachineCatalogsTestMachineCatalogExistsRequest {
	return ApiMachineCatalogsTestMachineCatalogExistsRequest{
		ctx:        ctx,
		ApiService: m,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsTestMachineCatalogExistsExecute(r ApiMachineCatalogsTestMachineCatalogExistsRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsTestRemotePCEnrollmentScopeExists(ctx context.Context, nameOrId string) ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest {
	return ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsTestRemotePCEnrollmentScopeExistsExecute(r ApiMachineCatalogsTestRemotePCEnrollmentScopeExistsRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsUpdateMachineCatalog(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogRequest {
	return ApiMachineCatalogsUpdateMachineCatalogRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsUpdateMachineCatalogExecute(r ApiMachineCatalogsUpdateMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*MachineCatalogDetailResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsUpdateMachineCatalogMachineAccount(ctx context.Context, nameOrId string, machine string) ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest {
	return ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
		machine:    machine,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsUpdateMachineCatalogMachineAccountExecute(r ApiMachineCatalogsUpdateMachineCatalogMachineAccountRequest) (*ProvisioningSchemeMachineAccountResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*ProvisioningSchemeMachineAccountResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsUpdateMachineCatalogProvisioningScheme(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest {
	return ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsUpdateMachineCatalogProvisioningSchemeExecute(r ApiMachineCatalogsUpdateMachineCatalogProvisioningSchemeRequest) (*JobResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*JobResponseModel), args.Get(1).(*http.Response), args.Error(2)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsUpdateMachineCatalogUpgradeSchedule(ctx context.Context, nameOrId string) ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest {
	return ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsUpdateMachineCatalogUpgradeScheduleExecute(r ApiMachineCatalogsUpdateMachineCatalogUpgradeScheduleRequest) (*http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*http.Response), args.Error(1)
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelection(ctx context.Context, nameOrId string) ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest {
	return ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest{
		ctx:        ctx,
		ApiService: m,
		nameOrId:   nameOrId,
	}
}

func (m *MockMachineCatalogsAPIsDAAS) MachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionExecute(r ApiMachineCatalogsValidateMachineCatalogVDAComponentsAndFeaturesSelectionRequest) (*VDAComponentsSelectionValidationResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*VDAComponentsSelectionValidationResponseModel), args.Get(1).(*http.Response), args.Error(2)
}
