/*
Citrix Virtual Apps and Desktops Rest API for Developer Portal

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: devportal-onprem-ga
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	"github.com/stretchr/testify/mock"
)

type BatchAPIsDAAS interface {

	/*
			BatchDoBatchRequest Perform a batch request.

			Perform a batch request.  This allows the client to submit more than one request
		at a time.  The requests may be performed in parallel and may not have any
		dependencies between them.  The result will be returned once all requests have
		completed.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiBatchDoBatchRequestRequest
	*/
	BatchDoBatchRequest(ctx context.Context) ApiBatchDoBatchRequestRequest

	// BatchDoBatchRequestExecute executes the request
	//  @return BatchResponseModel
	BatchDoBatchRequestExecute(r ApiBatchDoBatchRequestRequest) (*BatchResponseModel, *http.Response, error)
}

// BatchAPIsDAASService BatchAPIsDAAS service
type BatchAPIsDAASService service

type ApiBatchDoBatchRequestRequest struct {
	ctx                 context.Context
	ApiService          BatchAPIsDAAS
	citrixCustomerId    *string
	citrixInstanceId    *string
	batchRequestModel   *BatchRequestModel
	userAgent           *string
	authorization       *string
	citrixTransactionId *string
	accept              *string
	citrixLocale        *string
	async               *bool
}

// MockApiBatchDoBatchRequestRequest wraps the request struct to provide getter methods for testing
type MockApiBatchDoBatchRequestRequest struct {
	ApiBatchDoBatchRequestRequest
}

// GetCtx returns the context from the request
func (r MockApiBatchDoBatchRequestRequest) GetCtx() context.Context {
	return r.ctx
}

// GetCitrixCustomerId returns the citrixCustomerId parameter
func (r MockApiBatchDoBatchRequestRequest) GetCitrixCustomerId() *string {
	return r.citrixCustomerId
}

// GetCitrixInstanceId returns the citrixInstanceId parameter
func (r MockApiBatchDoBatchRequestRequest) GetCitrixInstanceId() *string {
	return r.citrixInstanceId
}

// GetBatchRequestModel returns the batchRequestModel parameter
func (r MockApiBatchDoBatchRequestRequest) GetBatchRequestModel() *BatchRequestModel {
	return r.batchRequestModel
}

// GetUserAgent returns the userAgent parameter
func (r MockApiBatchDoBatchRequestRequest) GetUserAgent() *string {
	return r.userAgent
}

// GetAuthorization returns the authorization parameter
func (r MockApiBatchDoBatchRequestRequest) GetAuthorization() *string {
	return r.authorization
}

// GetCitrixTransactionId returns the citrixTransactionId parameter
func (r MockApiBatchDoBatchRequestRequest) GetCitrixTransactionId() *string {
	return r.citrixTransactionId
}

// GetAccept returns the accept parameter
func (r MockApiBatchDoBatchRequestRequest) GetAccept() *string {
	return r.accept
}

// GetCitrixLocale returns the citrixLocale parameter
func (r MockApiBatchDoBatchRequestRequest) GetCitrixLocale() *string {
	return r.citrixLocale
}

// GetAsync returns the async parameter
func (r MockApiBatchDoBatchRequestRequest) GetAsync() *bool {
	return r.async
}

// Execute delegates to the embedded request's Execute method
func (r MockApiBatchDoBatchRequestRequest) Execute() (*BatchResponseModel, *http.Response, error) {
	return r.ApiBatchDoBatchRequestRequest.Execute()
}

// Citrix Customer ID. Default is &#39;CitrixOnPremises&#39;
func (r ApiBatchDoBatchRequestRequest) CitrixCustomerId(citrixCustomerId string) ApiBatchDoBatchRequestRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Instance (Site) ID.
func (r ApiBatchDoBatchRequestRequest) CitrixInstanceId(citrixInstanceId string) ApiBatchDoBatchRequestRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// List of requests that the server should perform in parallel.
func (r ApiBatchDoBatchRequestRequest) BatchRequestModel(batchRequestModel BatchRequestModel) ApiBatchDoBatchRequestRequest {
	r.batchRequestModel = &batchRequestModel
	return r
}

// User Agent type of the request.
func (r ApiBatchDoBatchRequestRequest) UserAgent(userAgent string) ApiBatchDoBatchRequestRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiBatchDoBatchRequestRequest) Authorization(authorization string) ApiBatchDoBatchRequestRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiBatchDoBatchRequestRequest) CitrixTransactionId(citrixTransactionId string) ApiBatchDoBatchRequestRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Must accept application/json.
func (r ApiBatchDoBatchRequestRequest) Accept(accept string) ApiBatchDoBatchRequestRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiBatchDoBatchRequestRequest) CitrixLocale(citrixLocale string) ApiBatchDoBatchRequestRequest {
	r.citrixLocale = &citrixLocale
	return r
}

// If &#x60;true&#x60;, the batch request will be processed as a background task. This is recommended, since a batch request that takes more than 90 seconds to execute may time out, and results may be lost. The task will have JobType Batch. The SubJobs will correspond to the items in the batch request. When the task is complete it will redirect to GetJobResults. The job&#39;s Parameters will contain no properties.
func (r ApiBatchDoBatchRequestRequest) Async(async bool) ApiBatchDoBatchRequestRequest {
	r.async = &async
	return r
}

func (r ApiBatchDoBatchRequestRequest) Execute() (*BatchResponseModel, *http.Response, error) {
	return r.ApiService.BatchDoBatchRequestExecute(r)
}

/*
BatchDoBatchRequest Perform a batch request.

Perform a batch request.  This allows the client to submit more than one request
at a time.  The requests may be performed in parallel and may not have any
dependencies between them.  The result will be returned once all requests have
completed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBatchDoBatchRequestRequest
*/
func (a *BatchAPIsDAASService) BatchDoBatchRequest(ctx context.Context) ApiBatchDoBatchRequestRequest {
	return ApiBatchDoBatchRequestRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BatchResponseModel
func (a *BatchAPIsDAASService) BatchDoBatchRequestExecute(r ApiBatchDoBatchRequestRequest) (*BatchResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIsDAASService.BatchDoBatchRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/$batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.batchRequestModel == nil {
		return localVarReturnValue, nil, reportError("batchRequestModel is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "simple", "")
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "simple", "")
	}
	// body params
	localVarPostBody = r.batchRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetMockBatchAPIsDAAS extracts the MockBatchAPIsDAAS from the APIClient.
// This is a convenience function to avoid verbose type assertions in tests.
//
// Example usage:
//
//	mockClient := NewMockAPIClient()
//	mockAPI := GetMockBatchAPIsDAAS(mockClient.APIClient)
//	mockAPI.On("OperationExecute", mock.Anything).Return(...)
func GetMockBatchAPIsDAAS(client *APIClient) *MockBatchAPIsDAAS {
	return client.BatchAPIsDAAS.(*MockBatchAPIsDAAS)
}

// MockBatchAPIsDAAS is a mock implementation of the BatchAPIsDAAS interface for testing
var _ BatchAPIsDAAS = (*MockBatchAPIsDAAS)(nil)

type MockBatchAPIsDAAS struct {
	mock.Mock
}

func (m *MockBatchAPIsDAAS) BatchDoBatchRequest(ctx context.Context) ApiBatchDoBatchRequestRequest {
	return ApiBatchDoBatchRequestRequest{
		ctx:        ctx,
		ApiService: m,
	}
}

func (m *MockBatchAPIsDAAS) BatchDoBatchRequestExecute(r ApiBatchDoBatchRequestRequest) (*BatchResponseModel, *http.Response, error) {
	args := m.Called(r)
	return args.Get(0).(*BatchResponseModel), args.Get(1).(*http.Response), args.Error(2)
}
