/*
Citrix Virtual Apps and Desktops Rest API for Developer Portal

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: devportal-ga
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TenantsAPIsDAASService TenantsAPIsDAAS service
type TenantsAPIsDAASService service

type ApiTenantsGetTenantRequest struct {
	ctx context.Context
	ApiService *TenantsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiTenantsGetTenantRequest) CitrixCustomerId(citrixCustomerId string) ApiTenantsGetTenantRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiTenantsGetTenantRequest) CitrixInstanceId(citrixInstanceId string) ApiTenantsGetTenantRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTenantsGetTenantRequest) UserAgent(userAgent string) ApiTenantsGetTenantRequest {
	r.userAgent = &userAgent
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTenantsGetTenantRequest) Authorization(authorization string) ApiTenantsGetTenantRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTenantsGetTenantRequest) CitrixTransactionId(citrixTransactionId string) ApiTenantsGetTenantRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiTenantsGetTenantRequest) XActionName(xActionName string) ApiTenantsGetTenantRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiTenantsGetTenantRequest) Accept(accept string) ApiTenantsGetTenantRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTenantsGetTenantRequest) CitrixLocale(citrixLocale string) ApiTenantsGetTenantRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTenantsGetTenantRequest) Execute() (*TenantDetailResponseModel, *http.Response, error) {
	return r.ApiService.TenantsGetTenantExecute(r)
}

/*
TenantsGetTenant Get a single tenant from the site.

Get a single tenant from the site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the tenant.
 @return ApiTenantsGetTenantRequest
*/
func (a *TenantsAPIsDAASService) TenantsGetTenant(ctx context.Context, nameOrId string) ApiTenantsGetTenantRequest {
	return ApiTenantsGetTenantRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return TenantDetailResponseModel
func (a *TenantsAPIsDAASService) TenantsGetTenantExecute(r ApiTenantsGetTenantRequest) (*TenantDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantsAPIsDAASService.TenantsGetTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tenants/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenantsGetTenantApplicationGroupsRequest struct {
	ctx context.Context
	ApiService *TenantsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	includeShared *bool
	limit *int32
	continuationToken *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiTenantsGetTenantApplicationGroupsRequest) CitrixCustomerId(citrixCustomerId string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiTenantsGetTenantApplicationGroupsRequest) CitrixInstanceId(citrixInstanceId string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTenantsGetTenantApplicationGroupsRequest) UserAgent(userAgent string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, shared application groups (those not associated with any tenant) are included in the results in addition to the application groups that are associated with the specified tenant.
func (r ApiTenantsGetTenantApplicationGroupsRequest) IncludeShared(includeShared bool) ApiTenantsGetTenantApplicationGroupsRequest {
	r.includeShared = &includeShared
	return r
}

// The max number of application groups returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTenantsGetTenantApplicationGroupsRequest) Limit(limit int32) ApiTenantsGetTenantApplicationGroupsRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiTenantsGetTenantApplicationGroupsRequest) ContinuationToken(continuationToken string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTenantsGetTenantApplicationGroupsRequest) Authorization(authorization string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTenantsGetTenantApplicationGroupsRequest) CitrixTransactionId(citrixTransactionId string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiTenantsGetTenantApplicationGroupsRequest) XActionName(xActionName string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiTenantsGetTenantApplicationGroupsRequest) Accept(accept string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTenantsGetTenantApplicationGroupsRequest) CitrixLocale(citrixLocale string) ApiTenantsGetTenantApplicationGroupsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTenantsGetTenantApplicationGroupsRequest) Execute() (*ApplicationGroupResponseModelCollection, *http.Response, error) {
	return r.ApiService.TenantsGetTenantApplicationGroupsExecute(r)
}

/*
TenantsGetTenantApplicationGroups Get application groups associated with a tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the tenant.
 @return ApiTenantsGetTenantApplicationGroupsRequest
*/
func (a *TenantsAPIsDAASService) TenantsGetTenantApplicationGroups(ctx context.Context, nameOrId string) ApiTenantsGetTenantApplicationGroupsRequest {
	return ApiTenantsGetTenantApplicationGroupsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return ApplicationGroupResponseModelCollection
func (a *TenantsAPIsDAASService) TenantsGetTenantApplicationGroupsExecute(r ApiTenantsGetTenantApplicationGroupsRequest) (*ApplicationGroupResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationGroupResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantsAPIsDAASService.TenantsGetTenantApplicationGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tenants/{nameOrId}/ApplicationGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.includeShared != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeShared", r.includeShared, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenantsGetTenantApplicationsRequest struct {
	ctx context.Context
	ApiService *TenantsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	includeShared *bool
	limit *int32
	continuationToken *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiTenantsGetTenantApplicationsRequest) CitrixCustomerId(citrixCustomerId string) ApiTenantsGetTenantApplicationsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiTenantsGetTenantApplicationsRequest) CitrixInstanceId(citrixInstanceId string) ApiTenantsGetTenantApplicationsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTenantsGetTenantApplicationsRequest) UserAgent(userAgent string) ApiTenantsGetTenantApplicationsRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, shared applications (those not associated with any tenant) are included in the results in addition to the applications that are associated with the specified tenant.
func (r ApiTenantsGetTenantApplicationsRequest) IncludeShared(includeShared bool) ApiTenantsGetTenantApplicationsRequest {
	r.includeShared = &includeShared
	return r
}

// The max number of applications returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTenantsGetTenantApplicationsRequest) Limit(limit int32) ApiTenantsGetTenantApplicationsRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiTenantsGetTenantApplicationsRequest) ContinuationToken(continuationToken string) ApiTenantsGetTenantApplicationsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTenantsGetTenantApplicationsRequest) Authorization(authorization string) ApiTenantsGetTenantApplicationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTenantsGetTenantApplicationsRequest) CitrixTransactionId(citrixTransactionId string) ApiTenantsGetTenantApplicationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiTenantsGetTenantApplicationsRequest) XActionName(xActionName string) ApiTenantsGetTenantApplicationsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiTenantsGetTenantApplicationsRequest) Accept(accept string) ApiTenantsGetTenantApplicationsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTenantsGetTenantApplicationsRequest) CitrixLocale(citrixLocale string) ApiTenantsGetTenantApplicationsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTenantsGetTenantApplicationsRequest) Execute() (*ApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiService.TenantsGetTenantApplicationsExecute(r)
}

/*
TenantsGetTenantApplications Get applications associated with a tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the tenant.
 @return ApiTenantsGetTenantApplicationsRequest
*/
func (a *TenantsAPIsDAASService) TenantsGetTenantApplications(ctx context.Context, nameOrId string) ApiTenantsGetTenantApplicationsRequest {
	return ApiTenantsGetTenantApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return ApplicationResponseModelCollection
func (a *TenantsAPIsDAASService) TenantsGetTenantApplicationsExecute(r ApiTenantsGetTenantApplicationsRequest) (*ApplicationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantsAPIsDAASService.TenantsGetTenantApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tenants/{nameOrId}/Applications"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.includeShared != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeShared", r.includeShared, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenantsGetTenantDeliveryGroupsRequest struct {
	ctx context.Context
	ApiService *TenantsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	includeShared *bool
	limit *int32
	continuationToken *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) CitrixCustomerId(citrixCustomerId string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) CitrixInstanceId(citrixInstanceId string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) UserAgent(userAgent string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, shared delivery groups (those not associated with any tenant) are included in the results in addition to the delivery groups that are associated with the specified tenant.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) IncludeShared(includeShared bool) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.includeShared = &includeShared
	return r
}

// The max number of delivery groups returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) Limit(limit int32) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) ContinuationToken(continuationToken string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTenantsGetTenantDeliveryGroupsRequest) Authorization(authorization string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) CitrixTransactionId(citrixTransactionId string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiTenantsGetTenantDeliveryGroupsRequest) XActionName(xActionName string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) Accept(accept string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTenantsGetTenantDeliveryGroupsRequest) CitrixLocale(citrixLocale string) ApiTenantsGetTenantDeliveryGroupsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTenantsGetTenantDeliveryGroupsRequest) Execute() (*DeliveryGroupResponseModelCollection, *http.Response, error) {
	return r.ApiService.TenantsGetTenantDeliveryGroupsExecute(r)
}

/*
TenantsGetTenantDeliveryGroups Get delivery groups associated with a tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the tenant.
 @return ApiTenantsGetTenantDeliveryGroupsRequest
*/
func (a *TenantsAPIsDAASService) TenantsGetTenantDeliveryGroups(ctx context.Context, nameOrId string) ApiTenantsGetTenantDeliveryGroupsRequest {
	return ApiTenantsGetTenantDeliveryGroupsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return DeliveryGroupResponseModelCollection
func (a *TenantsAPIsDAASService) TenantsGetTenantDeliveryGroupsExecute(r ApiTenantsGetTenantDeliveryGroupsRequest) (*DeliveryGroupResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeliveryGroupResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantsAPIsDAASService.TenantsGetTenantDeliveryGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tenants/{nameOrId}/DeliveryGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.includeShared != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeShared", r.includeShared, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenantsGetTenantDesktopsRequest struct {
	ctx context.Context
	ApiService *TenantsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	includeShared *bool
	limit *int32
	continuationToken *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiTenantsGetTenantDesktopsRequest) CitrixCustomerId(citrixCustomerId string) ApiTenantsGetTenantDesktopsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiTenantsGetTenantDesktopsRequest) CitrixInstanceId(citrixInstanceId string) ApiTenantsGetTenantDesktopsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTenantsGetTenantDesktopsRequest) UserAgent(userAgent string) ApiTenantsGetTenantDesktopsRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, shared desktops (those not associated with any tenant) are included in the results in addition to the desktops that are associated with the specified tenant.
func (r ApiTenantsGetTenantDesktopsRequest) IncludeShared(includeShared bool) ApiTenantsGetTenantDesktopsRequest {
	r.includeShared = &includeShared
	return r
}

// The max number of desktops returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTenantsGetTenantDesktopsRequest) Limit(limit int32) ApiTenantsGetTenantDesktopsRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiTenantsGetTenantDesktopsRequest) ContinuationToken(continuationToken string) ApiTenantsGetTenantDesktopsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTenantsGetTenantDesktopsRequest) Authorization(authorization string) ApiTenantsGetTenantDesktopsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTenantsGetTenantDesktopsRequest) CitrixTransactionId(citrixTransactionId string) ApiTenantsGetTenantDesktopsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiTenantsGetTenantDesktopsRequest) XActionName(xActionName string) ApiTenantsGetTenantDesktopsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiTenantsGetTenantDesktopsRequest) Accept(accept string) ApiTenantsGetTenantDesktopsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTenantsGetTenantDesktopsRequest) CitrixLocale(citrixLocale string) ApiTenantsGetTenantDesktopsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTenantsGetTenantDesktopsRequest) Execute() (*DesktopResponseModelCollection, *http.Response, error) {
	return r.ApiService.TenantsGetTenantDesktopsExecute(r)
}

/*
TenantsGetTenantDesktops Get desktops associated with a tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the tenant.
 @return ApiTenantsGetTenantDesktopsRequest
*/
func (a *TenantsAPIsDAASService) TenantsGetTenantDesktops(ctx context.Context, nameOrId string) ApiTenantsGetTenantDesktopsRequest {
	return ApiTenantsGetTenantDesktopsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return DesktopResponseModelCollection
func (a *TenantsAPIsDAASService) TenantsGetTenantDesktopsExecute(r ApiTenantsGetTenantDesktopsRequest) (*DesktopResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DesktopResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantsAPIsDAASService.TenantsGetTenantDesktops")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tenants/{nameOrId}/Desktops"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.includeShared != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeShared", r.includeShared, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenantsGetTenantHypervisorsRequest struct {
	ctx context.Context
	ApiService *TenantsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	includeShared *bool
	limit *int32
	continuationToken *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiTenantsGetTenantHypervisorsRequest) CitrixCustomerId(citrixCustomerId string) ApiTenantsGetTenantHypervisorsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiTenantsGetTenantHypervisorsRequest) CitrixInstanceId(citrixInstanceId string) ApiTenantsGetTenantHypervisorsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTenantsGetTenantHypervisorsRequest) UserAgent(userAgent string) ApiTenantsGetTenantHypervisorsRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, shared hypervisors (those not associated with any tenant) are included in the results in addition to the hypervisors that are associated with the specified tenant.
func (r ApiTenantsGetTenantHypervisorsRequest) IncludeShared(includeShared bool) ApiTenantsGetTenantHypervisorsRequest {
	r.includeShared = &includeShared
	return r
}

// The max number of hypervisors returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTenantsGetTenantHypervisorsRequest) Limit(limit int32) ApiTenantsGetTenantHypervisorsRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiTenantsGetTenantHypervisorsRequest) ContinuationToken(continuationToken string) ApiTenantsGetTenantHypervisorsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTenantsGetTenantHypervisorsRequest) Authorization(authorization string) ApiTenantsGetTenantHypervisorsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTenantsGetTenantHypervisorsRequest) CitrixTransactionId(citrixTransactionId string) ApiTenantsGetTenantHypervisorsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiTenantsGetTenantHypervisorsRequest) XActionName(xActionName string) ApiTenantsGetTenantHypervisorsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiTenantsGetTenantHypervisorsRequest) Accept(accept string) ApiTenantsGetTenantHypervisorsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTenantsGetTenantHypervisorsRequest) CitrixLocale(citrixLocale string) ApiTenantsGetTenantHypervisorsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTenantsGetTenantHypervisorsRequest) Execute() (*HypervisorResponseModelCollection, *http.Response, error) {
	return r.ApiService.TenantsGetTenantHypervisorsExecute(r)
}

/*
TenantsGetTenantHypervisors Get hypervisors associated with a tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the tenant.
 @return ApiTenantsGetTenantHypervisorsRequest
*/
func (a *TenantsAPIsDAASService) TenantsGetTenantHypervisors(ctx context.Context, nameOrId string) ApiTenantsGetTenantHypervisorsRequest {
	return ApiTenantsGetTenantHypervisorsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return HypervisorResponseModelCollection
func (a *TenantsAPIsDAASService) TenantsGetTenantHypervisorsExecute(r ApiTenantsGetTenantHypervisorsRequest) (*HypervisorResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HypervisorResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantsAPIsDAASService.TenantsGetTenantHypervisors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tenants/{nameOrId}/Hypervisors"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.includeShared != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeShared", r.includeShared, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenantsGetTenantMachineCatalogsRequest struct {
	ctx context.Context
	ApiService *TenantsAPIsDAASService
	nameOrId string
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	includeShared *bool
	limit *int32
	continuationToken *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiTenantsGetTenantMachineCatalogsRequest) CitrixCustomerId(citrixCustomerId string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiTenantsGetTenantMachineCatalogsRequest) CitrixInstanceId(citrixInstanceId string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTenantsGetTenantMachineCatalogsRequest) UserAgent(userAgent string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.userAgent = &userAgent
	return r
}

// If &#x60;true&#x60;, shared machine catalogs (those not associated with any tenant) are included in the results in addition to the machine catalogs that are associated with the specified tenant.
func (r ApiTenantsGetTenantMachineCatalogsRequest) IncludeShared(includeShared bool) ApiTenantsGetTenantMachineCatalogsRequest {
	r.includeShared = &includeShared
	return r
}

// The max number of machine catalogs returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTenantsGetTenantMachineCatalogsRequest) Limit(limit int32) ApiTenantsGetTenantMachineCatalogsRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiTenantsGetTenantMachineCatalogsRequest) ContinuationToken(continuationToken string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTenantsGetTenantMachineCatalogsRequest) Authorization(authorization string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTenantsGetTenantMachineCatalogsRequest) CitrixTransactionId(citrixTransactionId string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiTenantsGetTenantMachineCatalogsRequest) XActionName(xActionName string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiTenantsGetTenantMachineCatalogsRequest) Accept(accept string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTenantsGetTenantMachineCatalogsRequest) CitrixLocale(citrixLocale string) ApiTenantsGetTenantMachineCatalogsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTenantsGetTenantMachineCatalogsRequest) Execute() (*MachineCatalogResponseModelCollection, *http.Response, error) {
	return r.ApiService.TenantsGetTenantMachineCatalogsExecute(r)
}

/*
TenantsGetTenantMachineCatalogs Get machine catalogs associated with a tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the tenant.
 @return ApiTenantsGetTenantMachineCatalogsRequest
*/
func (a *TenantsAPIsDAASService) TenantsGetTenantMachineCatalogs(ctx context.Context, nameOrId string) ApiTenantsGetTenantMachineCatalogsRequest {
	return ApiTenantsGetTenantMachineCatalogsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
	}
}

// Execute executes the request
//  @return MachineCatalogResponseModelCollection
func (a *TenantsAPIsDAASService) TenantsGetTenantMachineCatalogsExecute(r ApiTenantsGetTenantMachineCatalogsRequest) (*MachineCatalogResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantsAPIsDAASService.TenantsGetTenantMachineCatalogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tenants/{nameOrId}/MachineCatalogs"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.includeShared != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeShared", r.includeShared, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTenantsGetTenantsRequest struct {
	ctx context.Context
	ApiService *TenantsAPIsDAASService
	citrixCustomerId *string
	citrixInstanceId *string
	userAgent *string
	limit *int32
	continuationToken *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
	accept *string
	citrixLocale *string
}

// Citrix Cloud Customer ID.
func (r ApiTenantsGetTenantsRequest) CitrixCustomerId(citrixCustomerId string) ApiTenantsGetTenantsRequest {
	r.citrixCustomerId = &citrixCustomerId
	return r
}

// Citrix Cloud Instance (Site) ID.
func (r ApiTenantsGetTenantsRequest) CitrixInstanceId(citrixInstanceId string) ApiTenantsGetTenantsRequest {
	r.citrixInstanceId = &citrixInstanceId
	return r
}

// User Agent type of the request.
func (r ApiTenantsGetTenantsRequest) UserAgent(userAgent string) ApiTenantsGetTenantsRequest {
	r.userAgent = &userAgent
	return r
}

// The max number of tenants returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiTenantsGetTenantsRequest) Limit(limit int32) ApiTenantsGetTenantsRequest {
	r.limit = &limit
	return r
}

// The continuationToken returned by the previous query.
func (r ApiTenantsGetTenantsRequest) ContinuationToken(continuationToken string) ApiTenantsGetTenantsRequest {
	r.continuationToken = &continuationToken
	return r
}

// Citrix Cloud authorization header: CWSAuth Bearer&#x3D;{token}
func (r ApiTenantsGetTenantsRequest) Authorization(authorization string) ApiTenantsGetTenantsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiTenantsGetTenantsRequest) CitrixTransactionId(citrixTransactionId string) ApiTenantsGetTenantsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiTenantsGetTenantsRequest) XActionName(xActionName string) ApiTenantsGetTenantsRequest {
	r.xActionName = &xActionName
	return r
}

// Must accept application/json.
func (r ApiTenantsGetTenantsRequest) Accept(accept string) ApiTenantsGetTenantsRequest {
	r.accept = &accept
	return r
}

// Locale of the request.
func (r ApiTenantsGetTenantsRequest) CitrixLocale(citrixLocale string) ApiTenantsGetTenantsRequest {
	r.citrixLocale = &citrixLocale
	return r
}

func (r ApiTenantsGetTenantsRequest) Execute() (*TenantResponseModelCollection, *http.Response, error) {
	return r.ApiService.TenantsGetTenantsExecute(r)
}

/*
TenantsGetTenants Get the list of all tenants in the site.

Get the list of all tenants in the site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTenantsGetTenantsRequest
*/
func (a *TenantsAPIsDAASService) TenantsGetTenants(ctx context.Context) ApiTenantsGetTenantsRequest {
	return ApiTenantsGetTenantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TenantResponseModelCollection
func (a *TenantsAPIsDAASService) TenantsGetTenantsExecute(r ApiTenantsGetTenantsRequest) (*TenantResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantsAPIsDAASService.TenantsGetTenants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Tenants"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.citrixCustomerId == nil {
		return localVarReturnValue, nil, reportError("citrixCustomerId is required and must be specified")
	}
	if r.citrixInstanceId == nil {
		return localVarReturnValue, nil, reportError("citrixInstanceId is required and must be specified")
	}
	if r.userAgent == nil {
		return localVarReturnValue, nil, reportError("userAgent is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-CustomerId", r.citrixCustomerId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-InstanceId", r.citrixInstanceId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	if r.citrixLocale != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-Locale", r.citrixLocale, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
