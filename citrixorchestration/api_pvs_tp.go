/*
Citrix Virtual Apps and Desktops REST API TECHPREVIEW

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: techpreview
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PvsTPApiService PvsTPApi service
type PvsTPApiService service

type ApiPvsTPGetPvsCollectionsRequest struct {
	ctx context.Context
	ApiService *PvsTPApiService
	serverAddress string
	customerid string
	siteid string
	siteNameOrId *[]string
	resourceLocationNameOrId *string
	forest *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
}

// Name or ID of the PVS site.  Optional.  If not specified, collections from all sites are returned.
func (r ApiPvsTPGetPvsCollectionsRequest) SiteNameOrId(siteNameOrId []string) ApiPvsTPGetPvsCollectionsRequest {
	r.siteNameOrId = &siteNameOrId
	return r
}

// Name or ID of the resource location or zone through which to communicate to the PVS server. Optional; however, if this is not specified then communication to the PVS server may randomly fail based on network firewall rules between resource locations. Not used for on-premises deployments.
func (r ApiPvsTPGetPvsCollectionsRequest) ResourceLocationNameOrId(resourceLocationNameOrId string) ApiPvsTPGetPvsCollectionsRequest {
	r.resourceLocationNameOrId = &resourceLocationNameOrId
	return r
}

// Active Directory forest of the PVS server.  May be different than the AD forest of the machines managed by PVS.   Optional; however, if this is not specified then communication to the PVS server may randomly fail if the site is connected to untrusted forests, and communication is attempted through a forest that is not within the trust scope of the PVS server&#39;s AD forest.   Not used for on-premises deployments.
func (r ApiPvsTPGetPvsCollectionsRequest) Forest(forest string) ApiPvsTPGetPvsCollectionsRequest {
	r.forest = &forest
	return r
}

// If &#x60;true&#x60;, the get pvs collections will be executed as a background task. The task will have JobType GetPvsCollections. When the task is complete it will redirect to GetJobResults.
func (r ApiPvsTPGetPvsCollectionsRequest) Async(async bool) ApiPvsTPGetPvsCollectionsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiPvsTPGetPvsCollectionsRequest) Authorization(authorization string) ApiPvsTPGetPvsCollectionsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiPvsTPGetPvsCollectionsRequest) CitrixTransactionId(citrixTransactionId string) ApiPvsTPGetPvsCollectionsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiPvsTPGetPvsCollectionsRequest) XAdminCredential(xAdminCredential string) ApiPvsTPGetPvsCollectionsRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiPvsTPGetPvsCollectionsRequest) XActionName(xActionName string) ApiPvsTPGetPvsCollectionsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiPvsTPGetPvsCollectionsRequest) Execute() (*PvsCollectionResponseModelCollection, *http.Response, error) {
	return r.ApiService.PvsTPGetPvsCollectionsExecute(r)
}

/*
PvsTPGetPvsCollections Get PVS collections within a site.

Get PVS collections within a site from the PVS server.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverAddress Name or IP of the PVS server.
 @param customerid
 @param siteid
 @return ApiPvsTPGetPvsCollectionsRequest
*/
func (a *PvsTPApiService) PvsTPGetPvsCollections(ctx context.Context, serverAddress string, customerid string, siteid string) ApiPvsTPGetPvsCollectionsRequest {
	return ApiPvsTPGetPvsCollectionsRequest{
		ApiService: a,
		ctx: ctx,
		serverAddress: serverAddress,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return PvsCollectionResponseModelCollection
func (a *PvsTPApiService) PvsTPGetPvsCollectionsExecute(r ApiPvsTPGetPvsCollectionsRequest) (*PvsCollectionResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PvsCollectionResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PvsTPApiService.PvsTPGetPvsCollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Pvs/{serverAddress}/Collections"
	localVarPath = strings.Replace(localVarPath, "{"+"serverAddress"+"}", url.PathEscape(parameterValueToString(r.serverAddress, "serverAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.siteNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteNameOrId", r.siteNameOrId, "csv")
	}
	if r.resourceLocationNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceLocationNameOrId", r.resourceLocationNameOrId, "")
	}
	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPvsTPGetPvsMachinesForCatalogRequest struct {
	ctx context.Context
	ApiService *PvsTPApiService
	serverAddress string
	customerid string
	siteid string
	siteNameOrId *[]string
	collectionNameOrId *[]string
	virtualOnly *bool
	resourceLocationNameOrId *string
	forest *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
}

// Name or ID of the PVS site.  Optional; if not specified, devices from all sites are returned.
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) SiteNameOrId(siteNameOrId []string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.siteNameOrId = &siteNameOrId
	return r
}

// Name or ID of the PVS collection.  Optional; if not specified, devices from all collections are returned.
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) CollectionNameOrId(collectionNameOrId []string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.collectionNameOrId = &collectionNameOrId
	return r
}

// If &#x60;true&#x60; then the results will be limited to only machines which can be located on hypervisors connected to the site, and each returned device will include the  and  through which the machine may be power-managed.   If &#x60;false&#x60; or not specified then all devices are returned, and  and  properties will not be resolved.
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) VirtualOnly(virtualOnly bool) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.virtualOnly = &virtualOnly
	return r
}

// Name or ID of the resource location or zone through which to communicate to the PVS server. Optional; however, if this is not specified then communication to the PVS server may randomly fail based on network firewall rules between resource locations. Not used for on-premises deployments.
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) ResourceLocationNameOrId(resourceLocationNameOrId string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.resourceLocationNameOrId = &resourceLocationNameOrId
	return r
}

// Active Directory forest of the PVS server.  May be different than the AD forest of the machines managed by PVS.   Optional; however, if this is not specified then communication to the PVS server may randomly fail if the site is connected to untrusted forests, and communication is attempted through a forest that is not within the trust scope of the PVS server&#39;s AD forest.   Not used for on-premises deployments.
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) Forest(forest string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.forest = &forest
	return r
}

// If &#x60;true&#x60;, the get pvs machines will be executed as a background task. The task will have JobType GetPvsMachinesForCatalog. When the task is complete it will redirect to GetJobResults.
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) Async(async bool) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) Authorization(authorization string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) XAdminCredential(xAdminCredential string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiPvsTPGetPvsMachinesForCatalogRequest) XActionName(xActionName string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiPvsTPGetPvsMachinesForCatalogRequest) Execute() (*PvsDeviceResponseModelCollection, *http.Response, error) {
	return r.ApiService.PvsTPGetPvsMachinesForCatalogExecute(r)
}

/*
PvsTPGetPvsMachinesForCatalog Get PVS devices within a collection.

Get PVS devices within a collection from the PVS server, which are suitable to be
added to a machine catalog (i.e. which are not already members of any machine catalog
within the site).  Template devices are omitted from the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverAddress Name or IP of the PVS server.
 @param customerid
 @param siteid
 @return ApiPvsTPGetPvsMachinesForCatalogRequest
*/
func (a *PvsTPApiService) PvsTPGetPvsMachinesForCatalog(ctx context.Context, serverAddress string, customerid string, siteid string) ApiPvsTPGetPvsMachinesForCatalogRequest {
	return ApiPvsTPGetPvsMachinesForCatalogRequest{
		ApiService: a,
		ctx: ctx,
		serverAddress: serverAddress,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return PvsDeviceResponseModelCollection
func (a *PvsTPApiService) PvsTPGetPvsMachinesForCatalogExecute(r ApiPvsTPGetPvsMachinesForCatalogRequest) (*PvsDeviceResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PvsDeviceResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PvsTPApiService.PvsTPGetPvsMachinesForCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Pvs/{serverAddress}/MachinesForCatalog"
	localVarPath = strings.Replace(localVarPath, "{"+"serverAddress"+"}", url.PathEscape(parameterValueToString(r.serverAddress, "serverAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.siteNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteNameOrId", r.siteNameOrId, "csv")
	}
	if r.collectionNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionNameOrId", r.collectionNameOrId, "csv")
	}
	if r.virtualOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualOnly", r.virtualOnly, "")
	}
	if r.resourceLocationNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceLocationNameOrId", r.resourceLocationNameOrId, "")
	}
	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPvsTPGetPvsSitesRequest struct {
	ctx context.Context
	ApiService *PvsTPApiService
	serverAddress string
	customerid string
	siteid string
	resourceLocationNameOrId *string
	forest *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
}

// Name or ID of the resource location or zone through which to communicate to the PVS server. Optional; however, if this is not specified then communication to the PVS server may randomly fail based on network firewall rules between resource locations. Not used for on-premises deployments.
func (r ApiPvsTPGetPvsSitesRequest) ResourceLocationNameOrId(resourceLocationNameOrId string) ApiPvsTPGetPvsSitesRequest {
	r.resourceLocationNameOrId = &resourceLocationNameOrId
	return r
}

// Active Directory forest of the PVS server.  May be different than the AD forest of the machines managed by PVS.   Optional; however, if this is not specified then communication to the PVS server may randomly fail if the site is connected to untrusted forests, and communication is attempted through a forest that is not within the trust scope of the PVS server&#39;s AD forest.   Not used for on-premises deployments.
func (r ApiPvsTPGetPvsSitesRequest) Forest(forest string) ApiPvsTPGetPvsSitesRequest {
	r.forest = &forest
	return r
}

// If &#x60;true&#x60;, the get pvs sites will be executed as a background task. The task will have JobType GetPvsSites. When the task is complete it will redirect to GetJobResults.
func (r ApiPvsTPGetPvsSitesRequest) Async(async bool) ApiPvsTPGetPvsSitesRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiPvsTPGetPvsSitesRequest) Authorization(authorization string) ApiPvsTPGetPvsSitesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiPvsTPGetPvsSitesRequest) CitrixTransactionId(citrixTransactionId string) ApiPvsTPGetPvsSitesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiPvsTPGetPvsSitesRequest) XAdminCredential(xAdminCredential string) ApiPvsTPGetPvsSitesRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiPvsTPGetPvsSitesRequest) XActionName(xActionName string) ApiPvsTPGetPvsSitesRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiPvsTPGetPvsSitesRequest) Execute() (*PvsSiteResponseModelCollection, *http.Response, error) {
	return r.ApiService.PvsTPGetPvsSitesExecute(r)
}

/*
PvsTPGetPvsSites Get PVS sites.

Get PVS sites from the PVS server.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverAddress Name or IP of the PVS server.
 @param customerid
 @param siteid
 @return ApiPvsTPGetPvsSitesRequest
*/
func (a *PvsTPApiService) PvsTPGetPvsSites(ctx context.Context, serverAddress string, customerid string, siteid string) ApiPvsTPGetPvsSitesRequest {
	return ApiPvsTPGetPvsSitesRequest{
		ApiService: a,
		ctx: ctx,
		serverAddress: serverAddress,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return PvsSiteResponseModelCollection
func (a *PvsTPApiService) PvsTPGetPvsSitesExecute(r ApiPvsTPGetPvsSitesRequest) (*PvsSiteResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PvsSiteResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PvsTPApiService.PvsTPGetPvsSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Pvs/{serverAddress}/Sites"
	localVarPath = strings.Replace(localVarPath, "{"+"serverAddress"+"}", url.PathEscape(parameterValueToString(r.serverAddress, "serverAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.resourceLocationNameOrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceLocationNameOrId", r.resourceLocationNameOrId, "")
	}
	if r.forest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forest", r.forest, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
