/*
Citrix Virtual Apps and Desktops REST API TECHPREVIEW

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: techpreview
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package citrixorchestration

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MachinesTPApiService MachinesTPApi service
type MachinesTPApiService service

type ApiMachinesTPAddMachineTagsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	tagNameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachinesTPAddMachineTagsRequest) Async(async bool) ApiMachinesTPAddMachineTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPAddMachineTagsRequest) Authorization(authorization string) ApiMachinesTPAddMachineTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPAddMachineTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPAddMachineTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPAddMachineTagsRequest) XActionName(xActionName string) ApiMachinesTPAddMachineTagsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPAddMachineTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPAddMachineTagsExecute(r)
}

/*
MachinesTPAddMachineTags Add a tag to a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param tagNameOrId Name or ID of the tag to add.
 @param customerid
 @param siteid
 @return ApiMachinesTPAddMachineTagsRequest
*/
func (a *MachinesTPApiService) MachinesTPAddMachineTags(ctx context.Context, nameOrId string, tagNameOrId string, customerid string, siteid string) ApiMachinesTPAddMachineTagsRequest {
	return ApiMachinesTPAddMachineTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		tagNameOrId: tagNameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return TagResponseModelCollection
func (a *MachinesTPApiService) MachinesTPAddMachineTagsExecute(r ApiMachinesTPAddMachineTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPAddMachineTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/Tags/{tagNameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagNameOrId"+"}", url.PathEscape(parameterValueToString(r.tagNameOrId, "tagNameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPCheckMachineExistsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	name string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPCheckMachineExistsRequest) Authorization(authorization string) ApiMachinesTPCheckMachineExistsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPCheckMachineExistsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPCheckMachineExistsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPCheckMachineExistsRequest) XActionName(xActionName string) ApiMachinesTPCheckMachineExistsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPCheckMachineExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesTPCheckMachineExistsExecute(r)
}

/*
MachinesTPCheckMachineExists Check for the existence of a machine by name.

Check for the existence of a machine by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPCheckMachineExistsRequest
*/
func (a *MachinesTPApiService) MachinesTPCheckMachineExists(ctx context.Context, name string, customerid string, siteid string) ApiMachinesTPCheckMachineExistsRequest {
	return ApiMachinesTPCheckMachineExistsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachinesTPApiService) MachinesTPCheckMachineExistsExecute(r ApiMachinesTPCheckMachineExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPCheckMachineExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesTPCreateMachineUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	request *CreateUpgradeScheduleRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details about the VDA upgrade schedule to create.
func (r ApiMachinesTPCreateMachineUpgradeScheduleRequest) Request(request CreateUpgradeScheduleRequestModel) ApiMachinesTPCreateMachineUpgradeScheduleRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be created as a background task.
func (r ApiMachinesTPCreateMachineUpgradeScheduleRequest) Async(async bool) ApiMachinesTPCreateMachineUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPCreateMachineUpgradeScheduleRequest) Authorization(authorization string) ApiMachinesTPCreateMachineUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPCreateMachineUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPCreateMachineUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPCreateMachineUpgradeScheduleRequest) XActionName(xActionName string) ApiMachinesTPCreateMachineUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPCreateMachineUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesTPCreateMachineUpgradeScheduleExecute(r)
}

/*
MachinesTPCreateMachineUpgradeSchedule Setup a new VDA upgrade schedule for a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPCreateMachineUpgradeScheduleRequest
*/
func (a *MachinesTPApiService) MachinesTPCreateMachineUpgradeSchedule(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPCreateMachineUpgradeScheduleRequest {
	return ApiMachinesTPCreateMachineUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachinesTPApiService) MachinesTPCreateMachineUpgradeScheduleExecute(r ApiMachinesTPCreateMachineUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPCreateMachineUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesTPDisconnectSessionsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	detailResponseRequired *bool
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Identify if the API need to return detail info in response model.             Set to false will improve performance with return basic machine model.
func (r ApiMachinesTPDisconnectSessionsRequest) DetailResponseRequired(detailResponseRequired bool) ApiMachinesTPDisconnectSessionsRequest {
	r.detailResponseRequired = &detailResponseRequired
	return r
}

// If &#x60;true&#x60;, the session will be disconnected as a background task. The task will have JobType DisconnectSessions. When the task is complete it will redirect to GetMachine. The job&#39;s Parameters will contain properties: * _Id_ - ID of the machine on which sessions are being disconnected. * _Name_ - Name of the machine on which sessions are being disconnected.
func (r ApiMachinesTPDisconnectSessionsRequest) Async(async bool) ApiMachinesTPDisconnectSessionsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPDisconnectSessionsRequest) Authorization(authorization string) ApiMachinesTPDisconnectSessionsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPDisconnectSessionsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPDisconnectSessionsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPDisconnectSessionsRequest) XActionName(xActionName string) ApiMachinesTPDisconnectSessionsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPDisconnectSessionsRequest) Execute() (*MachineDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPDisconnectSessionsExecute(r)
}

/*
MachinesTPDisconnectSessions Disconnect all sessions on a machine.

Disconnect all sessions on a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to disconnect sessions from.
 @param customerid
 @param siteid
 @return ApiMachinesTPDisconnectSessionsRequest
*/
func (a *MachinesTPApiService) MachinesTPDisconnectSessions(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPDisconnectSessionsRequest {
	return ApiMachinesTPDisconnectSessionsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineDetailResponseModel
func (a *MachinesTPApiService) MachinesTPDisconnectSessionsExecute(r ApiMachinesTPDisconnectSessionsRequest) (*MachineDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPDisconnectSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$disconnect"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailResponseRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailResponseRequired", r.detailResponseRequired, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPDoMachineSearchRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	customerid string
	siteid string
	searchRequest *MachineAndSessionSearchRequestModel
	limit *int32
	continuationToken *string
	fields *string
	async *bool
	skip *int32
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Specifies the advanced search parameters.
func (r ApiMachinesTPDoMachineSearchRequest) SearchRequest(searchRequest MachineAndSessionSearchRequestModel) ApiMachinesTPDoMachineSearchRequest {
	r.searchRequest = &searchRequest
	return r
}

// The max number of machines returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachinesTPDoMachineSearchRequest) Limit(limit int32) ApiMachinesTPDoMachineSearchRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachinesTPDoMachineSearchRequest) ContinuationToken(continuationToken string) ApiMachinesTPDoMachineSearchRequest {
	r.continuationToken = &continuationToken
	return r
}

// Optional filter, removing unspecified properties that otherwise would have been sent by the server
func (r ApiMachinesTPDoMachineSearchRequest) Fields(fields string) ApiMachinesTPDoMachineSearchRequest {
	r.fields = &fields
	return r
}

// If &#x60;true&#x60;, the search machines will be executed as a background task. The task will have JobType DoMachineSearch. When the task is complete it will redirect to GetJobResults.
func (r ApiMachinesTPDoMachineSearchRequest) Async(async bool) ApiMachinesTPDoMachineSearchRequest {
	r.async = &async
	return r
}

// The number of machines to skip.
func (r ApiMachinesTPDoMachineSearchRequest) Skip(skip int32) ApiMachinesTPDoMachineSearchRequest {
	r.skip = &skip
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPDoMachineSearchRequest) Authorization(authorization string) ApiMachinesTPDoMachineSearchRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPDoMachineSearchRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPDoMachineSearchRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPDoMachineSearchRequest) XActionName(xActionName string) ApiMachinesTPDoMachineSearchRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPDoMachineSearchRequest) Execute() (*MachineResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPDoMachineSearchExecute(r)
}

/*
MachinesTPDoMachineSearch Perform an advanced search for machines.

Perform an advanced search for machines.  Note that some combinations
of search parameters may result in slow performance.

The 'SessionSupport' 
must be included in search filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerid
 @param siteid
 @return ApiMachinesTPDoMachineSearchRequest
*/
func (a *MachinesTPApiService) MachinesTPDoMachineSearch(ctx context.Context, customerid string, siteid string) ApiMachinesTPDoMachineSearchRequest {
	return ApiMachinesTPDoMachineSearchRequest{
		ApiService: a,
		ctx: ctx,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineResponseModelCollection
func (a *MachinesTPApiService) MachinesTPDoMachineSearchExecute(r ApiMachinesTPDoMachineSearchRequest) (*MachineResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPDoMachineSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/$search"
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchRequest == nil {
		return localVarReturnValue, nil, reportError("searchRequest is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.searchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// The requested fields.
func (r ApiMachinesTPGetMachineRequest) Fields(fields string) ApiMachinesTPGetMachineRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineRequest) Authorization(authorization string) ApiMachinesTPGetMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineRequest) XActionName(xActionName string) ApiMachinesTPGetMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineRequest) Execute() (*MachineDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineExecute(r)
}

/*
MachinesTPGetMachine Get details of a single machine.

Get details of a single machine

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineRequest {
	return ApiMachinesTPGetMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineDetailResponseModel
func (a *MachinesTPApiService) MachinesTPGetMachineExecute(r ApiMachinesTPGetMachineRequest) (*MachineDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineApplicationsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineApplicationsRequest) Authorization(authorization string) ApiMachinesTPGetMachineApplicationsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineApplicationsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineApplicationsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineApplicationsRequest) XActionName(xActionName string) ApiMachinesTPGetMachineApplicationsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineApplicationsRequest) Execute() (*MachineApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineApplicationsExecute(r)
}

/*
MachinesTPGetMachineApplications Get the list of applications on a machine.

Get the list of applications published or in use on a machine.
At least one of Published
or InUse
will be `true` for each application returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineApplicationsRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachineApplications(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineApplicationsRequest {
	return ApiMachinesTPGetMachineApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineApplicationResponseModelCollection
func (a *MachinesTPApiService) MachinesTPGetMachineApplicationsExecute(r ApiMachinesTPGetMachineApplicationsRequest) (*MachineApplicationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineApplicationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachineApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/Applications"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineDeliveryGroupRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineDeliveryGroupRequest) Authorization(authorization string) ApiMachinesTPGetMachineDeliveryGroupRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineDeliveryGroupRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineDeliveryGroupRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineDeliveryGroupRequest) XActionName(xActionName string) ApiMachinesTPGetMachineDeliveryGroupRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineDeliveryGroupRequest) Execute() (*DeliveryGroupDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineDeliveryGroupExecute(r)
}

/*
MachinesTPGetMachineDeliveryGroup Get the delivery group for a machine.

Get the details of the delivery group in which a machine resides.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineDeliveryGroupRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachineDeliveryGroup(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineDeliveryGroupRequest {
	return ApiMachinesTPGetMachineDeliveryGroupRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return DeliveryGroupDetailResponseModel
func (a *MachinesTPApiService) MachinesTPGetMachineDeliveryGroupExecute(r ApiMachinesTPGetMachineDeliveryGroupRequest) (*DeliveryGroupDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeliveryGroupDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachineDeliveryGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/DeliveryGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineDesktopRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineDesktopRequest) Authorization(authorization string) ApiMachinesTPGetMachineDesktopRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineDesktopRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineDesktopRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineDesktopRequest) XActionName(xActionName string) ApiMachinesTPGetMachineDesktopRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineDesktopRequest) Execute() (*DesktopResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineDesktopExecute(r)
}

/*
MachinesTPGetMachineDesktop Get the desktop associated with the machine, if any.

Get the details of the desktop associated with the machine, if any.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineDesktopRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachineDesktop(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineDesktopRequest {
	return ApiMachinesTPGetMachineDesktopRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return DesktopResponseModel
func (a *MachinesTPApiService) MachinesTPGetMachineDesktopExecute(r ApiMachinesTPGetMachineDesktopRequest) (*DesktopResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DesktopResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachineDesktop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/Desktop"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineMachineCatalogRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineMachineCatalogRequest) Authorization(authorization string) ApiMachinesTPGetMachineMachineCatalogRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineMachineCatalogRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineMachineCatalogRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineMachineCatalogRequest) XActionName(xActionName string) ApiMachinesTPGetMachineMachineCatalogRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineMachineCatalogRequest) Execute() (*MachineCatalogDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineMachineCatalogExecute(r)
}

/*
MachinesTPGetMachineMachineCatalog Get the machine catalog for a machine.

Get the details of the machine catalog in which a machine resides.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineMachineCatalogRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachineMachineCatalog(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineMachineCatalogRequest {
	return ApiMachinesTPGetMachineMachineCatalogRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineCatalogDetailResponseModel
func (a *MachinesTPApiService) MachinesTPGetMachineMachineCatalogExecute(r ApiMachinesTPGetMachineMachineCatalogRequest) (*MachineCatalogDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineCatalogDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachineMachineCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/MachineCatalog"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachinePowerActionSchedulesRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachinePowerActionSchedulesRequest) Authorization(authorization string) ApiMachinesTPGetMachinePowerActionSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachinePowerActionSchedulesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachinePowerActionSchedulesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachinePowerActionSchedulesRequest) XActionName(xActionName string) ApiMachinesTPGetMachinePowerActionSchedulesRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachinePowerActionSchedulesRequest) Execute() (*PowerActionScheduleResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachinePowerActionSchedulesExecute(r)
}

/*
MachinesTPGetMachinePowerActionSchedules Get the power action schedules associated with a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachinePowerActionSchedulesRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachinePowerActionSchedules(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachinePowerActionSchedulesRequest {
	return ApiMachinesTPGetMachinePowerActionSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return PowerActionScheduleResponseModelCollection
func (a *MachinesTPApiService) MachinesTPGetMachinePowerActionSchedulesExecute(r ApiMachinesTPGetMachinePowerActionSchedulesRequest) (*PowerActionScheduleResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerActionScheduleResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachinePowerActionSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/PowerActionSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineSessionsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineSessionsRequest) Authorization(authorization string) ApiMachinesTPGetMachineSessionsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineSessionsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineSessionsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineSessionsRequest) XActionName(xActionName string) ApiMachinesTPGetMachineSessionsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineSessionsRequest) Execute() (*SessionResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineSessionsExecute(r)
}

/*
MachinesTPGetMachineSessions Get the list of sessions running on a machine.

Get the list of sessions running on a machine

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineSessionsRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachineSessions(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineSessionsRequest {
	return ApiMachinesTPGetMachineSessionsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return SessionResponseModelCollection
func (a *MachinesTPApiService) MachinesTPGetMachineSessionsExecute(r ApiMachinesTPGetMachineSessionsRequest) (*SessionResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachineSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/Sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineStartMenuShortcutIconRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	shortcutPath *string
	iconFormat *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Path to the start menu shortcut.
func (r ApiMachinesTPGetMachineStartMenuShortcutIconRequest) ShortcutPath(shortcutPath string) ApiMachinesTPGetMachineStartMenuShortcutIconRequest {
	r.shortcutPath = &shortcutPath
	return r
}

// Icon format.  Must be: &#x60;{mime-type};{width}x{height}x{colordepth}&#x60;   where:   * _mime-type_ must be &#x60;image/png&#x60;.  (Other formats may be supported in future.) * _width_ and _height_ are specified in pixels. * _colordepth_ (optional) is either &#x60;8&#x60; or &#x60;24&#x60;.   Optional. If not specified, only the raw icon data will be returned. Note that this is typically in ICO format, which many clients cannot display properly.
func (r ApiMachinesTPGetMachineStartMenuShortcutIconRequest) IconFormat(iconFormat string) ApiMachinesTPGetMachineStartMenuShortcutIconRequest {
	r.iconFormat = &iconFormat
	return r
}

// If &#x60;true&#x60;, the start menu shortcut icon will be queried as a background task. The task will have JobType GetMachineStartMenuShortcutIcon. When the task is complete it will redirect to GetJobResults. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine from which start menu icon are being obtained, * _Name_ - Name of the machine from which start menu icon are being obtained. * _ShortcutPath_ - Path to the start menu shortcut.
func (r ApiMachinesTPGetMachineStartMenuShortcutIconRequest) Async(async bool) ApiMachinesTPGetMachineStartMenuShortcutIconRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineStartMenuShortcutIconRequest) Authorization(authorization string) ApiMachinesTPGetMachineStartMenuShortcutIconRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineStartMenuShortcutIconRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineStartMenuShortcutIconRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineStartMenuShortcutIconRequest) XActionName(xActionName string) ApiMachinesTPGetMachineStartMenuShortcutIconRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineStartMenuShortcutIconRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineStartMenuShortcutIconExecute(r)
}

/*
MachinesTPGetMachineStartMenuShortcutIcon Get a start menu shortcut icon from the machine.

Get a start menu shortcut icon from the machine.  The machine must be powered-on
and registered in order for the call to succeed.


This icon is usually used to help create a published application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to get the shortcut icon from.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineStartMenuShortcutIconRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachineStartMenuShortcutIcon(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineStartMenuShortcutIconRequest {
	return ApiMachinesTPGetMachineStartMenuShortcutIconRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *MachinesTPApiService) MachinesTPGetMachineStartMenuShortcutIconExecute(r ApiMachinesTPGetMachineStartMenuShortcutIconRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachineStartMenuShortcutIcon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/StartMenuShortcutIcon"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.shortcutPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shortcutPath", r.shortcutPath, "")
	}
	if r.iconFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconFormat", r.iconFormat, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineStartMenuShortcutsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineStartMenuShortcutsRequest) Authorization(authorization string) ApiMachinesTPGetMachineStartMenuShortcutsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineStartMenuShortcutsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineStartMenuShortcutsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineStartMenuShortcutsRequest) XActionName(xActionName string) ApiMachinesTPGetMachineStartMenuShortcutsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineStartMenuShortcutsRequest) Execute() (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineStartMenuShortcutsExecute(r)
}

/*
MachinesTPGetMachineStartMenuShortcuts Get start menu shortcuts from the machine.

Get start menu shortcuts from the machine.  The machine must be powered-on
and registered in order for the call to succeed.


The shortcuts obtained are from the 'All users' start menu; user-specific shortcuts are not found.


Note that this call does not retrieve the shortcut icon; use

to get the icon.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to get the shortcuts from.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineStartMenuShortcutsRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachineStartMenuShortcuts(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineStartMenuShortcutsRequest {
	return ApiMachinesTPGetMachineStartMenuShortcutsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return StartMenuApplicationResponseModelCollection
func (a *MachinesTPApiService) MachinesTPGetMachineStartMenuShortcutsExecute(r ApiMachinesTPGetMachineStartMenuShortcutsRequest) (*StartMenuApplicationResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StartMenuApplicationResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachineStartMenuShortcuts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/StartMenuShortcuts"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachineTagsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	fields *string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Optional. A filter string containing object fields requested to be returned, the requested fields are separated by comma&#39;,&#39;. return all if not specified.
func (r ApiMachinesTPGetMachineTagsRequest) Fields(fields string) ApiMachinesTPGetMachineTagsRequest {
	r.fields = &fields
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachineTagsRequest) Authorization(authorization string) ApiMachinesTPGetMachineTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachineTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachineTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachineTagsRequest) XActionName(xActionName string) ApiMachinesTPGetMachineTagsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachineTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachineTagsExecute(r)
}

/*
MachinesTPGetMachineTags Get tags associated with a machine.

Get tags associated with a machine.  This includes tags which are
directly associated with the machine, as well as tags associated
with delivery groups, application groups, or applications that are
associated with the machine.  To find only tags directly associated
with the machine, filter the results to those with
NumMachines equal to `1`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachineTagsRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachineTags(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachineTagsRequest {
	return ApiMachinesTPGetMachineTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return TagResponseModelCollection
func (a *MachinesTPApiService) MachinesTPGetMachineTagsExecute(r ApiMachinesTPGetMachineTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachineTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/Tags"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachinesRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	customerid string
	siteid string
	sessionSupport *string
	configured *bool
	limit *int32
	continuationToken *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Optionally limit the results to machines that are either single or multi-session capable. If not specified, all types of machines are returned.
func (r ApiMachinesTPGetMachinesRequest) SessionSupport(sessionSupport string) ApiMachinesTPGetMachinesRequest {
	r.sessionSupport = &sessionSupport
	return r
}

// Optionally limit the results to machines that are either configured or not. If not specified, only configured machines are returned.
func (r ApiMachinesTPGetMachinesRequest) Configured(configured bool) ApiMachinesTPGetMachinesRequest {
	r.configured = &configured
	return r
}

// The max number of machines returned by this query. If not specified, the server might use a default limit of 250 items. If the specified value is larger than 1000, the server might reject the call. The default and maximum values depend on server settings.
func (r ApiMachinesTPGetMachinesRequest) Limit(limit int32) ApiMachinesTPGetMachinesRequest {
	r.limit = &limit
	return r
}

// If a query cannot be completed, the response will have a ContinuationToken set. To obtain more results from the query, pass the continuation token back into the query to get the next batch of results.
func (r ApiMachinesTPGetMachinesRequest) ContinuationToken(continuationToken string) ApiMachinesTPGetMachinesRequest {
	r.continuationToken = &continuationToken
	return r
}

// If &#x60;true&#x60;, the get machines will be executed as a background task. The task will have JobType GetMachines. When the task is complete it will redirect to GetJobResults.
func (r ApiMachinesTPGetMachinesRequest) Async(async bool) ApiMachinesTPGetMachinesRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachinesRequest) Authorization(authorization string) ApiMachinesTPGetMachinesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachinesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachinesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachinesRequest) XActionName(xActionName string) ApiMachinesTPGetMachinesRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachinesRequest) Execute() (*MachineResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachinesExecute(r)
}

/*
MachinesTPGetMachines Get all machines in the site.

Get all the machines in the site.  Note that the response
may not contain the entire list of machines; if this happens the
response will have a ContinuationToken
which, if passed, will resume retrieving results from the original
query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachinesRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachines(ctx context.Context, customerid string, siteid string) ApiMachinesTPGetMachinesRequest {
	return ApiMachinesTPGetMachinesRequest{
		ApiService: a,
		ctx: ctx,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineResponseModelCollection
func (a *MachinesTPApiService) MachinesTPGetMachinesExecute(r ApiMachinesTPGetMachinesRequest) (*MachineResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines"
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sessionSupport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionSupport", r.sessionSupport, "")
	}
	if r.configured != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configured", r.configured, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetMachinesAdministratorsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetMachinesAdministratorsRequest) Authorization(authorization string) ApiMachinesTPGetMachinesAdministratorsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetMachinesAdministratorsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetMachinesAdministratorsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetMachinesAdministratorsRequest) XActionName(xActionName string) ApiMachinesTPGetMachinesAdministratorsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetMachinesAdministratorsRequest) Execute() (*AdministratorResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPGetMachinesAdministratorsExecute(r)
}

/*
MachinesTPGetMachinesAdministrators Get administrators who can administer a machine

Get administrators who can administer a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId SamName, UPN, or SID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetMachinesAdministratorsRequest
*/
func (a *MachinesTPApiService) MachinesTPGetMachinesAdministrators(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPGetMachinesAdministratorsRequest {
	return ApiMachinesTPGetMachinesAdministratorsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return AdministratorResponseModelCollection
func (a *MachinesTPApiService) MachinesTPGetMachinesAdministratorsExecute(r ApiMachinesTPGetMachinesAdministratorsRequest) (*AdministratorResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdministratorResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetMachinesAdministrators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/Administrators"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPGetTestMachineReportRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	reportId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPGetTestMachineReportRequest) Authorization(authorization string) ApiMachinesTPGetTestMachineReportRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPGetTestMachineReportRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPGetTestMachineReportRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPGetTestMachineReportRequest) XActionName(xActionName string) ApiMachinesTPGetTestMachineReportRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPGetTestMachineReportRequest) Execute() (*MachineTestResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPGetTestMachineReportExecute(r)
}

/*
MachinesTPGetTestMachineReport Get Cloud Health Check Report on a VDA machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine to test.
 @param reportId ID of the Cloud Health Check Report.
 @param customerid
 @param siteid
 @return ApiMachinesTPGetTestMachineReportRequest
*/
func (a *MachinesTPApiService) MachinesTPGetTestMachineReport(ctx context.Context, nameOrId string, reportId string, customerid string, siteid string) ApiMachinesTPGetTestMachineReportRequest {
	return ApiMachinesTPGetTestMachineReportRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		reportId: reportId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineTestResponseModel
func (a *MachinesTPApiService) MachinesTPGetTestMachineReportExecute(r ApiMachinesTPGetTestMachineReportRequest) (*MachineTestResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineTestResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPGetTestMachineReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/TestReports/{reportId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reportId"+"}", url.PathEscape(parameterValueToString(r.reportId, "reportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPImportFileTypesRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the file types will be imported as a background task. The task will have JobType ImportFTA. When the task is complete it will redirect to GetJobResults. The job&#39;s Parameters will contain properties: * _MachineId_ - ID of the machine * _MachineName_ - Name of the machine
func (r ApiMachinesTPImportFileTypesRequest) Async(async bool) ApiMachinesTPImportFileTypesRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPImportFileTypesRequest) Authorization(authorization string) ApiMachinesTPImportFileTypesRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPImportFileTypesRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPImportFileTypesRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPImportFileTypesRequest) XActionName(xActionName string) ApiMachinesTPImportFileTypesRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPImportFileTypesRequest) Execute() (*FtaResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPImportFileTypesExecute(r)
}

/*
MachinesTPImportFileTypes Import file type associations from the machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPImportFileTypesRequest
*/
func (a *MachinesTPApiService) MachinesTPImportFileTypes(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPImportFileTypesRequest {
	return ApiMachinesTPImportFileTypesRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return FtaResponseModelCollection
func (a *MachinesTPApiService) MachinesTPImportFileTypesExecute(r ApiMachinesTPImportFileTypesRequest) (*FtaResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FtaResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPImportFileTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/FileTypes/$import"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPLogoffMachineSessionsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	detailResponseRequired *bool
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Identify if the API need to return detail info in response model.             Set to false will improve performance with return basic machine model.
func (r ApiMachinesTPLogoffMachineSessionsRequest) DetailResponseRequired(detailResponseRequired bool) ApiMachinesTPLogoffMachineSessionsRequest {
	r.detailResponseRequired = &detailResponseRequired
	return r
}

// If &#x60;true&#x60;, the sessions will be logged off as a background task. The task will have JobType . When the task is complete it will redirect to . The job&#39;s  will contain properties:   * _Id_ - ID of the machine which sessions are being logged off from, * _Name_ - Name of the machine which sessions are being logged off from.
func (r ApiMachinesTPLogoffMachineSessionsRequest) Async(async bool) ApiMachinesTPLogoffMachineSessionsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPLogoffMachineSessionsRequest) Authorization(authorization string) ApiMachinesTPLogoffMachineSessionsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPLogoffMachineSessionsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPLogoffMachineSessionsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPLogoffMachineSessionsRequest) XActionName(xActionName string) ApiMachinesTPLogoffMachineSessionsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPLogoffMachineSessionsRequest) Execute() (*MachineDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPLogoffMachineSessionsExecute(r)
}

/*
MachinesTPLogoffMachineSessions Logoff all sessions on a machine.

Logoff all sessions on a machine

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to log sessions off from.
 @param customerid
 @param siteid
 @return ApiMachinesTPLogoffMachineSessionsRequest
*/
func (a *MachinesTPApiService) MachinesTPLogoffMachineSessions(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPLogoffMachineSessionsRequest {
	return ApiMachinesTPLogoffMachineSessionsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineDetailResponseModel
func (a *MachinesTPApiService) MachinesTPLogoffMachineSessionsExecute(r ApiMachinesTPLogoffMachineSessionsRequest) (*MachineDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPLogoffMachineSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$logoff"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailResponseRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailResponseRequired", r.detailResponseRequired, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPRebootMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	force *bool
	detailResponseRequired *bool
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the machine will be forced to reboot without waiting for user activity to stop.  This may cause loss of user data if work is not saved.
func (r ApiMachinesTPRebootMachineRequest) Force(force bool) ApiMachinesTPRebootMachineRequest {
	r.force = &force
	return r
}

// Identify if the API need to return detail info in response model.             Set to false will improve performance with return basic machine model.
func (r ApiMachinesTPRebootMachineRequest) DetailResponseRequired(detailResponseRequired bool) ApiMachinesTPRebootMachineRequest {
	r.detailResponseRequired = &detailResponseRequired
	return r
}

// If &#x60;true&#x60;, the machine will be rebooted as a background task. This is recommended as this operation may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType RebootMachines. When the task is complete it will redirect to GetMachine. The job&#39;s Parameters will contain properties: * _Id_ - ID of the machine being rebooted, * _Name_ - Name of the machine being rebooted.
func (r ApiMachinesTPRebootMachineRequest) Async(async bool) ApiMachinesTPRebootMachineRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPRebootMachineRequest) Authorization(authorization string) ApiMachinesTPRebootMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPRebootMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPRebootMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPRebootMachineRequest) XActionName(xActionName string) ApiMachinesTPRebootMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPRebootMachineRequest) Execute() (*MachineDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPRebootMachineExecute(r)
}

/*
MachinesTPRebootMachine Reboot a machine.

Reboot a machine.  The machine must be capable of power management.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to reboot.
 @param customerid
 @param siteid
 @return ApiMachinesTPRebootMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPRebootMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPRebootMachineRequest {
	return ApiMachinesTPRebootMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineDetailResponseModel
func (a *MachinesTPApiService) MachinesTPRebootMachineExecute(r ApiMachinesTPRebootMachineRequest) (*MachineDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPRebootMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.detailResponseRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailResponseRequired", r.detailResponseRequired, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPRemoveMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	deleteVm *bool
	deleteAccount *string
	async *bool
	authorization *string
	citrixTransactionId *string
	xAdminCredential *string
	xActionName *string
}

// Specifies whether to delete the virtual machines, or just the machine record in the site database. Only relevant when ProvisioningType Optional; default is &#x60;true&#x60;.
func (r ApiMachinesTPRemoveMachineRequest) DeleteVm(deleteVm bool) ApiMachinesTPRemoveMachineRequest {
	r.deleteVm = &deleteVm
	return r
}

// Specifies what to do with the machine account in AD.  Optional; default is Leave. Only relevant when &#x60;deleteVm&#x60; is &#x60;true&#x60;; otherwise, ignored.
func (r ApiMachinesTPRemoveMachineRequest) DeleteAccount(deleteAccount string) ApiMachinesTPRemoveMachineRequest {
	r.deleteAccount = &deleteAccount
	return r
}

// If &#x60;true&#x60;, the machine will be deleted as a background task. The task will have JobType DeleteMachine. When the task is complete it will redirect to The job&#39;s Parameters will contain properties: * _Id_ - ID of the machine being deleted, * _Name_ - Name of the machine being deleted.
func (r ApiMachinesTPRemoveMachineRequest) Async(async bool) ApiMachinesTPRemoveMachineRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPRemoveMachineRequest) Authorization(authorization string) ApiMachinesTPRemoveMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPRemoveMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPRemoveMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Admin credential to use when performing the operation. If not specified, the operation will be performed using the account under which the identity service is running If specified, must be in a format matching that of the standard &#39;Authorization&#39; request header; the username and password separated by a colon, UTF8-encoded, then base64-encoded, then the \&quot;Basic \&quot; scheme prepended.  Example:Basic QWxhZGRpbjpPcGVuU2VzYW1l
func (r ApiMachinesTPRemoveMachineRequest) XAdminCredential(xAdminCredential string) ApiMachinesTPRemoveMachineRequest {
	r.xAdminCredential = &xAdminCredential
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPRemoveMachineRequest) XActionName(xActionName string) ApiMachinesTPRemoveMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPRemoveMachineRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesTPRemoveMachineExecute(r)
}

/*
MachinesTPRemoveMachine Delete a machine from the site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to remove.  May be specified by SamName, UPN, or SID.
 @param customerid
 @param siteid
 @return ApiMachinesTPRemoveMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPRemoveMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPRemoveMachineRequest {
	return ApiMachinesTPRemoveMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachinesTPApiService) MachinesTPRemoveMachineExecute(r ApiMachinesTPRemoveMachineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPRemoveMachine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteVm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteVm", r.deleteVm, "")
	}
	if r.deleteAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAccount", r.deleteAccount, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xAdminCredential != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-AdminCredential", r.xAdminCredential, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesTPRemoveMachineTagsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	tagNameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachinesTPRemoveMachineTagsRequest) Async(async bool) ApiMachinesTPRemoveMachineTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPRemoveMachineTagsRequest) Authorization(authorization string) ApiMachinesTPRemoveMachineTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPRemoveMachineTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPRemoveMachineTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPRemoveMachineTagsRequest) XActionName(xActionName string) ApiMachinesTPRemoveMachineTagsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPRemoveMachineTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPRemoveMachineTagsExecute(r)
}

/*
MachinesTPRemoveMachineTags Remove a tag from a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param tagNameOrId Name or ID of the tag.
 @param customerid
 @param siteid
 @return ApiMachinesTPRemoveMachineTagsRequest
*/
func (a *MachinesTPApiService) MachinesTPRemoveMachineTags(ctx context.Context, nameOrId string, tagNameOrId string, customerid string, siteid string) ApiMachinesTPRemoveMachineTagsRequest {
	return ApiMachinesTPRemoveMachineTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		tagNameOrId: tagNameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return TagResponseModelCollection
func (a *MachinesTPApiService) MachinesTPRemoveMachineTagsExecute(r ApiMachinesTPRemoveMachineTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPRemoveMachineTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/Tags/{tagNameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagNameOrId"+"}", url.PathEscape(parameterValueToString(r.tagNameOrId, "tagNameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPRemoveMachineUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	force *bool
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

func (r ApiMachinesTPRemoveMachineUpgradeScheduleRequest) Force(force bool) ApiMachinesTPRemoveMachineUpgradeScheduleRequest {
	r.force = &force
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be removed as a background task.
func (r ApiMachinesTPRemoveMachineUpgradeScheduleRequest) Async(async bool) ApiMachinesTPRemoveMachineUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPRemoveMachineUpgradeScheduleRequest) Authorization(authorization string) ApiMachinesTPRemoveMachineUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPRemoveMachineUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPRemoveMachineUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPRemoveMachineUpgradeScheduleRequest) XActionName(xActionName string) ApiMachinesTPRemoveMachineUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPRemoveMachineUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesTPRemoveMachineUpgradeScheduleExecute(r)
}

/*
MachinesTPRemoveMachineUpgradeSchedule Remove a pending VDA upgrade schedule for a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPRemoveMachineUpgradeScheduleRequest
*/
func (a *MachinesTPApiService) MachinesTPRemoveMachineUpgradeSchedule(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPRemoveMachineUpgradeScheduleRequest {
	return ApiMachinesTPRemoveMachineUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachinesTPApiService) MachinesTPRemoveMachineUpgradeScheduleExecute(r ApiMachinesTPRemoveMachineUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPRemoveMachineUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesTPRemovePowerActionScheduleRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the power action schedule will be removed as a background task.
func (r ApiMachinesTPRemovePowerActionScheduleRequest) Async(async bool) ApiMachinesTPRemovePowerActionScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPRemovePowerActionScheduleRequest) Authorization(authorization string) ApiMachinesTPRemovePowerActionScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPRemovePowerActionScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPRemovePowerActionScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPRemovePowerActionScheduleRequest) XActionName(xActionName string) ApiMachinesTPRemovePowerActionScheduleRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPRemovePowerActionScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesTPRemovePowerActionScheduleExecute(r)
}

/*
MachinesTPRemovePowerActionSchedule Remove pending power action schedules for a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPRemovePowerActionScheduleRequest
*/
func (a *MachinesTPApiService) MachinesTPRemovePowerActionSchedule(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPRemovePowerActionScheduleRequest {
	return ApiMachinesTPRemovePowerActionScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachinesTPApiService) MachinesTPRemovePowerActionScheduleExecute(r ApiMachinesTPRemovePowerActionScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPRemovePowerActionSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/PowerActionSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesTPRequestExistingMachinePropertyUpdateRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the tag will be created as a background task. The task will have JobType RequestProvVmUpdate. When the task is complete it will redirect to \&quot;GetMachine(string)\&quot;. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine being updated, * _Name_ - Name of the machine being updated.
func (r ApiMachinesTPRequestExistingMachinePropertyUpdateRequest) Async(async bool) ApiMachinesTPRequestExistingMachinePropertyUpdateRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPRequestExistingMachinePropertyUpdateRequest) Authorization(authorization string) ApiMachinesTPRequestExistingMachinePropertyUpdateRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPRequestExistingMachinePropertyUpdateRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPRequestExistingMachinePropertyUpdateRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPRequestExistingMachinePropertyUpdateRequest) XActionName(xActionName string) ApiMachinesTPRequestExistingMachinePropertyUpdateRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPRequestExistingMachinePropertyUpdateRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MachinesTPRequestExistingMachinePropertyUpdateExecute(r)
}

/*
MachinesTPRequestExistingMachinePropertyUpdate Request a single machine's property update to the latest provisioning scheme configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine. May be specified by name, ID, or SID.
 @param customerid
 @param siteid
 @return ApiMachinesTPRequestExistingMachinePropertyUpdateRequest
*/
func (a *MachinesTPApiService) MachinesTPRequestExistingMachinePropertyUpdate(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPRequestExistingMachinePropertyUpdateRequest {
	return ApiMachinesTPRequestExistingMachinePropertyUpdateRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return bool
func (a *MachinesTPApiService) MachinesTPRequestExistingMachinePropertyUpdateExecute(r ApiMachinesTPRequestExistingMachinePropertyUpdateRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPRequestExistingMachinePropertyUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$RequestProvVmUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPResumeMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	detailResponseRequired *bool
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Identify if the API need to return detail info in response model.             Set to false will improve performance with return basic machine model.
func (r ApiMachinesTPResumeMachineRequest) DetailResponseRequired(detailResponseRequired bool) ApiMachinesTPResumeMachineRequest {
	r.detailResponseRequired = &detailResponseRequired
	return r
}

// If &#x60;true&#x60;, the machine will be resumed as a background task. This is recommended as this operation may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType ResumeMachines. When the task is complete it will redirect to GetMachine. The job&#39;s Parameters will contain properties: * _Id_ - ID of the machine being resumed, * _Name_ - Name of the machine being resumed.
func (r ApiMachinesTPResumeMachineRequest) Async(async bool) ApiMachinesTPResumeMachineRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPResumeMachineRequest) Authorization(authorization string) ApiMachinesTPResumeMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPResumeMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPResumeMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPResumeMachineRequest) XActionName(xActionName string) ApiMachinesTPResumeMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPResumeMachineRequest) Execute() (*MachineDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPResumeMachineExecute(r)
}

/*
MachinesTPResumeMachine Resume a machine.

Resume a machine after it has been suspended.  The machine must be capable of
power management.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to resume.
 @param customerid
 @param siteid
 @return ApiMachinesTPResumeMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPResumeMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPResumeMachineRequest {
	return ApiMachinesTPResumeMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineDetailResponseModel
func (a *MachinesTPApiService) MachinesTPResumeMachineExecute(r ApiMachinesTPResumeMachineRequest) (*MachineDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPResumeMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$resume"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailResponseRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailResponseRequired", r.detailResponseRequired, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPSetMachineTagsRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	request *TagsRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details of the tags to set on the machine.
func (r ApiMachinesTPSetMachineTagsRequest) Request(request TagsRequestModel) ApiMachinesTPSetMachineTagsRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the tags will be modified as a background task.
func (r ApiMachinesTPSetMachineTagsRequest) Async(async bool) ApiMachinesTPSetMachineTagsRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPSetMachineTagsRequest) Authorization(authorization string) ApiMachinesTPSetMachineTagsRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPSetMachineTagsRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPSetMachineTagsRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPSetMachineTagsRequest) XActionName(xActionName string) ApiMachinesTPSetMachineTagsRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPSetMachineTagsRequest) Execute() (*TagResponseModelCollection, *http.Response, error) {
	return r.ApiService.MachinesTPSetMachineTagsExecute(r)
}

/*
MachinesTPSetMachineTags Set tags associated with a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPSetMachineTagsRequest
*/
func (a *MachinesTPApiService) MachinesTPSetMachineTags(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPSetMachineTagsRequest {
	return ApiMachinesTPSetMachineTagsRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return TagResponseModelCollection
func (a *MachinesTPApiService) MachinesTPSetMachineTagsExecute(r ApiMachinesTPSetMachineTagsRequest) (*TagResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPSetMachineTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/Tags"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPShutdownMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	force *bool
	detailResponseRequired *bool
	async *bool
	delay *int32
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// If &#x60;true&#x60;, the machine will be forced to shut down without waiting for user activity to stop.  This may cause loss of user data if work is not saved.
func (r ApiMachinesTPShutdownMachineRequest) Force(force bool) ApiMachinesTPShutdownMachineRequest {
	r.force = &force
	return r
}

// Identify if the API need to return detail info in response model.             Set to false will improve performance with return basic machine model.
func (r ApiMachinesTPShutdownMachineRequest) DetailResponseRequired(detailResponseRequired bool) ApiMachinesTPShutdownMachineRequest {
	r.detailResponseRequired = &detailResponseRequired
	return r
}

// If &#x60;true&#x60;, the machine will be shut down as a background task. This is recommended as this operation may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType ShutDownMachines. When the task is complete it will redirect to GetMachine. The job&#39;s Parameters will contain properties: * _Id_ - ID of the machine being shut down, * _Name_ - Name of the machine being shut down.
func (r ApiMachinesTPShutdownMachineRequest) Async(async bool) ApiMachinesTPShutdownMachineRequest {
	r.async = &async
	return r
}

// Shutdown a machine after the specified number of seconds delay, If &#x60;null&#x60;, the machine will be shut down without delay.
func (r ApiMachinesTPShutdownMachineRequest) Delay(delay int32) ApiMachinesTPShutdownMachineRequest {
	r.delay = &delay
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPShutdownMachineRequest) Authorization(authorization string) ApiMachinesTPShutdownMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPShutdownMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPShutdownMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPShutdownMachineRequest) XActionName(xActionName string) ApiMachinesTPShutdownMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPShutdownMachineRequest) Execute() (*MachineDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPShutdownMachineExecute(r)
}

/*
MachinesTPShutdownMachine Shut down a machine.

Shut down (power-off) a machine.  The machine must be capable of power
management.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to shut down.
 @param customerid
 @param siteid
 @return ApiMachinesTPShutdownMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPShutdownMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPShutdownMachineRequest {
	return ApiMachinesTPShutdownMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineDetailResponseModel
func (a *MachinesTPApiService) MachinesTPShutdownMachineExecute(r ApiMachinesTPShutdownMachineRequest) (*MachineDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPShutdownMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$shutdown"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.detailResponseRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailResponseRequired", r.detailResponseRequired, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.delay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delay", r.delay, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPStartMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	detailResponseRequired *bool
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Identify if the API need to return detail info in response model.             Set to false will improve performance with return basic machine model.
func (r ApiMachinesTPStartMachineRequest) DetailResponseRequired(detailResponseRequired bool) ApiMachinesTPStartMachineRequest {
	r.detailResponseRequired = &detailResponseRequired
	return r
}

// If &#x60;true&#x60;, the machine will be started as a background task. This is recommended as this operation may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType StartMachines. When the task is complete it will redirect to GetMachine. The job&#39;s Parameters will contain properties: * _Id_ - ID of the machine being started, * _Name_ - Name of the machine being started.
func (r ApiMachinesTPStartMachineRequest) Async(async bool) ApiMachinesTPStartMachineRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPStartMachineRequest) Authorization(authorization string) ApiMachinesTPStartMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPStartMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPStartMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPStartMachineRequest) XActionName(xActionName string) ApiMachinesTPStartMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPStartMachineRequest) Execute() (*MachineDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPStartMachineExecute(r)
}

/*
MachinesTPStartMachine Start a machine.

Start (power-on) a machine.  The machine must be capable of power management.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to start.
 @param customerid
 @param siteid
 @return ApiMachinesTPStartMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPStartMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPStartMachineRequest {
	return ApiMachinesTPStartMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineDetailResponseModel
func (a *MachinesTPApiService) MachinesTPStartMachineExecute(r ApiMachinesTPStartMachineRequest) (*MachineDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPStartMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$start"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailResponseRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailResponseRequired", r.detailResponseRequired, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPSuspendMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	detailResponseRequired *bool
	async *bool
	delay *int32
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Identify if the API need to return detail info in response model.             Set to false will improve performance with return basic machine model.
func (r ApiMachinesTPSuspendMachineRequest) DetailResponseRequired(detailResponseRequired bool) ApiMachinesTPSuspendMachineRequest {
	r.detailResponseRequired = &detailResponseRequired
	return r
}

// If &#x60;true&#x60;, the machine will be suspended as a background task. This is recommended as this operation may take some time to run, and if it exceeds 90 seconds the request may time out. The task will have JobType SuspendMachines. When the task is complete it will redirect to GetMachine. The job&#39;s Parameters will contain properties: * _Id_ - ID of the machine being suspended, * _Name_ - Name of the machine being suspended.
func (r ApiMachinesTPSuspendMachineRequest) Async(async bool) ApiMachinesTPSuspendMachineRequest {
	r.async = &async
	return r
}

// Suspend a machine after the specified number of seconds delay, If &#x60;null&#x60;, the machine will be suspended without delay.
func (r ApiMachinesTPSuspendMachineRequest) Delay(delay int32) ApiMachinesTPSuspendMachineRequest {
	r.delay = &delay
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPSuspendMachineRequest) Authorization(authorization string) ApiMachinesTPSuspendMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPSuspendMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPSuspendMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPSuspendMachineRequest) XActionName(xActionName string) ApiMachinesTPSuspendMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPSuspendMachineRequest) Execute() (*MachineDetailResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPSuspendMachineExecute(r)
}

/*
MachinesTPSuspendMachine Suspend a machine.

Suspend a machine.  The machine must be capable of power management.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to suspend.
 @param customerid
 @param siteid
 @return ApiMachinesTPSuspendMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPSuspendMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPSuspendMachineRequest {
	return ApiMachinesTPSuspendMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineDetailResponseModel
func (a *MachinesTPApiService) MachinesTPSuspendMachineExecute(r ApiMachinesTPSuspendMachineRequest) (*MachineDetailResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineDetailResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPSuspendMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailResponseRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailResponseRequired", r.detailResponseRequired, "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	if r.delay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delay", r.delay, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPTestMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPTestMachineRequest) Authorization(authorization string) ApiMachinesTPTestMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPTestMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPTestMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPTestMachineRequest) XActionName(xActionName string) ApiMachinesTPTestMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPTestMachineRequest) Execute() (*MachineTestResponseModel, *http.Response, error) {
	return r.ApiService.MachinesTPTestMachineExecute(r)
}

/*
MachinesTPTestMachine Run Cloud Health Check on a VDA machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine to test.
 @param customerid
 @param siteid
 @return ApiMachinesTPTestMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPTestMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPTestMachineRequest {
	return ApiMachinesTPTestMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
//  @return MachineTestResponseModel
func (a *MachinesTPApiService) MachinesTPTestMachineExecute(r ApiMachinesTPTestMachineRequest) (*MachineTestResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineTestResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPTestMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/$test"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesTPUpdateMachineCatalogMachineRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	update *UpdateMachineRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details of the machine to update.
func (r ApiMachinesTPUpdateMachineCatalogMachineRequest) Update(update UpdateMachineRequestModel) ApiMachinesTPUpdateMachineCatalogMachineRequest {
	r.update = &update
	return r
}

// If &#x60;true&#x60;, the tag will be created as a background task. The task will have JobType UpdateMachineCatalogMachine. When the task is complete it will redirect to \&quot;GetMachine(string)\&quot;. The job&#39;s Parameters will contain properties:  * _Id_ - ID of the machine being updated, * _Name_ - Name of the machine being updated.
func (r ApiMachinesTPUpdateMachineCatalogMachineRequest) Async(async bool) ApiMachinesTPUpdateMachineCatalogMachineRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPUpdateMachineCatalogMachineRequest) Authorization(authorization string) ApiMachinesTPUpdateMachineCatalogMachineRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPUpdateMachineCatalogMachineRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPUpdateMachineCatalogMachineRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPUpdateMachineCatalogMachineRequest) XActionName(xActionName string) ApiMachinesTPUpdateMachineCatalogMachineRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPUpdateMachineCatalogMachineRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesTPUpdateMachineCatalogMachineExecute(r)
}

/*
MachinesTPUpdateMachineCatalogMachine Update a machine.

Update a machine.  Typically used to change the assignment of a
statically-assigned machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Machine to update.  May be specified by name, ID, or SID.
 @param customerid
 @param siteid
 @return ApiMachinesTPUpdateMachineCatalogMachineRequest
*/
func (a *MachinesTPApiService) MachinesTPUpdateMachineCatalogMachine(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPUpdateMachineCatalogMachineRequest {
	return ApiMachinesTPUpdateMachineCatalogMachineRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachinesTPApiService) MachinesTPUpdateMachineCatalogMachineExecute(r ApiMachinesTPUpdateMachineCatalogMachineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPUpdateMachineCatalogMachine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.update == nil {
		return nil, reportError("update is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.update
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesTPUpdateMachineUpgradeScheduleRequest struct {
	ctx context.Context
	ApiService *MachinesTPApiService
	nameOrId string
	customerid string
	siteid string
	request *UpdateUpgradeScheduleRequestModel
	async *bool
	authorization *string
	citrixTransactionId *string
	xActionName *string
}

// Details about the updated VDA upgrade schedule.
func (r ApiMachinesTPUpdateMachineUpgradeScheduleRequest) Request(request UpdateUpgradeScheduleRequestModel) ApiMachinesTPUpdateMachineUpgradeScheduleRequest {
	r.request = &request
	return r
}

// If &#x60;true&#x60;, the VDA upgrade schedule will be updated as a background task.
func (r ApiMachinesTPUpdateMachineUpgradeScheduleRequest) Async(async bool) ApiMachinesTPUpdateMachineUpgradeScheduleRequest {
	r.async = &async
	return r
}

// Citrix Cloud authorization header: Bearer {token}
func (r ApiMachinesTPUpdateMachineUpgradeScheduleRequest) Authorization(authorization string) ApiMachinesTPUpdateMachineUpgradeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Transaction ID that will be used to track this request. If not provided, a new GUID will be generated and returned.
func (r ApiMachinesTPUpdateMachineUpgradeScheduleRequest) CitrixTransactionId(citrixTransactionId string) ApiMachinesTPUpdateMachineUpgradeScheduleRequest {
	r.citrixTransactionId = &citrixTransactionId
	return r
}

// Orchestration Action Name
func (r ApiMachinesTPUpdateMachineUpgradeScheduleRequest) XActionName(xActionName string) ApiMachinesTPUpdateMachineUpgradeScheduleRequest {
	r.xActionName = &xActionName
	return r
}

func (r ApiMachinesTPUpdateMachineUpgradeScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesTPUpdateMachineUpgradeScheduleExecute(r)
}

/*
MachinesTPUpdateMachineUpgradeSchedule Reschedule a pending VDA upgrade schedule for a machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameOrId Name or ID of the machine.
 @param customerid
 @param siteid
 @return ApiMachinesTPUpdateMachineUpgradeScheduleRequest
*/
func (a *MachinesTPApiService) MachinesTPUpdateMachineUpgradeSchedule(ctx context.Context, nameOrId string, customerid string, siteid string) ApiMachinesTPUpdateMachineUpgradeScheduleRequest {
	return ApiMachinesTPUpdateMachineUpgradeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		nameOrId: nameOrId,
		customerid: customerid,
		siteid: siteid,
	}
}

// Execute executes the request
func (a *MachinesTPApiService) MachinesTPUpdateMachineUpgradeScheduleExecute(r ApiMachinesTPUpdateMachineUpgradeScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesTPApiService.MachinesTPUpdateMachineUpgradeSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/techpreview/{customerid}/{siteid}/Machines/{nameOrId}/UpgradeSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", url.PathEscape(parameterValueToString(r.nameOrId, "nameOrId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerid"+"}", url.PathEscape(parameterValueToString(r.customerid, "customerid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteid"+"}", url.PathEscape(parameterValueToString(r.siteid, "siteid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	}
	if r.citrixTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Citrix-TransactionId", r.citrixTransactionId, "")
	}
	if r.xActionName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-ActionName", r.xActionName, "")
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
